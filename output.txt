æ–‡ä»¶å¤¹ 'CloudArt' çš„å±‚çº§ç»“æ„:

â””â”€â”€ CloudArt/
    â”œâ”€â”€ .gitignore
    â”œâ”€â”€ CMakeLists.txt
    â”œâ”€â”€ output.txt
    â”œâ”€â”€ readme.md
    â””â”€â”€ .qtcreator/
        â”œâ”€â”€ CMakeLists.txt.user
        â””â”€â”€ qtc-cmake-presets-bvhIHIpF/
        â””â”€â”€ qtc-cmake-presets-UMKIggZP/
        â””â”€â”€ qtc-cmake-presets-XZNvAZIY/
        â””â”€â”€ qtc-cmake-presets-ZvFdVnmy/
    â””â”€â”€ resources/
        â”œâ”€â”€ resources.qrc
        â””â”€â”€ images/
            â”œâ”€â”€ 426DAA5942BF4BCE235CD3004582BC3A.png
            â”œâ”€â”€ ComfyUI_00292_.png
            â”œâ”€â”€ ComfyUI_00301_.png
            â”œâ”€â”€ HideConversation.png
            â”œâ”€â”€ historypic.png
            â”œâ”€â”€ loading.gif
            â”œâ”€â”€ logo.png
            â”œâ”€â”€ setting.png
            â”œâ”€â”€ t2i_demo.gif
            â”œâ”€â”€ å›¾ç”Ÿå›¾æ¼”ç¤º.gif
            â”œâ”€â”€ å›¾ç”Ÿå›¾æ¼”ç¤º.png
            â”œâ”€â”€ æ–‡ç”Ÿå›¾æ¼”ç¤º.gif
            â”œâ”€â”€ æ–‡ç”Ÿå›¾æ¼”ç¤º.png
        â””â”€â”€ workflows/
            â”œâ”€â”€ i2i_render.json
            â”œâ”€â”€ i2i_vision.json
            â”œâ”€â”€ Z-Imageæ–‡ç”Ÿå›¾.json
            â”œâ”€â”€ é«˜æ¸…ä¿®å¤.json
    â””â”€â”€ src/
        â”œâ”€â”€ CMakeLists.txt
        â”œâ”€â”€ logo.ico
        â”œâ”€â”€ logo.rc
        â”œâ”€â”€ main.cpp
        â””â”€â”€ Core/
            â”œâ”€â”€ WorkflowManager.cpp
            â”œâ”€â”€ WorkflowManager.h
        â””â”€â”€ Database/
            â”œâ”€â”€ DatabaseManager.cpp
            â”œâ”€â”€ DatabaseManager.h
        â””â”€â”€ Model/
            â”œâ”€â”€ DataModels.h
            â”œâ”€â”€ WorkflowTypes.h
        â””â”€â”€ Network/
            â”œâ”€â”€ ComfyApiService.cpp
            â”œâ”€â”€ ComfyApiService.h
        â””â”€â”€ Ui/
            â”œâ”€â”€ MainWindow.cpp
            â”œâ”€â”€ MainWindow.h
            â””â”€â”€ Components/
                â”œâ”€â”€ ChatArea.cpp
                â”œâ”€â”€ ChatArea.h
                â”œâ”€â”€ ChatBubble.cpp
                â”œâ”€â”€ ChatBubble.h
                â”œâ”€â”€ HistoryGallery.cpp
                â”œâ”€â”€ HistoryGallery.h
                â”œâ”€â”€ ImageViewer.cpp
                â”œâ”€â”€ ImageViewer.h
                â”œâ”€â”€ InputPanel.cpp
                â”œâ”€â”€ InputPanel.h
                â”œâ”€â”€ ReferencePopup.cpp
                â”œâ”€â”€ ReferencePopup.h
                â”œâ”€â”€ SessionItem.cpp
                â”œâ”€â”€ SessionItem.h
                â”œâ”€â”€ SessionList.cpp
                â”œâ”€â”€ SessionList.h
                â”œâ”€â”€ SettingsDialog.cpp
                â”œâ”€â”€ SettingsDialog.h
                â”œâ”€â”€ SidebarControl.cpp
                â”œâ”€â”€ SidebarControl.h
                â”œâ”€â”€ WorkflowCard.cpp
                â”œâ”€â”€ WorkflowCard.h
                â”œâ”€â”€ WorkflowSelector.cpp
                â”œâ”€â”€ WorkflowSelector.h

================================================================================

--- æ–‡ä»¶å¼€å§‹: CMakeLists.txt ---

cmake_minimum_required(VERSION 3.16)

# é¡¹ç›®åç§°å’Œç‰ˆæœ¬
project(CloudArt VERSION 0.1 LANGUAGES CXX)

# è®¾ç½® C++ æ ‡å‡† (C++17 æ˜¯ç°ä»£ Qt6 å¼€å‘çš„æ ‡é…)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# Qt æ ¸å¿ƒè®¾ç½®ï¼šè‡ªåŠ¨å¤„ç†å…ƒå¯¹è±¡ç³»ç»Ÿ(MOC)ã€èµ„æº(RCC)å’ŒUIæ–‡ä»¶(UIC)
set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTORCC ON)
set(CMAKE_AUTOUIC ON)

# æŸ¥æ‰¾ Qt6 ç»„ä»¶ (æ ¸å¿ƒç»„ä»¶ã€ç•Œé¢ç»„ä»¶ã€ç½‘ç»œç»„ä»¶)
find_package(Qt6 COMPONENTS Widgets Network WebSockets Sql REQUIRED)

# æ·»åŠ å­ç›®å½• (å°†æ„å»ºé€»è¾‘ä¸‹æ”¾åˆ° src æ–‡ä»¶å¤¹)
add_subdirectory(src)


--- æ–‡ä»¶ç»“æŸ: CMakeLists.txt ---

--- æ–‡ä»¶å¼€å§‹: output.txt ---



--- æ–‡ä»¶ç»“æŸ: output.txt ---

--- æ–‡ä»¶å¼€å§‹: readme.md ---

# CloudArt - AIå›¾åƒç”Ÿæˆæ¡Œé¢å®¢æˆ·ç«¯

åŸºäºQt6çš„AIç»˜ç”»å·¥å…·ï¼Œæ¥å…¥ComfyUIæœåŠ¡å™¨ï¼Œæ”¯æŒæ–‡ç”Ÿå›¾ã€å›¾ç”Ÿå›¾ã€é«˜æ¸…ä¿®å¤ã€‚

## åŠŸèƒ½
- ä¼šè¯æŒä¹…åŒ–ï¼ˆSQLiteï¼‰
- å®æ—¶è¿›åº¦ï¼ˆWebSocketï¼‰
- å‚è€ƒå›¾ä¸Šä¼ 
- å†å²ç”»å»Š
- ç²¾è‡´æ·±è‰²UI + GIFåŠ¨æ•ˆ

## æ¼”ç¤º
![æ–‡ç”Ÿå›¾](resources/images/æ–‡ç”Ÿå›¾æ¼”ç¤º.gif)
![å›¾ç”Ÿå›¾](resources/images/å›¾ç”Ÿå›¾æ¼”ç¤º.gif)

## æŠ€æœ¯æ ˆ
Qt6 + C++17 + CMake + SQLite + WebSocket

## å¦‚ä½•è¿è¡Œ
éœ€è¦Qt6ç¯å¢ƒå’ŒComfyUIæœåŠ¡å™¨ã€‚# CloudArt


--- æ–‡ä»¶ç»“æŸ: readme.md ---

--- æ–‡ä»¶å¼€å§‹: resources\workflows\i2i_render.json ---

{
  "3": {
    "inputs": {
      "seed": 275879196400549,
      "steps": 8,
      "cfg": 1,
      "sampler_name": "dpmpp_2m_sde",
      "scheduler": "sgm_uniform",
      "denoise": 1,
      "model": [
        "51",
        0
      ],
      "positive": [
        "6",
        0
      ],
      "negative": [
        "70",
        0
      ],
      "latent_image": [
        "53",
        0
      ]
    },
    "class_type": "KSampler",
    "_meta": {
      "title": "Ké‡‡æ ·å™¨"
    }
  },
  "6": {
    "inputs": {
      "text": "ä¸€ä½å¹´è½»å¥³æ€§ï¼Œçº¦17-19å²ï¼Œä¸œäºšé¢å­”ï¼Œé•¿ç›´é»‘å‘å¸¦é½åˆ˜æµ·ï¼Œçœ¼ç¥ä¸“æ³¨ç•¥å¸¦æ…µæ‡’ï¼Œå˜´å”‡å¾®å¼ å«ç€ä¸€æ ¹ç»†æœ¨ç­¾ï¼›èº«ç©¿é»‘è‰²æ ¡æœå¤–å¥—æ­é…çº¢è‰²é¢†ç»“ä¸æ·±è‰²ç™¾è¤¶è£™ï¼Œå†…æ­ç™½è‰²è¡¬è¡«ï¼Œä¸‹èº«ç©¿ç€ç™½è‰²çŸ­è¢œé…çš®é‹ï¼Œå¤–å¥—æœ‰ç ´æ´è®¾è®¡ï¼Œè¡£æ‘†éšåŠ¨ä½œé£˜åŠ¨ï¼›èº«ä½“æ–œå€šåœ¨æ°´æ³¥å°é˜¶ä¸Šï¼Œå³è…¿æŠ¬èµ·å‘ˆåŠåå§¿ï¼Œå·¦æ‰‹è½»æ‰¶é˜¶æ²¿ï¼Œå³æ‰‹æŒæœ¨ç­¾é è¿‘å”‡è¾¹ï¼Œæ•´ä½“å§¿æ€æ”¾æ¾è€Œå¯Œæœ‰åŠ¨æ„Ÿï¼›èº«å¤„ç°ä»£éƒ½å¸‚è¡—å¤´é˜¶æ¢¯æ—ï¼Œä¸¤ä¾§æ˜¯è´´æ»¡æ—¥æ–‡å¹¿å‘Šç‰Œçš„åŸå¸‚å»ºç­‘å¢™é¢ï¼ŒçŸ³é˜¶è¡¨é¢å› é£åŒ–æ˜¾å‡ºç°ç™½é¢—ç²’ä¸æ±¡è¿¹ï¼Œè¿œå¤„å¯è§é«˜æ¥¼ç»ç’ƒå¹•å¢™åå°„å¤©å…‰ï¼›é¡¶éƒ¨åå·¦å¼ºå…‰ç…§å°„å½¢æˆæ˜æš—è¿‡æ¸¡ï¼Œé˜´å½±è½åœ¨è…¿éƒ¨ä¸å°é˜¶ç¼éš™å¤„ï¼Œç”»é¢ä¸»è°ƒä¸ºä¸­æ€§å†·ç°è‰²ç³»ä½†å±€éƒ¨å—å…‰åŒºåŸŸæ³›æš–é»„ï¼Œå¢å¼ºç«‹ä½“æ„Ÿï¼›è‚Œè‚¤å‘ˆç°ç»†è…»å“‘å…‰è´¨æ„Ÿï¼Œæ¯›å‘æ ¹éƒ¨æ¸…æ™°å¯è§ï¼Œè¡£ç‰©çº¤ç»´çº¹è·¯åˆ†æ˜ï¼Œçš®é©é‹é¢æœ‰æ²¹æ¶¦åå…‰ï¼Œæ··å‡åœŸå°é˜¶ç²—ç²å¤šå­”ä¸”æ²¾æŸ“å°˜åœŸç—•è¿¹ï¼›8Kè¶…æ¸…ç”»è´¨ï¼Œæè‡´ç»†èŠ‚æ‹‰æ»¡ï¼Œé•œå¤´é”åˆ©èšç„¦äºé¢éƒ¨ä¸æ‰‹éƒ¨ç‰¹å†™ï¼Œé«˜åŠ¨æ€èŒƒå›´å¯¹æ¯”åº¦ï¼Œä¸“ä¸šçº§å†™å®æ‘„å½±æ•ˆæœ",
      "clip": [
        "34",
        0
      ]
    },
    "class_type": "CLIPTextEncode",
    "_meta": {
      "title": "CLIP Text Encode (Positive Prompt)"
    }
  },
  "9": {
    "inputs": {
      "filename_prefix": "comfyuii2i",
      "images": [
        "80",
        0
      ]
    },
    "class_type": "SaveImage",
    "_meta": {
      "title": "ä¿å­˜å›¾åƒ"
    }
  },
  "17": {
    "inputs": {
      "vae_name": "ae.safetensors"
    },
    "class_type": "VAELoader",
    "_meta": {
      "title": "åŠ è½½VAE"
    }
  },
  "30": {
    "inputs": {
      "image": "pasted/image (22).png"
    },
    "class_type": "LoadImage",
    "_meta": {
      "title": "åŠ è½½å›¾åƒ"
    }
  },
  "34": {
    "inputs": {
      "clip_name": "qwen_3_4b.safetensors",
      "type": "lumina2",
      "device": "default"
    },
    "class_type": "CLIPLoader",
    "_meta": {
      "title": "åŠ è½½CLIP"
    }
  },
  "35": {
    "inputs": {
      "unet_name": "zImage_turbo.safetensors",
      "weight_dtype": "default"
    },
    "class_type": "UNETLoader",
    "_meta": {
      "title": "UNetåŠ è½½å™¨"
    }
  },
  "50": {
    "inputs": {
      "name": "Z-Image-Turbo-Fun-Controlnet-Union-2.1.safetensors"
    },
    "class_type": "ModelPatchLoader",
    "_meta": {
      "title": "ModelPatchLoader"
    }
  },
  "51": {
    "inputs": {
      "strength": 0.8,
      "model": [
        "35",
        0
      ],
      "model_patch": [
        "50",
        0
      ],
      "vae": [
        "17",
        0
      ],
      "image": [
        "52",
        0
      ]
    },
    "class_type": "QwenImageDiffsynthControlnet",
    "_meta": {
      "title": "QwenImageDiffsynthControlnet"
    }
  },
  "52": {
    "inputs": {
      "preprocessor": "DepthAnythingV2Preprocessor",
      "resolution": 1024,
      "image": [
        "83",
        0
      ]
    },
    "class_type": "AIO_Preprocessor",
    "_meta": {
      "title": "AIO Aux Preprocessor"
    }
  },
  "53": {
    "inputs": {
      "width": [
        "54",
        0
      ],
      "height": [
        "54",
        1
      ],
      "batch_size": 1
    },
    "class_type": "EmptyLatentImage",
    "_meta": {
      "title": "ç©ºLatentå›¾åƒ"
    }
  },
  "54": {
    "inputs": {
      "image": [
        "83",
        0
      ]
    },
    "class_type": "GetImageSize",
    "_meta": {
      "title": "è·å–å›¾åƒå°ºå¯¸"
    }
  },
  "69": {
    "inputs": {
      "images": [
        "52",
        0
      ]
    },
    "class_type": "PreviewImage",
    "_meta": {
      "title": "é¢„è§ˆå›¾åƒ"
    }
  },
  "70": {
    "inputs": {
      "conditioning": [
        "6",
        0
      ]
    },
    "class_type": "ConditioningZeroOut",
    "_meta": {
      "title": "æ¡ä»¶é›¶åŒ–"
    }
  },
  "71": {
    "inputs": {
      "samples": [
        "3",
        0
      ],
      "vae": [
        "17",
        0
      ]
    },
    "class_type": "VAEDecode",
    "_meta": {
      "title": "VAEè§£ç "
    }
  },
  "80": {
    "inputs": {
      "anything": [
        "71",
        0
      ]
    },
    "class_type": "easy cleanGpuUsed",
    "_meta": {
      "title": "æ¸…ç†æ˜¾å­˜å ç”¨"
    }
  },
  "83": {
    "inputs": {
      "mode": "Megapixel Limit",
      "target_value": 1024,
      "image": [
        "30",
        0
      ]
    },
    "class_type": "MySmartResize",
    "_meta": {
      "title": "ğŸ› ï¸ My Smart Resize"
    }
  }
}

--- æ–‡ä»¶ç»“æŸ: resources\workflows\i2i_render.json ---

--- æ–‡ä»¶å¼€å§‹: resources\workflows\i2i_vision.json ---

{
  "1": {
    "inputs": {
      "model_name": "Huihui-Qwen3-VL-8B-Instruct-abliterated",
      "quantization": "4-bit (VRAM-friendly)",
      "attention_mode": "sdpa",
      "preset_prompt": "ğŸ–¼ï¸ Detailed Description",
      "custom_prompt": "è¯·åˆ†æè¿™å¼ å›¾ç‰‡ï¼Œç”Ÿæˆç”¨äºAIç»˜ç”»çš„å†™å®é£æ ¼ä¸­æ–‡æç¤ºè¯ï¼Œä¸¥æ ¼æŒ‰ç…§ä»¥ä¸‹è¦æ±‚è¾“å‡ºï¼š\n1. ä¸»ä½“ç»†èŠ‚ï¼šæå–å›¾ç‰‡æ ¸å¿ƒä¸»ä½“ï¼ˆäººç‰©/ç‰©ä½“/åœºæ™¯ï¼‰ï¼Œè‹¥ä¸ºäºŒæ¬¡å…ƒå›¾ç‰‡ï¼Œéœ€å°†å¤¸å¼ ç‰¹å¾è½¬åŒ–ä¸ºå†™å®ç»†èŠ‚ï¼ˆå¦‚åŠ¨æ¼«å¤§çœ¼ç›æ”¹ä¸ºè‡ªç„¶çœ¼å‹ï¼Œç®€åŒ–å‘å‹è½¬ä¸ºçœŸå®å‘è´¨ï¼‰ï¼Œç»†åŒ–æè¿°æ€§åˆ«ã€å¹´é¾„ã€æœé¥°ã€å§¿æ€ã€è¡¨æƒ…ç­‰ç‰¹å¾ã€‚\n2. åœºæ™¯ç¯å¢ƒï¼šè¯¦ç»†æè¿°èƒŒæ™¯åœºæ™¯ï¼ˆå®¤å†…/æˆ·å¤–/åŸå¸‚/è‡ªç„¶ï¼‰ï¼Œè¡¥å……å†™å®åŒ–ç»†èŠ‚ï¼ˆå¦‚è€æ—§å¢™å£çš„æ–‘é©³çº¹ç†ã€é˜³å…‰é€è¿‡æ ‘å¶çš„å…‰æ–‘ã€åœ°é¢çš„æ°´æ¸ï¼‰ï¼ŒäºŒæ¬¡å…ƒåœºæ™¯éœ€æ›¿æ¢ä¸ºç°å®ä¸­å¯¹åº”çš„çœŸå®åœºæ™¯ã€‚\n3. å…‰å½±æ°›å›´ï¼šæ˜ç¡®å…‰æºæ–¹å‘ï¼ˆä¾§å…‰/é€†å…‰/é¡¶å…‰ï¼‰ã€å…‰çº¿å¼ºåº¦ï¼ˆæŸ”å’Œ/å¼ºçƒˆï¼‰ã€è‰²è°ƒï¼ˆå†·è‰²è°ƒ/æš–è‰²è°ƒï¼‰ï¼Œè¥é€ å†™å®æ°›å›´ï¼ˆé™è°§ã€ç´§å¼ ã€æ¸©é¦¨ã€ç”µå½±æ„Ÿï¼‰ã€‚\n4. æè´¨è´¨æ„Ÿï¼šæè¿°ä¸»ä½“å’Œåœºæ™¯çš„æè´¨ç»†èŠ‚ï¼ˆä¸ç»¸è¡£ç‰©çš„å…‰æ³½ã€é‡‘å±çš„åå…‰ã€çš®è‚¤çš„æ¯›å­”ã€å²©çŸ³çš„ç²—ç³™çº¹ç†ã€å¸ƒæ–™çš„è¤¶çš±ï¼‰ã€‚\n5. ç”»è´¨å‚æ•°ï¼šæ·»åŠ å†™å®æ‘„å½±å…³é”®è¯ï¼ˆ8Kåˆ†è¾¨ç‡ã€é«˜æ¸…ã€ç»†èŠ‚æ‹‰æ»¡ã€é”åˆ©å¯¹ç„¦ã€é«˜å¯¹æ¯”åº¦ã€ä¸“ä¸šçº§ç”»è´¨ï¼‰ã€‚\n6. æ ¼å¼è¦æ±‚ï¼šç›´æ¥è¾“å‡ºä¸­æ–‡æç¤ºè¯ï¼Œç”¨ä¸­æ–‡é€—å·åˆ†éš”ï¼ŒæŒ‰ã€Œä¸»ä½“â†’åœºæ™¯â†’å…‰å½±â†’æè´¨â†’ç”»è´¨ã€çš„é¡ºåºæ’åˆ—ï¼Œæ— éœ€ä»»ä½•è§£é‡Šæ€§æ–‡å­—ï¼Œç¡®ä¿å¯ç›´æ¥ç”¨äºzimageç”Ÿæˆå†™å®å›¾ç‰‡ã€‚",
      "max_tokens": 1024,
      "keep_model_loaded": false,
      "seed": 2293362220,
      "image": [
        "6",
        0
      ]
    },
    "class_type": "AILab_QwenVL",
    "_meta": {
      "title": "QwenVL"
    }
  },
  "3": {
    "inputs": {
      "image": "011f4ac2b959b7875cad923fcd97cd86_720.jpg"
    },
    "class_type": "LoadImage",
    "_meta": {
      "title": "åŠ è½½å›¾åƒ"
    }
  },
  "4": {
    "inputs": {
      "preview": "",
      "previewMode": null,
      "source": [
        "7",
        0
      ]
    },
    "class_type": "PreviewAny",
    "_meta": {
      "title": "é¢„è§ˆä»»æ„"
    }
  },
  "6": {
    "inputs": {
      "mode": "Long Edge Limit",
      "target_value": 1024,
      "image": [
        "3",
        0
      ]
    },
    "class_type": "MySmartResize",
    "_meta": {
      "title": "ğŸ› ï¸ My Smart Resize"
    }
  },
  "7": {
    "inputs": {
      "anything": [
        "1",
        0
      ]
    },
    "class_type": "easy cleanGpuUsed",
    "_meta": {
      "title": "æ¸…ç†æ˜¾å­˜å ç”¨"
    }
  }
}

--- æ–‡ä»¶ç»“æŸ: resources\workflows\i2i_vision.json ---

--- æ–‡ä»¶å¼€å§‹: resources\workflows\Z-Imageæ–‡ç”Ÿå›¾.json ---

{
  "3": {
    "inputs": {
      "vae_name": "ae.safetensors"
    },
    "class_type": "VAELoader",
    "_meta": {
      "title": "åŠ è½½VAE"
    }
  },
  "4": {
    "inputs": {
      "seed": 859214507156335,
      "steps": 8,
      "cfg": 1,
      "sampler_name": "euler",
      "scheduler": "simple",
      "denoise": 1,
      "model": [
        "23",
        0
      ],
      "positive": [
        "5",
        0
      ],
      "negative": [
        "25",
        0
      ],
      "latent_image": [
        "7",
        0
      ]
    },
    "class_type": "KSampler",
    "_meta": {
      "title": "Ké‡‡æ ·å™¨"
    }
  },
  "5": {
    "inputs": {
      "text": " ",
      "clip": [
        "24",
        0
      ]
    },
    "class_type": "CLIPTextEncode",
    "_meta": {
      "title": "CLIPæ–‡æœ¬ç¼–ç "
    }
  },
  "7": {
    "inputs": {
      "width": 720,
      "height": 1080,
      "batch_size": 1
    },
    "class_type": "EmptyLatentImage",
    "_meta": {
      "title": "ç©ºLatentå›¾åƒ"
    }
  },
  "8": {
    "inputs": {
      "samples": [
        "4",
        0
      ],
      "vae": [
        "3",
        0
      ]
    },
    "class_type": "VAEDecode",
    "_meta": {
      "title": "VAEè§£ç "
    }
  },
  "20": {
    "inputs": {
      "filename_prefix": "ComfyUI",
      "images": [
        "29",
        0
      ]
    },
    "class_type": "SaveImage",
    "_meta": {
      "title": "ä¿å­˜å›¾åƒ"
    }
  },
  "23": {
    "inputs": {
      "unet_name": "zImage_turbo.safetensors",
      "weight_dtype": "default"
    },
    "class_type": "UNETLoader",
    "_meta": {
      "title": "UNetåŠ è½½å™¨"
    }
  },
  "24": {
    "inputs": {
      "clip_name": "qwen_3_4b.safetensors",
      "type": "qwen_image",
      "device": "default"
    },
    "class_type": "CLIPLoader",
    "_meta": {
      "title": "åŠ è½½CLIP"
    }
  },
  "25": {
    "inputs": {
      "text": "",
      "clip": [
        "24",
        0
      ]
    },
    "class_type": "CLIPTextEncode",
    "_meta": {
      "title": "CLIPæ–‡æœ¬ç¼–ç "
    }
  },
  "29": {
    "inputs": {
      "anything": [
        "8",
        0
      ]
    },
    "class_type": "easy cleanGpuUsed",
    "_meta": {
      "title": "æ¸…ç†æ˜¾å­˜å ç”¨"
    }
  }
}

--- æ–‡ä»¶ç»“æŸ: resources\workflows\Z-Imageæ–‡ç”Ÿå›¾.json ---

--- æ–‡ä»¶å¼€å§‹: resources\workflows\é«˜æ¸…ä¿®å¤.json ---

{
  "1": {
    "inputs": {
      "filename_prefix": "ComfyUI",
      "images": [
        "5",
        0
      ]
    },
    "class_type": "SaveImage",
    "_meta": {
      "title": "ä¿å­˜å›¾åƒ"
    }
  },
  "2": {
    "inputs": {
      "seed": 580323588,
      "resolution": 1536,
      "max_resolution": 0,
      "batch_size": 1,
      "uniform_batch_size": false,
      "color_correction": "wavelet",
      "temporal_overlap": 0,
      "prepend_frames": 0,
      "input_noise_scale": 0,
      "latent_noise_scale": 0,
      "offload_device": "cpu",
      "enable_debug": false,
      "image": [
        "6",
        0
      ],
      "dit": [
        "4",
        0
      ],
      "vae": [
        "3",
        0
      ]
    },
    "class_type": "SeedVR2VideoUpscaler",
    "_meta": {
      "title": "SeedVR2 Video Upscaler (v2.5.22)"
    }
  },
  "3": {
    "inputs": {
      "model": "ema_vae_fp16.safetensors",
      "device": "cuda:0",
      "encode_tiled": false,
      "encode_tile_size": 1024,
      "encode_tile_overlap": 128,
      "decode_tiled": false,
      "decode_tile_size": 1024,
      "decode_tile_overlap": 128,
      "tile_debug": "false",
      "offload_device": "cpu",
      "cache_model": false
    },
    "class_type": "SeedVR2LoadVAEModel",
    "_meta": {
      "title": "SeedVR2 (Down)Load VAE Model"
    }
  },
  "4": {
    "inputs": {
      "model": "seedvr2_ema_3b_fp8_e4m3fn.safetensors",
      "device": "cuda:0",
      "blocks_to_swap": 32,
      "swap_io_components": false,
      "offload_device": "cpu",
      "cache_model": false,
      "attention_mode": "sdpa"
    },
    "class_type": "SeedVR2LoadDiTModel",
    "_meta": {
      "title": "SeedVR2 (Down)Load DiT Model"
    }
  },
  "5": {
    "inputs": {
      "anything": [
        "2",
        0
      ]
    },
    "class_type": "easy cleanGpuUsed",
    "_meta": {
      "title": "æ¸…ç†æ˜¾å­˜å ç”¨"
    }
  },
  "6": {
    "inputs": {
      "image": "comfyuii2i_00140_.png"
    },
    "class_type": "LoadImage",
    "_meta": {
      "title": "åŠ è½½å›¾åƒ"
    }
  }
}

--- æ–‡ä»¶ç»“æŸ: resources\workflows\é«˜æ¸…ä¿®å¤.json ---

--- æ–‡ä»¶å¼€å§‹: src\CMakeLists.txt ---

# å®šä¹‰æºä»£ç æ–‡ä»¶åˆ—è¡¨
set(SOURCES
    main.cpp
    logo.rc
    Ui/MainWindow.h
    Ui/MainWindow.cpp

    #Core
    Core/WorkflowManager.h
    Core/WorkflowManager.cpp

    # Model
    Model/WorkflowTypes.h
    Model/DataModels.h

    # Database
    Database/DatabaseManager.h
    Database/DatabaseManager.cpp

    # Network
    Network/ComfyApiService.h
    Network/ComfyApiService.cpp

    # Components
    Ui/Components/SidebarControl.h
    Ui/Components/SidebarControl.cpp
    Ui/Components/SessionList.h
    Ui/Components/SessionList.cpp
    Ui/Components/ChatArea.h
    Ui/Components/ChatArea.cpp
    Ui/Components/InputPanel.h
    Ui/Components/InputPanel.cpp
    Ui/Components/WorkflowSelector.h
    Ui/Components/WorkflowSelector.cpp
    Ui/Components/WorkflowCard.h
    Ui/Components/WorkflowCard.cpp
    Ui/Components/ReferencePopup.h
    Ui/Components/ReferencePopup.cpp
    Ui/Components/SessionItem.h
    Ui/Components/SessionItem.cpp
    Ui/Components/ChatBubble.h
    Ui/Components/ChatBubble.cpp
    Ui/Components/ImageViewer.h
    Ui/Components/ImageViewer.cpp
    Ui/Components/HistoryGallery.h
    Ui/Components/HistoryGallery.cpp
    Ui/Components/SettingsDialog.h
    Ui/Components/SettingsDialog.cpp
    ../resources/resources.qrc
)

# å®šä¹‰å¯æ‰§è¡Œæ–‡ä»¶
add_executable(CloudArt ${SOURCES})

# é“¾æ¥ Qt åº“
target_link_libraries(CloudArt PRIVATE
    Qt6::Widgets
    Qt6::Network
    Qt6::WebSockets
    Qt6::Sql
)

# è®¾ç½® Windows å­ç³»ç»Ÿ (é¿å…è¿è¡Œæ—¶å¼¹å‡ºé»‘è‰² cmd çª—å£ï¼Œä½†åœ¨å¼€å‘è°ƒè¯•æœŸå¯ä»¥å…ˆæ³¨é‡Šæ‰ä¸‹é¢è¿™è¡Œ)
set_target_properties(CloudArt PROPERTIES WIN32_EXECUTABLE ON)


--- æ–‡ä»¶ç»“æŸ: src\CMakeLists.txt ---

--- æ–‡ä»¶å¼€å§‹: src\main.cpp ---

/**
 * @file main.cpp
 * @brief åº”ç”¨ç¨‹åºä¸»å…¥å£æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶åŒ…å«åº”ç”¨ç¨‹åºçš„mainå‡½æ•°ï¼Œè´Ÿè´£åº”ç”¨ç¨‹åºçš„åˆå§‹åŒ–ã€æ•°æ®åº“è¿æ¥å’Œä¸»çª—å£æ˜¾ç¤ºã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#include <QApplication>
#include "Ui/MainWindow.h"
#include "Database/DatabaseManager.h"

/**
 * @brief åº”ç”¨ç¨‹åºä¸»å‡½æ•°
 * @param argc å‘½ä»¤è¡Œå‚æ•°ä¸ªæ•°
 * @param argv å‘½ä»¤è¡Œå‚æ•°æ•°ç»„
 * @return int åº”ç”¨ç¨‹åºé€€å‡ºç 
 */
int main(int argc, char *argv[])
{
    QApplication app(argc, argv);
    app.setApplicationName("CloudArt");
    app.setWindowIcon(QIcon(":/images/logo.png"));

    if (!DatabaseManager::instance().init()) {
        qDebug() << "âš ï¸ è­¦å‘Šï¼šæ•°æ®åº“åˆå§‹åŒ–å¤±è´¥ï¼Œå†å²è®°å½•å°†æ— æ³•ä¿å­˜ï¼";
    }

    if (!DatabaseManager::instance().init()) {
        return -1;
    }

    MainWindow window;
    window.show();

    return app.exec();
}


--- æ–‡ä»¶ç»“æŸ: src\main.cpp ---

--- æ–‡ä»¶å¼€å§‹: src\Core\WorkflowManager.cpp ---

/**
 * @file WorkflowManager.cpp
 * @brief å·¥ä½œæµç®¡ç†å™¨å®ç°æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®ç°äº†WorkflowManagerç±»ï¼Œè´Ÿè´£æ„å»ºå’Œç®¡ç†å„ç§å·¥ä½œæµçš„JSONæ•°æ®ã€‚
 * æ”¯æŒæ–‡ç”Ÿå›¾ã€å›¾ç”Ÿå›¾ã€é«˜æ¸…ä¿®å¤ã€è§†è§‰åæ¨ç­‰å¤šç§å·¥ä½œæµç±»å‹ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#include "WorkflowManager.h"
#include <QFile>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonValue>
#include <QDebug>
#include <QRandomGenerator>

/**
 * @brief æ„é€ å‡½æ•°
 * @param parent çˆ¶å¯¹è±¡æŒ‡é’ˆ
 */
WorkflowManager::WorkflowManager(QObject *parent) : QObject(parent)
{
}

/**
 * @brief æ„å»ºå·¥ä½œæµJSON
 * @param type å·¥ä½œæµç±»å‹
 * @param params ç”¨æˆ·è¾“å…¥çš„å‚æ•°
 * @return QJsonObject å‡†å¤‡å¥½å‘é€ç»™APIçš„JSONå¯¹è±¡
 */
QJsonObject WorkflowManager::buildWorkflow(WorkflowType type, const QMap<QString, QVariant>& params)
{
    qDebug() << "WorkflowManager: æ„å»ºå·¥ä½œæµç±»å‹ ->" << (int)type;

    switch (type) {
    case WorkflowType::TextToImage:
        return buildTextToImage(params);

    case WorkflowType::Upscale:
        return buildUpscale(params);

    case WorkflowType::ImageToImage:
        return buildImageToImage(params);

    case WorkflowType::VisionCaption:
        return buildVisionCaption(params);

    default:
        qDebug() << "æœªçŸ¥çš„å·¥ä½œæµç±»å‹:" << (int)type;
        return QJsonObject();
    }
}

/**
 * @brief æ„å»ºæ–‡ç”Ÿå›¾å·¥ä½œæµ
 * @param params ç”¨æˆ·è¾“å…¥å‚æ•°
 * @return QJsonObject æ–‡ç”Ÿå›¾å·¥ä½œæµJSONå¯¹è±¡
 */
QJsonObject WorkflowManager::buildTextToImage(const QMap<QString, QVariant>& params)
{
    QJsonObject workflow = loadTemplate(":/workflows/t2i");
    if (workflow.isEmpty()) return QJsonObject();

    if (params.contains("prompt")) {
        setNodeInput(workflow, "5", "text", params["prompt"].toString());
    }

    if (params.contains("seed")) {
        setNodeInput(workflow, "4", "seed", params["seed"].toLongLong());
    }

    if (params.contains("width") && params.contains("height")) {
        setNodeInput(workflow, "7", "width", params["width"].toInt());
        setNodeInput(workflow, "7", "height", params["height"].toInt());
    }

    return workflow;
}

/**
 * @brief æ„å»ºé«˜æ¸…ä¿®å¤å·¥ä½œæµ
 * @param params ç”¨æˆ·è¾“å…¥å‚æ•°
 * @return QJsonObject é«˜æ¸…ä¿®å¤å·¥ä½œæµJSONå¯¹è±¡
 */
QJsonObject WorkflowManager::buildUpscale(const QMap<QString, QVariant>& params)
{
    QJsonObject workflow = loadTemplate(":/workflows/upscale");
    if (workflow.isEmpty()) return QJsonObject();

    if (params.contains("image_path")) {
        setNodeInput(workflow, "6", "image", params["image_path"].toString());
    }

    if (params.contains("seed")) {
        setNodeInput(workflow, "2", "seed", params["seed"].toLongLong());
    }

    return workflow;
}

/**
 * @brief è®¾ç½®æŒ‡å®šèŠ‚ç‚¹çš„è¾“å…¥å‚æ•°å€¼
 * @param workflow å·¥ä½œæµJSONå¯¹è±¡ï¼ˆå¼•ç”¨ä¼ é€’ï¼Œç›´æ¥ä¿®æ”¹ï¼‰
 * @param nodeId èŠ‚ç‚¹ID
 * @param inputKey å‚æ•°å
 * @param value å‚æ•°å€¼
 */
void WorkflowManager::setNodeInput(QJsonObject& workflow, const QString& nodeId, const QString& inputKey, const QVariant& value)
{
    if (!workflow.contains(nodeId)) {
        qDebug() << "Warning: JSONä¸­æ‰¾ä¸åˆ°èŠ‚ç‚¹ ID:" << nodeId;
        return;
    }

    QJsonObject node = workflow[nodeId].toObject();

    if (!node.contains("inputs")) {
        qDebug() << "Warning: èŠ‚ç‚¹" << nodeId << "æ²¡æœ‰ inputs å­—æ®µ";
        return;
    }

    QJsonObject inputs = node["inputs"].toObject();

    if (value.typeId() == QMetaType::LongLong || value.typeId() == QMetaType::Int) {
        inputs[inputKey] = value.toLongLong();
    }
    else {
        inputs[inputKey] = value.toString();
    }

    node["inputs"] = inputs;
    workflow[nodeId] = node;
}

/**
 * @brief åŠ è½½èµ„æºæ–‡ä»¶ä¸­çš„JSONæ¨¡æ¿
 * @param resourcePath èµ„æºæ–‡ä»¶è·¯å¾„
 * @return QJsonObject JSONæ¨¡æ¿å¯¹è±¡
 */
QJsonObject WorkflowManager::loadTemplate(const QString& resourcePath)
{
    QFile file(resourcePath);
    if (!file.open(QIODevice::ReadOnly)) {
        qDebug() << "æ— æ³•åŠ è½½æ¨¡æ¿æ–‡ä»¶:" << resourcePath;
        return QJsonObject();
    }

    QJsonDocument doc = QJsonDocument::fromJson(file.readAll());
    if (doc.isNull()) {
        qDebug() << "JSON æ ¼å¼é”™è¯¯:" << resourcePath;
        return QJsonObject();
    }

    return doc.object();
}

/**
 * @brief æ„å»ºè§†è§‰åæ¨å·¥ä½œæµ
 * @param params ç”¨æˆ·è¾“å…¥å‚æ•°
 * @return QJsonObject è§†è§‰åæ¨å·¥ä½œæµJSONå¯¹è±¡
 */
QJsonObject WorkflowManager::buildVisionCaption(const QMap<QString, QVariant>& params)
{
    QJsonObject workflow = loadTemplate(":/workflows/vision");

    if (workflow.isEmpty()) {
        qDebug() << "æ— æ³•åŠ è½½åæ¨æ¨¡æ¿ :/workflows/vision";
        return QJsonObject();
    }

    if (params.contains("image_path")) {
        setNodeInput(workflow, "3", "image", params["image_path"].toString());
    }

    qint64 seed = QRandomGenerator::global()->generate();
    if (seed < 0) seed = -seed;

    if (params.contains("seed")) {
        seed = params["seed"].toLongLong();
    }

    setNodeInput(workflow, "1", "seed", seed);

    return workflow;
}

/**
 * @brief æ„å»ºå›¾ç”Ÿå›¾å·¥ä½œæµ
 * @param params ç”¨æˆ·è¾“å…¥å‚æ•°
 * @return QJsonObject å›¾ç”Ÿå›¾å·¥ä½œæµJSONå¯¹è±¡
 */
QJsonObject WorkflowManager::buildImageToImage(const QMap<QString, QVariant>& params)
{
    QJsonObject workflow = loadTemplate(":/workflows/render");
    if (workflow.isEmpty()) return QJsonObject();

    if (params.contains("image_path")) {
        setNodeInput(workflow, "30", "image", params["image_path"].toString());
    }

    if (params.contains("prompt")) {
        setNodeInput(workflow, "6", "text", params["prompt"].toString());
    }

    if (params.contains("seed")) {
        setNodeInput(workflow, "3", "seed", params["seed"].toLongLong());
    }

    return workflow;
}


--- æ–‡ä»¶ç»“æŸ: src\Core\WorkflowManager.cpp ---

--- æ–‡ä»¶å¼€å§‹: src\Core\WorkflowManager.h ---

/**
 * @file WorkflowManager.h
 * @brief å·¥ä½œæµç®¡ç†å™¨å¤´æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†WorkflowManagerç±»ï¼Œè´Ÿè´£æ„å»ºå’Œç®¡ç†å„ç§å·¥ä½œæµçš„JSONæ•°æ®ã€‚
 * æ”¯æŒæ–‡ç”Ÿå›¾ã€å›¾ç”Ÿå›¾ã€é«˜æ¸…ä¿®å¤ã€è§†è§‰åæ¨ç­‰å¤šç§å·¥ä½œæµç±»å‹ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#pragma once

#include <QObject>
#include <QJsonObject>
#include <QMap>
#include <QVariant>
#include "../Model/WorkflowTypes.h"

/**
 * @brief å·¥ä½œæµç®¡ç†å™¨ç±»
 * 
 * è´Ÿè´£æ„å»ºä¸åŒç±»å‹çš„å·¥ä½œæµJSONå¯¹è±¡ï¼Œç”¨äºä¸ComfyUI APIäº¤äº’ã€‚
 * æ”¯æŒæ–‡ç”Ÿå›¾ã€å›¾ç”Ÿå›¾ã€é«˜æ¸…ä¿®å¤å’Œè§†è§‰åæ¨ç­‰å¤šç§å·¥ä½œæµç±»å‹ã€‚
 */
class WorkflowManager : public QObject
{
    Q_OBJECT

public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param parent çˆ¶å¯¹è±¡æŒ‡é’ˆ
     */
    explicit WorkflowManager(QObject *parent = nullptr);

    /**
     * @brief æ„å»ºå·¥ä½œæµJSON
     * @param type å·¥ä½œæµç±»å‹ (ä¾‹å¦‚ TextToImage)
     * @param params ç”¨æˆ·è¾“å…¥çš„å‚æ•° (ä¾‹å¦‚ prompt, seed)
     * @return QJsonObject å‡†å¤‡å¥½å‘é€ç»™APIçš„JSONå¯¹è±¡
     */
    QJsonObject buildWorkflow(WorkflowType type, const QMap<QString, QVariant>& params);

private:
    /**
     * @brief åŠ è½½èµ„æºæ–‡ä»¶ä¸­çš„JSONæ¨¡æ¿
     * @param resourcePath èµ„æºæ–‡ä»¶è·¯å¾„
     * @return QJsonObject JSONæ¨¡æ¿å¯¹è±¡
     */
    QJsonObject loadTemplate(const QString& resourcePath);

    /**
     * @brief è®¾ç½®æŒ‡å®šèŠ‚ç‚¹çš„è¾“å…¥å‚æ•°å€¼
     * @param workflow å·¥ä½œæµJSONå¯¹è±¡ï¼ˆå¼•ç”¨ä¼ é€’ï¼Œç›´æ¥ä¿®æ”¹ï¼‰
     * @param nodeId èŠ‚ç‚¹ID (å¦‚ "3")
     * @param inputKey å‚æ•°å (å¦‚ "seed", "text")
     * @param value å‚æ•°å€¼
     */
    void setNodeInput(QJsonObject& workflow, const QString& nodeId, const QString& inputKey, const QVariant& value);

    /**
     * @brief æ„å»ºæ–‡ç”Ÿå›¾å·¥ä½œæµ
     * @param params ç”¨æˆ·è¾“å…¥å‚æ•°
     * @return QJsonObject æ–‡ç”Ÿå›¾å·¥ä½œæµJSONå¯¹è±¡
     */
    QJsonObject buildTextToImage(const QMap<QString, QVariant>& params);

    /**
     * @brief æ„å»ºé«˜æ¸…ä¿®å¤å·¥ä½œæµ
     * @param params ç”¨æˆ·è¾“å…¥å‚æ•°
     * @return QJsonObject é«˜æ¸…ä¿®å¤å·¥ä½œæµJSONå¯¹è±¡
     */
    QJsonObject buildUpscale(const QMap<QString, QVariant>& params);

    /**
     * @brief æ„å»ºå›¾ç”Ÿå›¾å·¥ä½œæµ
     * @param params ç”¨æˆ·è¾“å…¥å‚æ•°
     * @return QJsonObject å›¾ç”Ÿå›¾å·¥ä½œæµJSONå¯¹è±¡
     */
    QJsonObject buildImageToImage(const QMap<QString, QVariant>& params);

    /**
     * @brief æ„å»ºè§†è§‰åæ¨å·¥ä½œæµ
     * @param params ç”¨æˆ·è¾“å…¥å‚æ•°
     * @return QJsonObject è§†è§‰åæ¨å·¥ä½œæµJSONå¯¹è±¡
     */
    QJsonObject buildVisionCaption(const QMap<QString, QVariant>& params);
};


--- æ–‡ä»¶ç»“æŸ: src\Core\WorkflowManager.h ---

--- æ–‡ä»¶å¼€å§‹: src\Database\DatabaseManager.cpp ---

/**
 * @file DatabaseManager.cpp
 * @brief æ•°æ®åº“ç®¡ç†å™¨å®ç°æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®ç°äº†DatabaseManagerç±»ï¼Œè´Ÿè´£åº”ç”¨ç¨‹åºçš„æ•°æ®åº“æ“ä½œã€‚
 * ä½¿ç”¨å•ä¾‹æ¨¡å¼ç®¡ç†æ•°æ®åº“è¿æ¥ï¼Œæä¾›ä¼šè¯å’Œæ¶ˆæ¯çš„å¢åˆ æ”¹æŸ¥æ¥å£ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#include "DatabaseManager.h"
#include <QSqlQuery>
#include <QSqlError>
#include <QStandardPaths>
#include <QDir>
#include <QDebug>
#include <QVariant>

/**
 * @brief è·å–å•ä¾‹å®ä¾‹
 * @return DatabaseManager& æ•°æ®åº“ç®¡ç†å™¨å•ä¾‹å¼•ç”¨
 */
DatabaseManager& DatabaseManager::instance()
{
    static DatabaseManager instance;
    return instance;
}

/**
 * @brief æ„é€ å‡½æ•°
 * @param parent çˆ¶å¯¹è±¡æŒ‡é’ˆ
 */
DatabaseManager::DatabaseManager(QObject *parent) : QObject(parent) {}

/**
 * @brief ææ„å‡½æ•°
 */
DatabaseManager::~DatabaseManager()
{
    if (m_db.isOpen()) m_db.close();
}

/**
 * @brief åˆå§‹åŒ–æ•°æ®åº“
 * @return bool åˆå§‹åŒ–æ˜¯å¦æˆåŠŸ
 * 
 * æ‰“å¼€æ•°æ®åº“è¿æ¥å¹¶åˆ›å»ºå¿…è¦çš„æ•°æ®è¡¨
 */
bool DatabaseManager::init()
{
    QString dataDir = QStandardPaths::writableLocation(QStandardPaths::AppDataLocation);

    QDir dir(dataDir);
    if (!dir.exists()) dir.mkpath(".");

    QString dbPath = dataDir + "/cloudart.db";
    qDebug() << "æ•°æ®åº“è·¯å¾„:" << dbPath;

    m_db = QSqlDatabase::addDatabase("QSQLITE");
    m_db.setDatabaseName(dbPath);

    if (!m_db.open()) {
        qDebug() << "æ‰“å¼€æ•°æ®åº“å¤±è´¥:" << m_db.lastError().text();
        return false;
    }

    createTables();
    return true;
}

/**
 * @brief åˆ›å»ºæ•°æ®è¡¨
 * 
 * åˆ›å»ºä¼šè¯è¡¨å’Œæ¶ˆæ¯è¡¨ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
 */
void DatabaseManager::createTables()
{
    QSqlQuery query;

    bool success = query.exec(
        "CREATE TABLE IF NOT EXISTS tb_sessions ("
        "id INTEGER PRIMARY KEY AUTOINCREMENT, "
        "title TEXT NOT NULL, "
        "created_at INTEGER"
        ")"
        );
    if (!success) qDebug() << "tb_sessions å»ºè¡¨å¤±è´¥:" << query.lastError();

    success = query.exec(
        "CREATE TABLE IF NOT EXISTS tb_messages ("
        "id INTEGER PRIMARY KEY AUTOINCREMENT, "
        "session_id INTEGER, "
        "role TEXT, "
        "content TEXT, "
        "image_path TEXT, "
        "timestamp INTEGER"
        ")"
        );
    if (!success) qDebug() << "tb_messages å»ºè¡¨å¤±è´¥:" << query.lastError();
}

/**
 * @brief åˆ›å»ºæ–°ä¼šè¯
 * @param name ä¼šè¯åç§°
 * @return int æ–°åˆ›å»ºçš„ä¼šè¯IDï¼Œå¤±è´¥è¿”å›-1
 */
int DatabaseManager::createSession(const QString& name)
{
    QSqlQuery query;
    query.prepare("INSERT INTO tb_sessions (title, created_at) VALUES (:name, :time)");

    query.bindValue(":name", name);
    query.bindValue(":time", QDateTime::currentMSecsSinceEpoch());

    if (query.exec()) {
        return query.lastInsertId().toInt();
    }

    qDebug() << "åˆ›å»ºä¼šè¯å¤±è´¥:" << query.lastError();
    return -1;
}

/**
 * @brief è·å–æ‰€æœ‰ä¼šè¯
 * @return QVector<SessionData> æ‰€æœ‰ä¼šè¯çš„æ•°æ®åˆ—è¡¨
 * 
 * ç”¨äºåˆå§‹åŒ–å·¦ä¾§ä¼šè¯åˆ—è¡¨
 */
QVector<SessionData> DatabaseManager::getAllSessions()
{
    QVector<SessionData> list;
    QSqlQuery query("SELECT * FROM tb_sessions ORDER BY created_at DESC");

    while (query.next()) {
        SessionData session;
        session.id = query.value("id").toInt();
        session.name = query.value("title").toString();
        session.createdAt = query.value("created_at").toLongLong();
        list.append(session);
    }
    return list;
}

/**
 * @brief é‡å‘½åä¼šè¯
 * @param id ä¼šè¯ID
 * @param newName æ–°ä¼šè¯åç§°
 * @return bool é‡å‘½åæ˜¯å¦æˆåŠŸ
 */
bool DatabaseManager::renameSession(int id, const QString& newName)
{
    QSqlQuery query;
    query.prepare("UPDATE tb_sessions SET title = :name WHERE id = :id");
    query.bindValue(":name", newName);
    query.bindValue(":id", id);
    return query.exec();
}

/**
 * @brief åˆ é™¤ä¼šè¯
 * @param id ä¼šè¯ID
 * @return bool åˆ é™¤æ˜¯å¦æˆåŠŸ
 * 
 * åˆ é™¤ä¼šè¯æ—¶ä¼šè¿å¸¦åˆ é™¤è¯¥ä¼šè¯ä¸‹çš„æ‰€æœ‰æ¶ˆæ¯
 */
bool DatabaseManager::deleteSession(int id)
{
    QSqlQuery queryMsg;
    queryMsg.prepare("DELETE FROM tb_messages WHERE session_id = :sid");
    queryMsg.bindValue(":sid", id);
    queryMsg.exec();

    QSqlQuery query;
    query.prepare("DELETE FROM tb_sessions WHERE id = :id");
    query.bindValue(":id", id);
    return query.exec();
}

/**
 * @brief æ·»åŠ æ–°æ¶ˆæ¯
 * @param msg æ¶ˆæ¯æ•°æ®
 * @return int æ–°æ¶ˆæ¯çš„IDï¼Œå¤±è´¥è¿”å›-1
 */
int DatabaseManager::addMessage(const MessageData& msg)
{
    QSqlQuery query;
    query.prepare("INSERT INTO tb_messages (session_id, role, content, image_path, timestamp) "
                  "VALUES (:sid, :role, :content, :img, :time)");

    query.bindValue(":sid", msg.sessionId);
    query.bindValue(":role", msg.role == MessageRole::User ? "user" : "ai");
    query.bindValue(":content", msg.text);
    query.bindValue(":img", msg.imagePath);
    query.bindValue(":time", QDateTime::currentMSecsSinceEpoch());

    if (query.exec()) {
        return query.lastInsertId().toInt();
    }

    qDebug() << "æ’å…¥æ¶ˆæ¯å¤±è´¥:" << query.lastError();
    return -1;
}

/**
 * @brief è·å–æŒ‡å®šä¼šè¯çš„æ‰€æœ‰æ¶ˆæ¯
 * @param sessionId ä¼šè¯ID
 * @return QVector<MessageData> æ¶ˆæ¯æ•°æ®åˆ—è¡¨
 * 
 * ç”¨äºç‚¹å‡»ä¼šè¯ååŠ è½½å†å²æ¶ˆæ¯
 */
QVector<MessageData> DatabaseManager::getMessages(int sessionId)
{
    QVector<MessageData> list;
    QSqlQuery query;
    query.prepare("SELECT * FROM tb_messages WHERE session_id = :sid ORDER BY timestamp ASC");
    query.bindValue(":sid", sessionId);

    if (!query.exec()) {
        qDebug() << "æŸ¥è¯¢æ¶ˆæ¯å¤±è´¥:" << query.lastError();
        return list;
    }

    while (query.next()) {
        int id = query.value("id").toInt();
        int sid = query.value("session_id").toInt();
        QString roleStr = query.value("role").toString();
        QString content = query.value("content").toString();
        QString imgPath = query.value("image_path").toString();
        qint64 time = query.value("timestamp").toLongLong();

        MessageRole role = (roleStr == "user") ? MessageRole::User : MessageRole::AI;

        MessageData msg(sid, role, content, imgPath);
        msg.id = id;
        msg.timestamp = time;

        list.append(msg);
    }
    return list;
}

/**
 * @brief è·å–æ‰€æœ‰ç”Ÿæˆçš„å›¾ç‰‡è·¯å¾„
 * @return QVector<QString> å›¾ç‰‡è·¯å¾„åˆ—è¡¨ï¼ˆæŒ‰æ—¶é—´å€’åºï¼‰
 */
QVector<QString> DatabaseManager::getAllAiImages()
{
    QVector<QString> list;
    QSqlQuery query;
    query.prepare("SELECT image_path FROM tb_messages WHERE role = 'ai' AND image_path != '' ORDER BY timestamp DESC");

    if (query.exec()) {
        while (query.next()) {
            list.append(query.value("image_path").toString());
        }
    } else {
        qDebug() << "æŸ¥è¯¢å†å²å›¾ç‰‡å¤±è´¥:" << query.lastError();
    }
    return list;
}


--- æ–‡ä»¶ç»“æŸ: src\Database\DatabaseManager.cpp ---

--- æ–‡ä»¶å¼€å§‹: src\Database\DatabaseManager.h ---

/**
 * @file DatabaseManager.h
 * @brief æ•°æ®åº“ç®¡ç†å™¨å¤´æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†DatabaseManagerç±»ï¼Œè´Ÿè´£åº”ç”¨ç¨‹åºçš„æ•°æ®åº“æ“ä½œã€‚
 * ä½¿ç”¨å•ä¾‹æ¨¡å¼ç®¡ç†æ•°æ®åº“è¿æ¥ï¼Œæä¾›ä¼šè¯å’Œæ¶ˆæ¯çš„å¢åˆ æ”¹æŸ¥æ¥å£ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#pragma once

#include <QObject>
#include <QSqlDatabase>
#include <QVector>
#include "../Model/DataModels.h"

/**
 * @brief æ•°æ®åº“ç®¡ç†å™¨ç±»
 * 
 * é‡‡ç”¨å•ä¾‹æ¨¡å¼ç®¡ç†æ•°æ®åº“è¿æ¥ï¼Œæä¾›ä¼šè¯å’Œæ¶ˆæ¯çš„æŒä¹…åŒ–å­˜å‚¨åŠŸèƒ½ã€‚
 * æ”¯æŒä¼šè¯çš„åˆ›å»ºã€æŸ¥è¯¢ã€é‡å‘½åã€åˆ é™¤ä»¥åŠæ¶ˆæ¯çš„æ·»åŠ å’ŒæŸ¥è¯¢æ“ä½œã€‚
 */
class DatabaseManager : public QObject
{
    Q_OBJECT

public:
    /**
     * @brief è·å–å•ä¾‹å®ä¾‹
     * @return DatabaseManager& æ•°æ®åº“ç®¡ç†å™¨å•ä¾‹å¼•ç”¨
     */
    static DatabaseManager& instance();

    /**
     * @brief åˆå§‹åŒ–æ•°æ®åº“
     * @return bool åˆå§‹åŒ–æ˜¯å¦æˆåŠŸ
     * 
     * æ‰“å¼€æ•°æ®åº“è¿æ¥å¹¶åˆ›å»ºå¿…è¦çš„æ•°æ®è¡¨
     */
    bool init();

    /**
     * @brief åˆ›å»ºæ–°ä¼šè¯
     * @param name ä¼šè¯åç§°
     * @return int æ–°åˆ›å»ºçš„ä¼šè¯IDï¼Œå¤±è´¥è¿”å›-1
     */
    int createSession(const QString& name);

    /**
     * @brief è·å–æ‰€æœ‰ä¼šè¯
     * @return QVector<SessionData> æ‰€æœ‰ä¼šè¯çš„æ•°æ®åˆ—è¡¨
     * 
     * ç”¨äºåˆå§‹åŒ–å·¦ä¾§ä¼šè¯åˆ—è¡¨
     */
    QVector<SessionData> getAllSessions();

    /**
     * @brief é‡å‘½åä¼šè¯
     * @param id ä¼šè¯ID
     * @param newName æ–°ä¼šè¯åç§°
     * @return bool é‡å‘½åæ˜¯å¦æˆåŠŸ
     */
    bool renameSession(int id, const QString& newName);

    /**
     * @brief åˆ é™¤ä¼šè¯
     * @param id ä¼šè¯ID
     * @return bool åˆ é™¤æ˜¯å¦æˆåŠŸ
     * 
     * åˆ é™¤ä¼šè¯æ—¶ä¼šè¿å¸¦åˆ é™¤è¯¥ä¼šè¯ä¸‹çš„æ‰€æœ‰æ¶ˆæ¯
     */
    bool deleteSession(int id);

    /**
     * @brief æ·»åŠ æ–°æ¶ˆæ¯
     * @param msg æ¶ˆæ¯æ•°æ®
     * @return int æ–°æ¶ˆæ¯çš„IDï¼Œå¤±è´¥è¿”å›-1
     */
    int addMessage(const MessageData& msg);

    /**
     * @brief è·å–æŒ‡å®šä¼šè¯çš„æ‰€æœ‰æ¶ˆæ¯
     * @param sessionId ä¼šè¯ID
     * @return QVector<MessageData> æ¶ˆæ¯æ•°æ®åˆ—è¡¨
     * 
     * ç”¨äºç‚¹å‡»ä¼šè¯ååŠ è½½å†å²æ¶ˆæ¯
     */
    QVector<MessageData> getMessages(int sessionId);

    /**
     * @brief è·å–æ‰€æœ‰ç”Ÿæˆçš„å›¾ç‰‡è·¯å¾„
     * @return QVector<QString> å›¾ç‰‡è·¯å¾„åˆ—è¡¨ï¼ˆæŒ‰æ—¶é—´å€’åºï¼‰
     */
    QVector<QString> getAllAiImages();

private:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param parent çˆ¶å¯¹è±¡æŒ‡é’ˆ
     */
    explicit DatabaseManager(QObject *parent = nullptr);

    /**
     * @brief ææ„å‡½æ•°
     */
    ~DatabaseManager();

    /**
     * @brief ç¦ç”¨æ‹·è´æ„é€ å‡½æ•°
     */
    DatabaseManager(const DatabaseManager&) = delete;

    /**
     * @brief ç¦ç”¨æ‹·è´èµ‹å€¼è¿ç®—ç¬¦
     */
    DatabaseManager& operator=(const DatabaseManager&) = delete;

    /**
     * @brief åˆ›å»ºæ•°æ®è¡¨
     * 
     * åˆ›å»ºä¼šè¯è¡¨å’Œæ¶ˆæ¯è¡¨ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
     */
    void createTables();

private:
    QSqlDatabase m_db; ///< æ•°æ®åº“è¿æ¥å¯¹è±¡
};


--- æ–‡ä»¶ç»“æŸ: src\Database\DatabaseManager.h ---

--- æ–‡ä»¶å¼€å§‹: src\Model\DataModels.h ---

/**
 * @file DataModels.h
 * @brief æ ¸å¿ƒæ•°æ®æ¨¡å‹å®šä¹‰
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†åº”ç”¨ç¨‹åºçš„æ ¸å¿ƒæ•°æ®æ¨¡å‹ï¼ŒåŒ…æ‹¬æ¶ˆæ¯è§’è‰²æšä¸¾ã€ä¼šè¯æ•°æ®ç»“æ„å’Œæ¶ˆæ¯æ•°æ®ç»“æ„ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#pragma once
#include <QString>
#include <QDateTime>

/**
 * @brief æ¶ˆæ¯å‘é€è€…è§’è‰²æšä¸¾
 * 
 * å®šä¹‰æ¶ˆæ¯å‘é€è€…çš„è§’è‰²ç±»å‹ï¼Œå¯¹åº”æ•°æ®åº“é‡Œçš„roleå­—æ®µã€‚
 */
enum class MessageRole {
    User, ///< ç”¨æˆ·è§’è‰²
    AI    ///< AIè§’è‰²
};

/**
 * @brief ä¼šè¯æ•°æ®ç»“æ„
 * 
 * åŒ…å«ä¼šè¯çš„åŸºæœ¬ä¿¡æ¯ï¼Œç”¨äºæ•°æ®åº“å­˜å‚¨å’Œç•Œé¢æ˜¾ç¤ºã€‚
 */
struct SessionData {
    int id = -1;                ///< æ•°æ®åº“ID
    QString name;               ///< ä¼šè¯æ ‡é¢˜
    qint64 createdAt = 0;       ///< åˆ›å»ºæ—¶é—´æˆ³

    /**
     * @brief é»˜è®¤æ„é€ å‡½æ•°
     */
    SessionData() {}

    /**
     * @brief ä¾¿æ·æ„é€ å‡½æ•°
     * @param _id ä¼šè¯ID
     * @param _name ä¼šè¯åç§°
     */
    SessionData(int _id, const QString& _name)
        : id(_id), name(_name), createdAt(QDateTime::currentMSecsSinceEpoch()) {}
};

/**
 * @brief æ¶ˆæ¯æ•°æ®ç»“æ„
 * 
 * åŒ…å«æ¶ˆæ¯çš„å®Œæ•´ä¿¡æ¯ï¼Œæ”¯æŒæ–‡æœ¬å’Œå›¾ç‰‡ä¸¤ç§ç±»å‹ã€‚
 */
struct MessageData {
    int id = -1;                ///< æ¶ˆæ¯ID
    int sessionId = -1;         ///< å¤–é”®ï¼Œå…³è”çš„ä¼šè¯ID
    MessageRole role = MessageRole::User; ///< æ¶ˆæ¯å‘é€è€…è§’è‰²

    QString text;               ///< æ–‡å­—å†…å®¹
    QString imagePath;          ///< æœ¬åœ°å›¾ç‰‡è·¯å¾„ï¼ˆå¦‚æœæ˜¯æ–‡å­—åˆ™ä¸ºç©ºï¼‰

    qint64 timestamp = 0;       ///< æ¶ˆæ¯æ—¶é—´æˆ³

    /**
     * @brief åˆ¤æ–­æ˜¯å¦æ˜¯å›¾ç‰‡æ¶ˆæ¯
     * @return bool æ˜¯å¦ä¸ºå›¾ç‰‡æ¶ˆæ¯
     */
    bool isImage() const { return !imagePath.isEmpty(); }

    /**
     * @brief é»˜è®¤æ„é€ å‡½æ•°
     */
    MessageData() {}

    /**
     * @brief ä¾¿æ·æ„é€ å‡½æ•°
     * @param sid ä¼šè¯ID
     * @param r æ¶ˆæ¯è§’è‰²
     * @param t æ–‡æœ¬å†…å®¹
     * @param img å›¾ç‰‡è·¯å¾„ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä¸ºç©ºï¼‰
     */
    MessageData(int sid, MessageRole r, const QString& t, const QString& img = "")
        : sessionId(sid), role(r), text(t), imagePath(img)
    {
        timestamp = QDateTime::currentMSecsSinceEpoch();
    }
};


--- æ–‡ä»¶ç»“æŸ: src\Model\DataModels.h ---

--- æ–‡ä»¶å¼€å§‹: src\Model\WorkflowTypes.h ---

/**
 * @file WorkflowTypes.h
 * @brief å·¥ä½œæµç±»å‹å®šä¹‰å¤´æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†å·¥ä½œæµç›¸å…³çš„æšä¸¾ç±»å‹å’Œæ•°æ®ç»“æ„ã€‚
 * åŒ…å«å·¥ä½œæµç±»å‹æšä¸¾å’Œå·¥ä½œæµä¿¡æ¯ç»“æ„ä½“å®šä¹‰ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#pragma once

#include <QString>

/**
 * @brief å·¥ä½œæµç±»å‹æšä¸¾
 * 
 * å®šä¹‰äº†åº”ç”¨ç¨‹åºæ”¯æŒçš„æ‰€æœ‰å·¥ä½œæµç±»å‹ã€‚
 */
enum class WorkflowType {
    TextToImage = 1,      ///< æ–‡ç”Ÿå›¾
    ImageToImage = 2,     ///< å›¾ç”Ÿå›¾
    Inpaint = 3,          ///< å±€éƒ¨é‡ç»˜
    Upscale = 4,          ///< å›¾åƒæ”¾å¤§
    StyleTransfer = 5,    ///< é£æ ¼è½¬æ¢
    PortraitEnhance = 6,  ///< äººåƒç¾åŒ–
    BackgroundRemove = 7, ///< èƒŒæ™¯ç§»é™¤
    ColorCorrection = 8,   ///< è‰²å½©æ ¡æ­£
    VisionCaption = 9      ///< è§†è§‰åæ¨
};

/**
 * @brief å·¥ä½œæµä¿¡æ¯ç»“æ„ä½“
 * 
 * åŒ…å«å•ä¸ªå·¥ä½œæµçš„å®Œæ•´ä¿¡æ¯ï¼Œç”¨äºç•Œé¢æ˜¾ç¤ºå’ŒåŠŸèƒ½å¤„ç†ã€‚
 */
struct WorkflowInfo {
    int id; ///< å·¥ä½œæµå”¯ä¸€æ ‡è¯†ç¬¦
    QString name; ///< å·¥ä½œæµåç§°
    QString imagePath; ///< å·¥ä½œæµå›¾æ ‡è·¯å¾„
    QString gifPath; ///< å·¥ä½œæµåŠ¨ç”»è·¯å¾„ï¼ˆå¯é€‰ï¼‰
    QString description; ///< å·¥ä½œæµæè¿°ï¼ˆå¯é€‰ï¼‰
    WorkflowType type; ///< å·¥ä½œæµç±»å‹
    
    /**
     * @brief æ„é€ å‡½æ•°
     * @param id å·¥ä½œæµID
     * @param name å·¥ä½œæµåç§°
     * @param imagePath å›¾æ ‡è·¯å¾„
     * @param gifPath åŠ¨ç”»è·¯å¾„ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä¸ºç©ºï¼‰
     * @param description æè¿°ä¿¡æ¯ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä¸ºç©ºï¼‰
     * @param type å·¥ä½œæµç±»å‹ï¼ˆå¯é€‰ï¼Œé»˜è®¤ä¸ºæ–‡ç”Ÿå›¾ï¼‰
     */
    WorkflowInfo(int id, const QString& name, const QString& imagePath, 
                 const QString& gifPath = "", const QString& description = "", WorkflowType type = WorkflowType::TextToImage)
        : id(id), name(name), imagePath(imagePath), gifPath(gifPath), description(description), type(type) {}
};


--- æ–‡ä»¶ç»“æŸ: src\Model\WorkflowTypes.h ---

--- æ–‡ä»¶å¼€å§‹: src\Network\ComfyApiService.cpp ---

/**
 * @file ComfyApiService.cpp
 * @brief ComfyUI APIæœåŠ¡å®ç°æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®ç°äº†ComfyApiServiceç±»ï¼Œç”¨äºä¸ComfyUIæœåŠ¡å™¨è¿›è¡Œé€šä¿¡ã€‚
 * åŒ…å«HTTPè¯·æ±‚å’ŒWebSocketè¿æ¥åŠŸèƒ½ï¼Œæ”¯æŒå›¾ç‰‡ç”Ÿæˆè¿›åº¦ç›‘æ§å’Œç»“æœæ¥æ”¶ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#include "ComfyApiService.h"
#include <QNetworkRequest>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QUrl>
#include <QUrlQuery>
#include <QDebug>
#include <QWebSocket>
#include <QHttpMultiPart>
#include <QHttpPart>
#include <QFile>
#include <QFileInfo>
#include <QSslConfiguration>
#include <QSslSocket>

/**
 * @brief æ„é€ å‡½æ•°
 * @param parent çˆ¶å¯¹è±¡æŒ‡é’ˆ
 */
ComfyApiService::ComfyApiService(QObject *parent)
    : QObject(parent)
{
    m_networkManager = new QNetworkAccessManager(this);
    m_webSocket = new QWebSocket(QString(), QWebSocketProtocol::VersionLatest, this);

    m_clientId = QUuid::createUuid().toString(QUuid::WithoutBraces);

    connect(m_webSocket, &QWebSocket::connected, this, [=](){
        qDebug() << "WebSocket è¿æ¥æˆåŠŸ!";
        emit serverConnected();
    });

    connect(m_webSocket, &QWebSocket::disconnected, this, [=](){
        qDebug() << "WebSocket è¿æ¥æ–­å¼€";
        emit serverDisconnected();
    });

    connect(m_webSocket, &QWebSocket::errorOccurred, this, [=](QAbstractSocket::SocketError error){
        Q_UNUSED(error);
        QString errStr = m_webSocket->errorString();
        qDebug() << "WebSocket é”™è¯¯:" << errStr;
        emit errorOccurred(errStr);
    });

    connect(m_webSocket, &QWebSocket::textMessageReceived,
            this, &ComfyApiService::onTextMessageReceived);
}

/**
 * @brief ææ„å‡½æ•°
 */
ComfyApiService::~ComfyApiService()
{
    if (m_webSocket) {
        m_webSocket->close();
    }
}

/**
 * @brief è¿æ¥åˆ°ComfyUIæœåŠ¡å™¨
 * @param fullUrl æœåŠ¡å™¨å®Œæ•´URL
 */
void ComfyApiService::connectToHost(const QString& fullUrl)
{
    QString urlStr = fullUrl.trimmed();

    if (!urlStr.startsWith("http://") && !urlStr.startsWith("https://")) {
        urlStr = "http://" + urlStr;
    }

    if (urlStr.endsWith("/")) {
        urlStr.chop(1);
    }

    m_apiBaseUrl = urlStr;

    QString wsUrl = m_apiBaseUrl;
    if (wsUrl.startsWith("https://")) {
        wsUrl.replace(0, 8, "wss://");
    } else {
        wsUrl.replace(0, 7, "ws://");
    }

    wsUrl += QString("/ws?clientId=%1").arg(m_clientId);

    qDebug() << "å‡†å¤‡è¿æ¥:" << wsUrl;

    if (m_webSocket->state() == QAbstractSocket::ConnectedState) {
        m_webSocket->close();
    }

    QSslConfiguration sslConfig = m_webSocket->sslConfiguration();
    sslConfig.setPeerVerifyMode(QSslSocket::VerifyNone);
    sslConfig.setProtocol(QSsl::AnyProtocol);
    m_webSocket->setSslConfiguration(sslConfig);

    connect(m_webSocket, &QWebSocket::sslErrors, this, [=](const QList<QSslError>& errors){
        qDebug() << "æ•è·åˆ° SSL é”™è¯¯ (å·²å¿½ç•¥):" << errors.first().errorString();
        m_webSocket->ignoreSslErrors();
    });

    m_webSocket->open(QUrl(wsUrl));
}

/**
 * @brief å‘é€æç¤ºè¯ç”Ÿæˆä»»åŠ¡
 * @param workflow å·¥ä½œæµJSONå¯¹è±¡
 */
void ComfyApiService::queuePrompt(const QJsonObject& workflow)
{
    QUrl url(m_apiBaseUrl + "/prompt");
    QNetworkRequest request(url);

    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    QJsonObject payload;
    payload["prompt"] = workflow;
    payload["client_id"] = m_clientId;
    QByteArray data = QJsonDocument(payload).toJson();

    qDebug() << "Posting prompt to:" << url.toString();
    QNetworkReply* reply = m_networkManager->post(request, data);

    connect(reply, &QNetworkReply::sslErrors, reply, [reply](const QList<QSslError> &errors){
        Q_UNUSED(errors);
        reply->ignoreSslErrors();
    });

    connect(reply, &QNetworkReply::finished, this, &ComfyApiService::onPostFinished);
}

/**
 * @brief å¤„ç†HTTP POSTè¯·æ±‚å®Œæˆ
 */
void ComfyApiService::onPostFinished()
{
    QNetworkReply* reply = qobject_cast<QNetworkReply*>(sender());
    if (!reply) return;

    if (reply->error() == QNetworkReply::NoError) {
        QByteArray response = reply->readAll();
        QJsonDocument doc = QJsonDocument::fromJson(response);
        QJsonObject obj = doc.object();

        QString promptId = obj["prompt_id"].toString();

        m_currentPromptId = promptId;

        qDebug() << "ä»»åŠ¡å‘é€æˆåŠŸ! ID:" << promptId;

        emit promptQueued(promptId);
    } else {
        QString err = "å‘é€ä»»åŠ¡å¤±è´¥: " + reply->errorString();
        qDebug() << err;
        emit errorOccurred(err);
    }

    reply->deleteLater();
}

/**
 * @brief å¤„ç†WebSocketæ–‡æœ¬æ¶ˆæ¯
 * @param message æ¥æ”¶åˆ°çš„æ¶ˆæ¯å†…å®¹
 */
void ComfyApiService::onTextMessageReceived(const QString &message)
{
    QJsonDocument doc = QJsonDocument::fromJson(message.toUtf8());
    QJsonObject root = doc.object();
    QString msgType = root["type"].toString();
    QJsonObject data = root["data"].toObject();

    if (msgType == "cloudart_stream") {
        QString token = data["token"].toString();
        bool finished = data["finished"].toBool();
        emit streamTokenReceived(token, finished);
        return;
    }

    if (msgType == "executed") {
        QString nodeId = QString::number(data["node"].toInt());
        if (nodeId == "0") nodeId = data["node"].toString();

        QString promptId = data["prompt_id"].toString();

        qDebug() << "æ£€æŸ¥ç»“æŸæ¡ä»¶ | æ”¶åˆ°ID:" << nodeId << " | ç›®æ ‡ID: 4 | ä»»åŠ¡åŒ¹é…:" << (promptId == m_currentPromptId);

        if (promptId == m_currentPromptId && (nodeId == "20" || nodeId == "1" || nodeId == "9")) {
            QJsonObject output = data["output"].toObject();
            QJsonArray images = output["images"].toArray();
            if (!images.isEmpty()) {
                QJsonObject imgInfo = images[0].toObject();
                getImage(imgInfo["filename"].toString(),
                         imgInfo["subfolder"].toString(),
                         imgInfo["type"].toString(), promptId);
            }
        }

        if (promptId == m_currentPromptId && nodeId == "4") {
            qDebug() << "è§¦å‘åæ¨å¼ºåˆ¶è§£é”";
            emit streamTokenReceived("", true);
        }
    }
}

/**
 * @brief è·å–å›¾ç‰‡æ•°æ®
 * @param filename å›¾ç‰‡æ–‡ä»¶å
 * @param subfolder å­æ–‡ä»¶å¤¹è·¯å¾„
 * @param type å›¾ç‰‡ç±»å‹
 * @param promptId æç¤ºè¯ID
 */
void ComfyApiService::getImage(const QString& filename, const QString& subfolder, const QString& type, const QString& promptId)
{
    QUrl url(m_apiBaseUrl + "/view");
    QUrlQuery query;
    query.addQueryItem("filename", filename);
    query.addQueryItem("subfolder", subfolder);
    query.addQueryItem("type", type);
    url.setQuery(query);

    QNetworkRequest request(url);
    QNetworkReply* reply = m_networkManager->get(request);

    connect(reply, &QNetworkReply::sslErrors, reply, [reply](const QList<QSslError> &errors){
        Q_UNUSED(errors);
        reply->ignoreSslErrors();
    });

    reply->setProperty("promptId", promptId);
    reply->setProperty("filename", filename);

    connect(reply, &QNetworkReply::finished, this, &ComfyApiService::onImageDownloadFinished);
}

/**
 * @brief å¤„ç†å›¾ç‰‡ä¸‹è½½å®Œæˆ
 */
void ComfyApiService::onImageDownloadFinished()
{
    QNetworkReply* reply = qobject_cast<QNetworkReply*>(sender());
    if (!reply) return;

    QString promptId = reply->property("promptId").toString();
    QString filename = reply->property("filename").toString();

    if (reply->error() == QNetworkReply::NoError) {
        QByteArray data = reply->readAll();
        QPixmap pixmap;
        if (pixmap.loadFromData(data)) {
            qDebug() << "å›¾ç‰‡ä¸‹è½½æˆåŠŸ:" << filename;

            emit imageReceived(promptId, filename, pixmap);
        } else {
            qDebug() << "å›¾ç‰‡æ•°æ®æŸå";
        }
    } else {
        qDebug() << "å›¾ç‰‡ä¸‹è½½å¤±è´¥:" << reply->errorString();
    }
    reply->deleteLater();
}

/**
 * @brief ä¸Šä¼ å›¾ç‰‡åˆ°æœåŠ¡å™¨
 * @param localPath æœ¬åœ°å›¾ç‰‡è·¯å¾„
 */
void ComfyApiService::uploadImage(const QString& localPath)
{
    QFile* file = new QFile(localPath);
    if (!file->open(QIODevice::ReadOnly)) {
        qDebug() << "æ— æ³•æ‰“å¼€æœ¬åœ°å›¾ç‰‡:" << localPath;
        delete file;
        return;
    }

    QHttpMultiPart *multiPart = new QHttpMultiPart(QHttpMultiPart::FormDataType);

    QHttpPart imagePart;
    QString fileName = QFileInfo(localPath).fileName();

    imagePart.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("image/png"));
    imagePart.setHeader(QNetworkRequest::ContentDispositionHeader,
                        QVariant(QString("form-data; name=\"image\"; filename=\"%1\"").arg(fileName)));

    imagePart.setBodyDevice(file);
    file->setParent(multiPart);

    multiPart->append(imagePart);

    QUrl url(m_apiBaseUrl + "/upload/image");
    QNetworkRequest request(url);

    qDebug() << "æ­£åœ¨ä¸Šä¼ å›¾ç‰‡:" << localPath;

    QNetworkReply* reply = m_networkManager->post(request, multiPart);
    multiPart->setParent(reply);

    connect(reply, &QNetworkReply::sslErrors, reply, [reply](const QList<QSslError> &errors){
        Q_UNUSED(errors);
        reply->ignoreSslErrors();
    });

    connect(reply, &QNetworkReply::finished, this, [=](){
        if (reply->error() == QNetworkReply::NoError) {
            QByteArray response = reply->readAll();
            QJsonDocument doc = QJsonDocument::fromJson(response);
            QJsonObject obj = doc.object();

            QString serverName = obj["name"].toString();

            qDebug() << "å›¾ç‰‡ä¸Šä¼ æˆåŠŸ! æœåŠ¡å™¨æ–‡ä»¶å:" << serverName;
            emit imageUploaded(serverName);
        } else {
            qDebug() << "ä¸Šä¼ å¤±è´¥:" << reply->errorString();
        }
        reply->deleteLater();
    });
}


--- æ–‡ä»¶ç»“æŸ: src\Network\ComfyApiService.cpp ---

--- æ–‡ä»¶å¼€å§‹: src\Network\ComfyApiService.h ---

/**
 * @file ComfyApiService.h
 * @brief ComfyUI APIæœåŠ¡ç±»å¤´æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†ComfyApiServiceç±»ï¼Œç”¨äºä¸ComfyUIæœåŠ¡å™¨è¿›è¡Œé€šä¿¡ã€‚
 * åŒ…å«HTTPè¯·æ±‚å’ŒWebSocketè¿æ¥åŠŸèƒ½ï¼Œæ”¯æŒå›¾ç‰‡ç”Ÿæˆè¿›åº¦ç›‘æ§å’Œç»“æœæ¥æ”¶ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#pragma once

#include <QObject>
#include <QPixmap>
#include <QJsonObject>
#include <QNetworkReply>
#include <QUuid>
#include <QHttpMultiPart>

// å‰å‘å£°æ˜
class QNetworkAccessManager;
class QWebSocket;

/**
 * @brief ComfyUI APIæœåŠ¡ç±»
 * 
 * è´Ÿè´£ä¸ComfyUIæœåŠ¡å™¨è¿›è¡ŒHTTPå’ŒWebSocketé€šä¿¡ï¼Œ
 * å¤„ç†å›¾ç‰‡ç”Ÿæˆè¯·æ±‚ã€è¿›åº¦ç›‘æ§å’Œç»“æœæ¥æ”¶ã€‚
 */
class ComfyApiService : public QObject
{
    Q_OBJECT

public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param parent çˆ¶å¯¹è±¡æŒ‡é’ˆ
     */
    explicit ComfyApiService(QObject *parent = nullptr);

    /**
     * @brief ææ„å‡½æ•°
     */
    ~ComfyApiService();

    /**
     * @brief è¿æ¥åˆ°ComfyUIæœåŠ¡å™¨
     * @param address æœåŠ¡å™¨åœ°å€
     * @param port æœåŠ¡å™¨ç«¯å£
     */
    void connectToHost(const QString& baseUrl);

    /**
     * @brief å‘é€æç¤ºè¯ç”Ÿæˆä»»åŠ¡
     * @param workflow å·¥ä½œæµJSONå¯¹è±¡
     */
    void queuePrompt(const QJsonObject& workflow);

    /**
     * @brief è·å–å›¾ç‰‡æ•°æ®
     * @param filename å›¾ç‰‡æ–‡ä»¶å
     * @param subfolder å­æ–‡ä»¶å¤¹è·¯å¾„
     * @param type å›¾ç‰‡ç±»å‹
     * @param promptId æç¤ºè¯ID
     */
    void getImage(const QString& filename, const QString& subfolder, const QString& type, const QString& promptId);

    /**
     * @brief ä¸Šä¼ å›¾ç‰‡åˆ°æœåŠ¡å™¨
     * @param localPath æœ¬åœ°å›¾ç‰‡è·¯å¾„
     */
    void uploadImage(const QString& localPath);

signals:
    /**
     * @brief æœåŠ¡å™¨è¿æ¥æˆåŠŸä¿¡å·
     */
    void serverConnected();

    /**
     * @brief æœåŠ¡å™¨è¿æ¥æ–­å¼€ä¿¡å·
     */
    void serverDisconnected();

    /**
     * @brief ç”Ÿæˆè¿›åº¦æ›´æ–°ä¿¡å·
     * @param step å½“å‰æ­¥éª¤
     * @param total æ€»æ­¥éª¤æ•°
     */
    void progressUpdated(int step, int total);

    /**
     * @brief é”™è¯¯å‘ç”Ÿä¿¡å·
     * @param msg é”™è¯¯æ¶ˆæ¯
     */
    void errorOccurred(const QString& msg);

    void promptQueued(const QString& promptId);

    /**
     * @brief å›¾ç‰‡ä¸‹è½½å®Œæˆä¿¡å·
     * @param promptId æç¤ºè¯ID
     * @param filename æ–‡ä»¶å
     * @param img å›¾ç‰‡æ•°æ®
     */
    void imageReceived(const QString& promptId, const QString& filename, const QPixmap& img);

    /**
     * @brief å›¾ç‰‡ä¸Šä¼ æˆåŠŸä¿¡å·
     * @param serverFileName æœåŠ¡å™¨æ–‡ä»¶å
     */
    void imageUploaded(const QString& serverFileName);

    /**
     * @brief æµå¼æ–‡å­—æ¥æ”¶ä¿¡å·
     * @param token æ¥æ”¶åˆ°çš„æ–‡æœ¬
     * @param finished æ˜¯å¦å®Œæˆ
     */
    void streamTokenReceived(const QString& token, bool finished);

private slots:
    /**
     * @brief å¤„ç†HTTP POSTè¯·æ±‚å®Œæˆ
     */
    void onPostFinished();

    /**
     * @brief å¤„ç†WebSocketæ–‡æœ¬æ¶ˆæ¯
     * @param message æ¥æ”¶åˆ°çš„æ¶ˆæ¯å†…å®¹
     */
    void onTextMessageReceived(const QString &message);

    /**
     * @brief å¤„ç†å›¾ç‰‡ä¸‹è½½å®Œæˆ
     */
    void onImageDownloadFinished();

private:
    QNetworkAccessManager* m_networkManager; ///< HTTPç½‘ç»œç®¡ç†å™¨
    QWebSocket* m_webSocket; ///< WebSocketè¿æ¥
    QString m_apiBaseUrl; ///< APIåŸºç¡€URL
    QString m_currentPromptId; ///< å½“å‰ä»»åŠ¡IDï¼Œç”¨äºåŒ¹é…
    QString m_clientId; ///< å®¢æˆ·ç«¯ID
};


--- æ–‡ä»¶ç»“æŸ: src\Network\ComfyApiService.h ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\MainWindow.cpp ---

/**
 * @file MainWindow.cpp
 * @brief ä¸»çª—å£å®ç°æ–‡ä»¶
 *
 * è¯¥æ–‡ä»¶å®ç°äº†MainWindowç±»ï¼Œä½œä¸ºåº”ç”¨ç¨‹åºçš„ä¸»çª—å£ã€‚
 * åŒ…å«ç•Œé¢å¸ƒå±€ã€ç»„ä»¶ç®¡ç†ã€ä¿¡å·è¿æ¥å’Œäº‹ä»¶å¤„ç†ç­‰åŠŸèƒ½ã€‚
 *
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#include "MainWindow.h"
#include "Components/SidebarControl.h"
#include "Components/SessionList.h"
#include "Components/ChatArea.h"
#include "Components/InputPanel.h"      // å¿…é¡»åŒ…å«è¿™ä¸ª
#include "Components/WorkflowSelector.h"
#include "Components/ReferencePopup.h"  // å¿…é¡»åŒ…å«è¿™ä¸ª
#include "Components/ChatBubble.h"
#include "../Network/ComfyApiService.h"  // æ–°å¢
#include "../Core/WorkflowManager.h"
#include "../Model/DataModels.h"
#include "Components/HistoryGallery.h" // ã€æ–°å¢ã€‘
#include "Components/ImageViewer.h"

#include <QHBoxLayout>
#include <QVBoxLayout>
#include <QToolButton>
#include <QPropertyAnimation>
#include <QToolTip>
#include <QTimer>
#include <QVBoxLayout>
#include <QResizeEvent>
#include <limits>
#include <QDebug>
#include <QRandomGenerator> // ç”¨äºç”Ÿæˆéšæœºç§å­
#include <QStandardPaths>
#include <QFileDialog>
#include <QStandardPaths>
#include <QDir>
#include <QDateTime>
#include <QSettings>

/**
 * @brief æ„é€ å‡½æ•°
 * @param parent çˆ¶çª—å£æŒ‡é’ˆ
 *
 * åˆå§‹åŒ–ä¸»çª—å£ï¼Œè®¾ç½®çª—å£å±æ€§å¹¶åˆ›å»ºUIç•Œé¢ã€‚
 */
MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , m_leftStack(nullptr)
    , m_sessionList(nullptr)
    , m_chatArea(nullptr)
    , m_inputPanel(nullptr)
    , m_wfSelector(nullptr)
    , m_refPopup(nullptr)
    , m_sidebarControl(nullptr)
    , m_leftContainerVisible(true)
    , m_leftContainerOriginalWidth(250) // é»˜è®¤å®½åº¦
    , m_currentPageIndex(0) // é»˜è®¤æ˜¾ç¤ºä¼šè¯åˆ—è¡¨
    , m_historyGallery(nullptr)
    , m_leftContainerAnimation(nullptr)
    , m_mainLayout(nullptr)
    , m_apiService(nullptr) // æ–°å¢
{
    setupUi();
}

/**
 * @brief ææ„å‡½æ•°
 *
 * Qtä¼šè‡ªåŠ¨æ¸…ç†å­æ§ä»¶ï¼Œæ— éœ€æ‰‹åŠ¨åˆ é™¤ã€‚
 */
MainWindow::~MainWindow()
{
}

/**
 * @brief åˆå§‹åŒ–UIç•Œé¢
 *
 * åˆ›å»ºä¸»çª—å£çš„æ‰€æœ‰UIç»„ä»¶ï¼ŒåŒ…æ‹¬ï¼š
 * - ä¸­å¿ƒéƒ¨ä»¶å’Œä¸»å¸ƒå±€
 * - å·¦ä¾§ä¼šè¯åˆ—è¡¨
 * - å³ä¾§èŠå¤©åŒºåŸŸå’Œè¾“å…¥é¢æ¿
 * - æµ®åŠ¨çª—å£ï¼ˆå·¥ä½œæµé€‰æ‹©å™¨å’Œå‚è€ƒå›¾å¼¹çª—ï¼‰
 * - ä¿¡å·è¿æ¥å’Œåˆå§‹çŠ¶æ€è®¾ç½®
 */
void MainWindow::setupUi()
{
    this->resize(1280, 800);
    this->setWindowTitle("CloudArt");
    // 1. åˆ›å»ºä¸­å¿ƒéƒ¨ä»¶

    QWidget* central = new QWidget(this);
    this->setCentralWidget(central);

    // 2. é¡¶çº§æ°´å¹³å¸ƒå±€ (å·¦ä¾§åˆ—è¡¨ | å³ä¾§å·¥ä½œåŒº)
    m_mainLayout = new QHBoxLayout(central);
    m_mainLayout->setContentsMargins(0, 0, 0, 0);
    m_mainLayout->setSpacing(0);

    // --- å·¦ä¾§å®¹å™¨å †æ ˆ ---
    m_leftStack = new QStackedWidget(central);

    // æ·»åŠ ä¼šè¯åˆ—è¡¨é¡µé¢
    m_sessionList = new SessionList(m_leftStack);
    m_leftStack->addWidget(m_sessionList);

    // æ·»åŠ å†å²è®°å½•é¡µé¢
    m_historyGallery = new HistoryGallery(m_leftStack);
    // è¿™é‡Œä¸éœ€è¦æ‰‹åŠ¨ setStyleSheet äº†ï¼Œå› ä¸ºç»„ä»¶å†…éƒ¨å·²ç»å†™å¥½äº†
    m_leftStack->addWidget(m_historyGallery);

    // è¿æ¥å›¾åº“çš„ç‚¹å‡»ä¿¡å· -> æ‰“å¼€å¤§å›¾æŸ¥çœ‹å™¨
    connect(m_historyGallery, &HistoryGallery::imageClicked, this, [this](const QString& path){
        QPixmap pix(path);
        if (!pix.isNull()) {
            ImageViewer* viewer = new ImageViewer(pix, this);
            viewer->exec(); // æ¨¡æ€æ˜¾ç¤º
            delete viewer;
        }
    });

    // è®¾ç½®é»˜è®¤æ˜¾ç¤ºä¼šè¯åˆ—è¡¨
    m_leftStack->setCurrentIndex(0);

    // ä¿å­˜å·¦ä¾§å®¹å™¨çš„åˆå§‹å®½åº¦ï¼Œæœ€å¤§ä¸è¶…è¿‡250
    m_leftContainerOriginalWidth = 250;
    m_leftStack->setMaximumWidth(250);

    m_mainLayout->insertWidget(0, m_leftStack);

    // --- å³ä¾§å®¹å™¨ ---
    QWidget* rightWidget = new QWidget(central);
    QVBoxLayout* rightLayout = new QVBoxLayout(rightWidget);
    rightLayout->setContentsMargins(0, 0, 0, 0);
    rightLayout->setSpacing(0);

    // A. å³ä¸Šï¼šèŠå¤©åŒºåŸŸ (ChatArea) - å æ®ä¸»è¦ç©ºé—´ (Stretch = 1)
    m_chatArea = new ChatArea(rightWidget);
    rightLayout->addWidget(m_chatArea, 1);

    // B. å³ä¸‹ï¼šè¾“å…¥æ§åˆ¶æ¿ (InputPanel) - ã€è¿™é‡Œå°±æ˜¯åˆ›å»ºå®ƒçš„åœ°æ–¹ï¼ã€‘
    m_inputPanel = new InputPanel(rightWidget);
    rightLayout->addWidget(m_inputPanel);

    // å°†å³ä¾§æ•´ä½“åŠ å…¥ä¸»å¸ƒå±€
    m_mainLayout->addWidget(rightWidget);

    // ---------------------------------------------------------
    // ä¸‹é¢æ˜¯æµ®åŠ¨çª—å£çš„åˆå§‹åŒ– (ä¸åŠ å…¥ Layoutï¼Œç‹¬ç«‹å­˜åœ¨çš„)
    // ---------------------------------------------------------

    // åˆå§‹åŒ–ä¸šåŠ¡ç®¡ç†å™¨
    m_wfManager = new WorkflowManager(this);

    // 1. åˆå§‹åŒ–å·¥ä½œæµé€‰æ‹©å™¨
    m_wfSelector = new WorkflowSelector(this);


    // 2. åˆå§‹åŒ–å‚è€ƒå›¾å¼¹çª—
    m_refPopup = new ReferencePopup(this);

    // ---------------------------------------------------------
    // åˆ‡æ¢æŒ‰é’®å’ŒåŠ¨ç”»åˆå§‹åŒ–
    // ---------------------------------------------------------
    // ä¾§è¾¹æ æ§åˆ¶ç»„ä»¶åˆå§‹åŒ–
    // ---------------------------------------------------------

    m_sidebarControl = new SidebarControl(this);

    // åˆ›å»ºåŠ¨ç”»æ•ˆæœ - ä½¿ç”¨minimumWidthå’ŒmaximumWidthæ§åˆ¶æ”¶ç¼©
    m_leftContainerAnimation = new QPropertyAnimation(m_leftStack, "minimumWidth", this);
    m_leftContainerAnimation->setDuration(300); // 300æ¯«ç§’åŠ¨ç”»
    m_leftContainerAnimation->setEasingCurve(QEasingCurve::InOutQuad);

    // è¿æ¥æŒ‰é’®ç‚¹å‡»ä¿¡å·
    connect(m_sidebarControl->toggleBtn(), &QToolButton::clicked,
            this, &MainWindow::switchToSessionList);
    connect(m_sidebarControl->historyBtn(), &QToolButton::clicked,
            this, &MainWindow::switchToHistoryWindow);

    // ---------------------------------------------------------
    // ä¿¡å·è¿æ¥
    // ---------------------------------------------------------

    // 1. ç‚¹å‡»"é€‰æ‹©å·¥ä½œæµ"æŒ‰é’® -> å‘¼å‡ºå·¥ä½œæµé¢æ¿
    connect(m_inputPanel->getWorkflowBtn(), &QPushButton::clicked,
            this, &MainWindow::onWorkflowBtnClicked);

    // 2. ç‚¹å‡»"å‚è€ƒå›¾(å›å½¢é’ˆ)"æŒ‰é’® -> å‘¼å‡ºå‚è€ƒå›¾é¢æ¿
    connect(m_inputPanel->getRefBtn(), &QToolButton::clicked,
            this, &MainWindow::onRefBtnClicked);

    // 3. ç‚¹å‡»"ç”Ÿæˆ"æŒ‰é’® -> å¤„ç†ç”Ÿæˆè¯·æ±‚
    connect(m_inputPanel, &InputPanel::generateClicked,
            this, &MainWindow::onGenerateClicked);

    // 4. å·¥ä½œæµé€‰æ‹©å™¨é€‰ä¸­å·¥ä½œæµ -> æ›´æ–°ç•Œé¢çŠ¶æ€
    connect(m_wfSelector, &WorkflowSelector::workflowSelected,
            this, &MainWindow::onWorkflowSelected);

    connect(m_inputPanel->getInterrogateBtn(), &QToolButton::clicked,
            this, &MainWindow::onInterrogateClicked);



    // ---------------------------------------------------------
    // åˆå§‹çŠ¶æ€è®¾ç½®
    // ---------------------------------------------------------

    // é»˜è®¤æˆ‘ä»¬å‡è®¾å½“å‰æ˜¯â€œæ–‡ç”Ÿå›¾â€æ¨¡å¼ï¼Œæ‰€ä»¥ç¦ç”¨å‚è€ƒå›¾æŒ‰é’®

    // é»˜è®¤æˆ‘ä»¬å‡è®¾å½“å‰æ˜¯â€œæ–‡ç”Ÿå›¾â€æ¨¡å¼
    m_inputPanel->updateState(WorkflowType::TextToImage);

    // =========================================================
    // ã€ä¿®å¤ä»£ç ã€‘åˆå§‹åŒ–ä¾§è¾¹æ æ§åˆ¶ç»„ä»¶çš„ä½ç½®
    // =========================================================

    // 1. å¼ºåˆ¶è®¾ç½®åˆå§‹ä½ç½®ã€‚
    // æ³¨æ„ï¼šæ­¤æ—¶ m_leftStack->width() å¯èƒ½è¿˜æ²¡è®¡ç®—å¥½ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æ¥ä½¿ç”¨
    // å·²çŸ¥çš„ m_leftContainerOriginalWidth (250) æ¥è®¡ç®—ï¼Œç¡®ä¿è½¯ä»¶ä¸€å¯åŠ¨æŒ‰é’®å°±åœ¨æ­£ç¡®ä½ç½®ã€‚
    if (m_leftContainerVisible) {
        int initialBtnX = m_leftContainerOriginalWidth + 10;
        m_sidebarControl->move(initialBtnX, 10);
    } else {
        m_sidebarControl->move(10, 10);
    }

    // 2. ç¡®ä¿æŒ‰é’®åœ¨æ‰€æœ‰æ§ä»¶çš„æœ€ä¸Šå±‚ï¼ˆé˜²æ­¢è¢« Sidebar é®æŒ¡ï¼‰
    m_sidebarControl->raise();

    // 3. ä½¿ç”¨ 0ms å®šæ—¶å™¨è¿›è¡ŒäºŒæ¬¡æ ¡å‡†
    // è¿™æ˜¯ä¸€ä¸ª Qt å¸¸ç”¨æŠ€å·§ï¼š0ms å®šæ—¶å™¨ä¼šåœ¨å½“å‰äº‹ä»¶å¾ªç¯ç»“æŸåï¼ˆå³ç•Œé¢æ˜¾ç¤ºã€å¸ƒå±€è®¡ç®—å®Œæˆåï¼‰ç«‹åˆ»æ‰§è¡Œã€‚
    // è¿™æ ·èƒ½ç¡®ä¿ updateSidebarPosition è·å–åˆ°çš„æ˜¯ Layout è®¡ç®—åçš„çœŸå®åæ ‡ã€‚
    QTimer::singleShot(0, this, [this](){
        updateSidebarPosition();
    });

    // ---------------------------------------------------------
    // APIæœåŠ¡åˆå§‹åŒ–
    // ---------------------------------------------------------

    // --- æ‰¾åˆ°æœ€ååˆå§‹åŒ– m_apiService çš„åœ°æ–¹ ---

    m_apiService = new ComfyApiService(this);

    // 1. è¿æ¥æˆåŠŸ -> è§£é”å¹¶æ¢å¤æ–‡å­—
    connect(m_apiService, &ComfyApiService::serverConnected, this, [this](){
        this->setWindowTitle("CloudArt - å·²è¿æ¥ âœ…");
        m_inputPanel->setConnectionStatus(true); // <--- è°ƒç”¨è¿™é‡Œ
    });

    // 2. è¿æ¥æ–­å¼€ -> é”å®šå¹¶æç¤ºæœªè¿æ¥
    connect(m_apiService, &ComfyApiService::serverDisconnected, this, [this](){
        this->setWindowTitle("CloudArt - æœªè¿æ¥ âŒ");
        m_inputPanel->setConnectionStatus(false); // <--- è°ƒç”¨è¿™é‡Œ
    });

    // 3. é”™è¯¯ -> é”å®š
    connect(m_apiService, &ComfyApiService::errorOccurred, this, [this](const QString& msg){
        this->setWindowTitle("CloudArt - è¿æ¥å¤±è´¥ âš ï¸");
        m_inputPanel->setConnectionStatus(false); // <--- è°ƒç”¨è¿™é‡Œ
    });

    // åˆå§‹çŠ¶æ€é”ä½
    m_inputPanel->setConnectionStatus(false);

    // ã€æ–°å¢ã€‘è¿æ¥ä¾§è¾¹æ çš„â€œè®¾ç½®æŒ‰é’®â€
    connect(m_sidebarControl->settingsBtn(), &QToolButton::clicked, this, [this](){
        SettingsDialog dlg(this);
        if (dlg.exec() == QDialog::Accepted) {
            // å¦‚æœç”¨æˆ·ç‚¹äº†ç¡®å®šï¼Œå°±é‡æ–°è¯»å–é…ç½®å¹¶è¿æ¥
            loadAndConnect();
        }
    });

    // å¯åŠ¨æ—¶ï¼Œè‡ªåŠ¨è¯»å–é…ç½®å¹¶è¿æ¥
    loadAndConnect();

    // =========================================================
    // ã€æ ¸å¿ƒé€»è¾‘ 1ã€‘ä»»åŠ¡æäº¤æˆåŠŸï¼ŒæœåŠ¡å™¨è¿”å›äº† ID
    // =========================================================
    connect(m_apiService, &ComfyApiService::promptQueued, this, [this](const QString& promptId){
        // å¦‚æœå½“å‰æœ‰ä¸€ä¸ªæ­£åœ¨ç­‰å¾… ID çš„æ°”æ³¡
        if (m_tempBubbleForId) {
            qDebug() << "ğŸ”— ç»‘å®šä»»åŠ¡ ID:" << promptId << " åˆ°å½“å‰æ°”æ³¡";
            // å­˜å…¥æ˜ å°„è¡¨ï¼šä»¥åçœ‹åˆ°è¿™ä¸ª IDï¼Œå°±çŸ¥é“æ˜¯è¿™ä¸ªæ°”æ³¡
            m_pendingBubbles.insert(promptId, m_tempBubbleForId);
            // æ¸…ç©ºæš‚å­˜æŒ‡é’ˆï¼Œå‡†å¤‡ä¸‹ä¸€æ¬¡ä½¿ç”¨
            m_tempBubbleForId = nullptr;
        }
    });

    // =========================================================
    // ã€æ ¸å¿ƒé€»è¾‘ 2ã€‘å›¾ç‰‡ä¸‹è½½å®Œæ¯•
    // =========================================================
    connect(m_apiService, &ComfyApiService::imageReceived, this,
            [this](const QString& promptId, const QString& filename, const QPixmap& img){

                // 1. ã€æ–°å¢ã€‘ä¿å­˜å›¾ç‰‡åˆ°æœ¬åœ°å­˜å‚¨
                QString localPath = saveImageToLocal(img);

                // 2. ã€æ–°å¢ã€‘å­˜å…¥æ•°æ®åº“ (AI Role)
                int currentSid = m_chatArea->currentSessionId();
                if (currentSid != -1 && !localPath.isEmpty()) {
                    MessageData msg(currentSid, MessageRole::AI, "", localPath); // æ–‡æœ¬ä¸ºç©ºï¼Œè·¯å¾„æœ‰å€¼
                    DatabaseManager::instance().addMessage(msg);
                }

                // æ£€æŸ¥è¿™ä¸ª ID æ˜¯å¦åœ¨æˆ‘ä»¬çš„ç­‰å¾…åˆ—è¡¨ä¸­
                if (m_pendingBubbles.contains(promptId)) {
                    qDebug() << "ğŸ–¼ï¸ æ‰¾åˆ°å¯¹åº”çš„æ°”æ³¡ï¼Œæ›´æ–°å›¾ç‰‡...";

                    ChatBubble* bubble = m_pendingBubbles[promptId];
                    if (bubble) {
                        // 1. æ°”æ³¡å˜èº« (é«˜åº¦ç¬é—´å˜é«˜)
                        bubble->updateImage(img, filename);


                        QTimer::singleShot(100, this, [this](){
                            m_chatArea->scrollToBottom();
                        });
                    }

                    setJobRunning(false);

                    // ä»»åŠ¡å®Œæˆï¼Œä»ç­‰å¾…åˆ—è¡¨ä¸­ç§»é™¤
                    m_pendingBubbles.remove(promptId);
                } else {
                    // å¯èƒ½æ˜¯æ—§çš„æˆ–è€…å…¶ä»–æ¥æºçš„å›¾ç‰‡ï¼Œç›´æ¥åŠ åˆ°æœ€åï¼ˆå…œåº•ç­–ç•¥ï¼‰
                    if (m_chatArea) {
                        m_chatArea->addAiImage(img);
                        // å…œåº•é€»è¾‘ä¹Ÿè¦æ»š
                        QTimer::singleShot(100, this, [this](){ m_chatArea->scrollToBottom(); });
                    }
                }
            });

    connect(m_chatArea, &ChatArea::upscaleRequested, this,
            [this](const QString& serverFileName, const QPixmap& img){

                if (m_isJobRunning) {
                    qDebug() << "âš ï¸ ä»»åŠ¡è¿›è¡Œä¸­ï¼Œå¿½ç•¥é«˜æ¸…ä¿®å¤è¯·æ±‚";
                    return;
                }

                // ã€æ–°å¢ã€‘ä¸Šé”
                setJobRunning(true);

                qDebug() << "æ”¶åˆ°é«˜æ¸…ä¿®å¤è¯·æ±‚ï¼Œå‡†å¤‡å›ç¯ä¸Šä¼ ...";

                // 1. åœ¨ç•Œé¢ä¸ŠåŠ ä¸ªè½¬åœˆæ°”æ³¡
                m_tempUpscaleBubble = m_chatArea->addLoadingBubble();

                // 2. å°†å›¾ç‰‡ä¿å­˜ä¸ºæœ¬åœ°ä¸´æ—¶æ–‡ä»¶
                QString tempPath = QStandardPaths::writableLocation(QStandardPaths::TempLocation)
                                   + "/temp_upscale_source.png";
                if (img.save(tempPath)) {
                    // 3. è®¾ç½®æ ‡è®°ä½ï¼Œå¼€å§‹ä¸Šä¼ 
                    m_isUploadingForUpscale = true;

                    // è¿™é‡Œçš„ m_tempBubbleForId éœ€è¦æŒ‡å‘è¿™ä¸ªæ–°æ°”æ³¡ï¼Œä»¥ä¾¿ upload å®Œå‘ä»»åŠ¡æ—¶ä½¿ç”¨
                    // ä½†æˆ‘ä»¬åœ¨ imageUploaded é‡Œå¤„ç†å‘ä»»åŠ¡ï¼Œæ‰€ä»¥è¿™é‡Œåªéœ€è¦ä¼ æ–‡ä»¶
                    m_apiService->uploadImage(tempPath);
                } else {
                    qDebug() << "âŒ ä¸´æ—¶æ–‡ä»¶ä¿å­˜å¤±è´¥";
                    // åº”è¯¥åˆ é™¤è½¬åœˆæ°”æ³¡...
                    setJobRunning(false);
                }
            });

    connect(m_apiService, &ComfyApiService::imageUploaded, this, [this](const QString& serverName){

        // --- åˆ†æ”¯ï¼šå¦‚æœæ˜¯ä¸ºäº†é«˜æ¸…ä¿®å¤ ---
        if (m_isUploadingForUpscale) {
            qDebug() << "ğŸ”„ é«˜æ¸…ä¿®å¤åŸå›¾ä¸Šä¼ å®Œæ¯• (" << serverName << ")ï¼Œå¼€å§‹å‘é€ç”Ÿæˆä»»åŠ¡...";

            // 1. å¤ä½æ ‡è®°
            m_isUploadingForUpscale = false;

            // 2. å‡†å¤‡å‚æ•°
            QMap<QString, QVariant> params;
            params["image_path"] = serverName; // å¡«å…¥åˆšæ‰ä¸Šä¼ è¿”å›çš„æ–‡ä»¶å

            qint64 seed = QRandomGenerator::global()->generate();
            if (seed < 0) seed = -seed;
            params["seed"] = seed;

            // 3. æ„å»ºé«˜æ¸…ä¿®å¤å·¥ä½œæµ
            QJsonObject wf = m_wfManager->buildWorkflow(WorkflowType::Upscale, params);

            // 4. ç»‘å®šæ°”æ³¡ ID
            // æŠŠåˆšæ‰åˆ›å»ºçš„è½¬åœˆæ°”æ³¡ (m_tempUpscaleBubble) è½¬ç§»ç»™ m_tempBubbleForId
            // è¿™æ ·å½“ queuePrompt è¿”å› promptID æ—¶ï¼Œå°±ä¼šè‡ªåŠ¨ç»‘å®šåˆ°è¿™ä¸ªæ°”æ³¡
            m_tempBubbleForId = m_tempUpscaleBubble;
            m_tempUpscaleBubble = nullptr;

            // 5. å‘é€ä»»åŠ¡
            if (m_apiService) {
                m_apiService->queuePrompt(wf);
            }

            return;
        }

        // --- åˆ†æ”¯ B: ã€æ–°å¢ã€‘è§†è§‰åæ¨ ---
        if (m_isUploadingForInterrogate) {
            qDebug() << "åæ¨å›¾ç‰‡ä¸Šä¼ æˆåŠŸï¼Œæ­£åœ¨æ„å»ºä»»åŠ¡...";
            m_isUploadingForInterrogate = false; // å¤ä½æ ‡è®°
            m_currentServerRefImg = serverName;  // è®°ä¸‹æ¥ä¾›åç»­ä½¿ç”¨

            // 1. å‡†å¤‡å‚æ•°
            QMap<QString, QVariant> params;
            params["image_path"] = serverName; // å¡«å…¥åˆšæ‰ä¸Šä¼ çš„æ–‡ä»¶å

            // 2. è°ƒç”¨ç®¡ç†å™¨æ„å»º JSON
            QJsonObject wf = m_wfManager->buildWorkflow(WorkflowType::VisionCaption, params);

            // 3. å‘é€ä»»åŠ¡
            if (wf.isEmpty()) {
                qDebug() << "âŒ åæ¨å·¥ä½œæµæ„å»ºå¤±è´¥";
                setJobRunning(false); // è®°å¾—è§£é”
                return;
            }

            if (m_apiService) {
                m_apiService->queuePrompt(wf);
            }

            // åæ¨ä¸éœ€è¦ m_tempBubbleForIdï¼Œå› ä¸ºå®ƒæ˜¯æµå¼è¾“å‡ºï¼Œæˆ‘ä»¬ä¼šåŠ¨æ€åˆ›å»ºæ°”æ³¡
            return;
        }

        // --- åˆ†æ”¯ C: ã€æ–°å¢ã€‘å›¾ç”Ÿå›¾ç”Ÿæˆæ¥åŠ› ---
        if (m_isUploadingForI2I) {
            qDebug() << "å›¾ç”Ÿå›¾ç´ æä¸Šä¼ å®Œæ¯•:" << serverName;
            m_isUploadingForI2I = false; // å¤ä½æ ‡è®°

            // 1. å–å‡ºä¹‹å‰æš‚å­˜çš„å‚æ•° (æç¤ºè¯ã€ç§å­)
            QMap<QString, QVariant> params = m_pendingI2IParams;

            // 2. å¡«å…¥æœ€å…³é”®çš„å‚æ•°ï¼šæœåŠ¡å™¨ä¸Šçš„æ–‡ä»¶å
            params["image_path"] = serverName;

            // 3. æ„å»ºå·¥ä½œæµ JSON
            QJsonObject wf = m_wfManager->buildWorkflow(WorkflowType::ImageToImage, params);

            // 4. å‘é€ä»»åŠ¡
            if (wf.isEmpty()) {
                qDebug() << "âŒ å›¾ç”Ÿå›¾å·¥ä½œæµæ„å»ºå¤±è´¥";
                setJobRunning(false);
                return;
            }

            if (m_apiService) {
                m_apiService->queuePrompt(wf);
            }

            // æ³¨æ„ï¼šæ­¤æ—¶ m_tempBubbleForId ä¾ç„¶æŒ‡å‘æˆ‘ä»¬åœ¨ onGenerateClicked é‡Œåˆ›å»ºçš„é‚£ä¸ªæ°”æ³¡
            // ç­‰ä¸€ä¼šå„¿ promptQueued ä¿¡å·å›æ¥ï¼Œå°±ä¼šè‡ªåŠ¨æŠŠå®ƒå’Œä»»åŠ¡ ID ç»‘å®šä¸Š
            return;
        }



        // (æœªæ¥è¿™é‡Œè¿˜å¯ä»¥åŠ  else if å¤„ç†å›¾ç”Ÿå›¾çš„ä¸Šä¼ é€»è¾‘)
    });

    // ã€æ–°å¢ã€‘ç›‘å¬æµå¼æ–‡æœ¬ (åæ¨æç¤ºè¯)
    // =========================================================
    connect(m_apiService, &ComfyApiService::streamTokenReceived, this,
            [this](const QString& token, bool finished){

                // 1. ã€æ–°å¢ã€‘ç´¯åŠ æ–‡æœ¬ (åªç´¯åŠ æœ‰æ•ˆå†…å®¹)
                if (!token.isEmpty()) {
                    m_accumulatedStreamText += token;
                }

                // 2. UI æ˜¾ç¤º (åŸæœ‰é€»è¾‘)
                if (m_chatArea) {
                    m_chatArea->handleStreamToken(token, finished);
                }

                // 3. ç»“æŸå¤„ç†
                if (finished) {
                    qDebug() << "âœ… åæ¨ç»“æŸï¼Œå®Œæ•´æ–‡æœ¬é•¿åº¦:" << m_accumulatedStreamText.length();

                    // ã€æ–°å¢ã€‘å­˜å…¥æ•°æ®åº“ (AI Role)
                    int currentSid = m_chatArea->currentSessionId();

                    // åªæœ‰å½“æœ‰å†…å®¹ä¸”æœ‰ä¼šè¯æ—¶æ‰å­˜
                    if (currentSid != -1 && !m_accumulatedStreamText.isEmpty()) {
                        MessageData msg(currentSid, MessageRole::AI, m_accumulatedStreamText);
                        DatabaseManager::instance().addMessage(msg);
                        qDebug() << "ğŸ’¾ åæ¨æ–‡æœ¬å·²ä¿å­˜åˆ°æ•°æ®åº“";
                    }

                    // ã€æ–°å¢ã€‘æ¸…ç©ºç¼“å­˜ï¼Œä¸ºä¸‹æ¬¡åšå‡†å¤‡ (å¯é€‰ï¼ŒåŒé‡ä¿é™©)
                    m_accumulatedStreamText.clear();

                    setJobRunning(false);
                }
            });

    // å·¦ä¾§åˆ—è¡¨è¯·æ±‚æ–°å»ºä¼šè¯
    connect(m_sessionList, &SessionList::createNewSessionRequest,
            this, &MainWindow::createNewSession); // ã€ä¿®æ”¹ã€‘è¿åˆ°æ–°å†™çš„å‡½æ•°

    // 2. ã€ä¿®å¤ã€‘å¤„ç†é‡å‘½å
    connect(m_sessionList, &SessionList::sessionRenameRequest, this,
            [this](int id, const QString& newName){

                // æ›´æ–°æ•°æ®åº“
                DatabaseManager::instance().renameSession(id, newName);
                qDebug() << "ä¼šè¯" << id << "é‡å‘½åä¸º" << newName;
            });

    // 3. ã€ä¿®å¤ã€‘å¤„ç†åˆ é™¤
    connect(m_sessionList, &SessionList::sessionDeleteRequest, this,
            [this](int id){

                // æ›´æ–°æ•°æ®åº“ (çº§è”åˆ é™¤æ¶ˆæ¯)
                DatabaseManager::instance().deleteSession(id);

                // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ­£åœ¨çœ‹çš„ä¼šè¯ï¼Œæ¸…ç©ºå³ä¾§å¹¶é‡ç½® ID
                if (m_chatArea->currentSessionId() == id) {
                    m_chatArea->clear();
                    m_chatArea->setCurrentSessionId(-1);
                }
                qDebug() << "ä¼šè¯" << id << "å·²åˆ é™¤";
            });

    // å·¦ä¾§åˆ—è¡¨è¯·æ±‚åˆ‡æ¢ä¼šè¯ (ä¹‹å‰å¯èƒ½æ²¡å®ç°å…·ä½“é€»è¾‘ï¼Œç°åœ¨è¦è¡¥ä¸Š)
    connect(m_sessionList, &SessionList::sessionSwitchRequest, this, [this](int id){
        loadSessionHistory(id);
    });

    // ...

    // ã€æœ€åä¸€æ­¥ã€‘å¯åŠ¨æ—¶åŠ è½½æ•°æ®
    // æ”¾åœ¨ setupUi çš„æœ€åï¼Œæˆ–è€… show() ä¹‹å‰
    loadSessionList();
}

/**
 * @brief å·¥ä½œæµæŒ‰é’®ç‚¹å‡»äº‹ä»¶å¤„ç†
 *
 * å½“ç”¨æˆ·ç‚¹å‡»å·¥ä½œæµé€‰æ‹©æŒ‰é’®æ—¶ï¼Œå¼¹å‡ºå·¥ä½œæµé€‰æ‹©å™¨çª—å£ã€‚
 * çª—å£ä½ç½®è‡ªåŠ¨è®¡ç®—åœ¨æŒ‰é’®ä¸Šæ–¹å±…ä¸­æ˜¾ç¤ºã€‚
 */
void MainWindow::onWorkflowBtnClicked() {
    // è·å–æŒ‰é’®ä½ç½®ï¼Œè®©é¢æ¿å‡ºç°åœ¨æŒ‰é’®ä¸Šæ–¹
    QPushButton* btn = m_inputPanel->getWorkflowBtn();
    if (btn) {
        QPoint btnPos = btn->mapToGlobal(QPoint(btn->width() / 2, 0));
        m_wfSelector->popup(btnPos);
    }
}

/**
 * @brief å‚è€ƒå›¾æŒ‰é’®ç‚¹å‡»äº‹ä»¶å¤„ç†
 *
 * å½“ç”¨æˆ·ç‚¹å‡»å‚è€ƒå›¾æŒ‰é’®æ—¶ï¼Œåˆ‡æ¢å‚è€ƒå›¾é€‰æ‹©çª—å£çš„æ˜¾ç¤ºå’Œéšè—çŠ¶æ€ã€‚
 * å¦‚æœçª—å£å·²æ˜¾ç¤ºï¼Œåˆ™éšè—ï¼›å¦‚æœçª—å£å·²éšè—ï¼Œåˆ™æ˜¾ç¤ºã€‚
 */
void MainWindow::onRefBtnClicked() {
    // å¦‚æœçª—å£å·²æ˜¾ç¤ºï¼Œåˆ™éšè—ï¼›å¦åˆ™æ˜¾ç¤º
    if (m_refPopup->isVisible()) {
        m_refPopup->hide();
    } else {
        // è·å–æŒ‰é’®ä½ç½®ï¼Œè®©é¢æ¿å‡ºç°åœ¨æŒ‰é’®ä¸Šæ–¹
        QToolButton* btn = m_inputPanel->getRefBtn();
        if (btn) {
            QPoint btnPos = btn->mapToGlobal(QPoint(btn->width() / 2, 0));
            m_refPopup->popup(btnPos);
        }
    }
}

/**
 * @brief å·¥ä½œæµé€‰æ‹©äº‹ä»¶å¤„ç†
 * @param info é€‰ä¸­çš„å·¥ä½œæµä¿¡æ¯
 *
 * å½“ç”¨æˆ·ä»å·¥ä½œæµé€‰æ‹©å™¨ä¸­é€‰æ‹©å·¥ä½œæµæ—¶ï¼Œæ›´æ–°è¾“å…¥é¢æ¿çŠ¶æ€ã€‚
 * æ ¹æ®å·¥ä½œæµç±»å‹å¯ç”¨æˆ–ç¦ç”¨ç›¸å…³åŠŸèƒ½æŒ‰é’®ã€‚
 */
void MainWindow::onWorkflowSelected(const WorkflowInfo& info)
{
    // æ ¹æ®å·¥ä½œæµç±»å‹æ›´æ–°è¾“å…¥é¢æ¿çŠ¶æ€
    m_inputPanel->updateState(info.type);

    // ã€æ–°å¢ã€‘è®°å½•å½“å‰ç±»å‹ï¼Œä¾›ç”Ÿæˆæ—¶ä½¿ç”¨
    m_currentWorkflowType = info.type;

    qDebug() << "åˆ‡æ¢åˆ°å·¥ä½œæµ:" << info.name << " (ID:" << info.id << ")";
}

/**
 * @brief ç”ŸæˆæŒ‰é’®ç‚¹å‡»äº‹ä»¶å¤„ç†
 * @param prompt ç”¨æˆ·è¾“å…¥çš„æç¤ºè¯
 *
 * å½“ç”¨æˆ·ç‚¹å‡»ç”ŸæˆæŒ‰é’®æ—¶ï¼Œå¤„ç†ç”Ÿæˆè¯·æ±‚ã€‚
 * åªæœ‰åœ¨è¾“å…¥æ¡†æœ‰å†…å®¹æ—¶æ‰ä¼šè§¦å‘æ­¤ä¿¡å·ã€‚
 * é¦–å…ˆåœ¨èŠå¤©åŒºåŸŸæ·»åŠ ç”¨æˆ·å¯¹è¯ï¼Œç„¶åå¤„ç†ç”Ÿæˆé€»è¾‘ã€‚
 */
void MainWindow::onGenerateClicked(const QString& prompt)
{
    // 1. æ£€æŸ¥é”
    if (m_isJobRunning) return;

    qDebug() << "ç”Ÿæˆè¯·æ±‚ - æç¤ºè¯:" << prompt;

    // ã€æ–°å¢ã€‘å­˜å…¥æ•°æ®åº“ -> UIæ˜¾ç¤º
    // åªæœ‰å½“å‰æœ‰é€‰ä¸­çš„ä¼šè¯æ‰å­˜ (currentSessionId != -1)
    // å¦‚æœæ²¡æœ‰é€‰ä¸­ä¼šè¯ï¼ˆæ¯”å¦‚åˆšå¯åŠ¨ï¼‰ï¼Œåº”è¯¥å…ˆ createNewSession()ï¼Œè¿™é‡Œå‡è®¾å·²æœ‰
    int currentSid = m_chatArea->currentSessionId();
    if (currentSid != -1) {
        // A. å­˜åº“
        MessageData msg(currentSid, MessageRole::User, prompt);
        DatabaseManager::instance().addMessage(msg);

        // B. ä¸Šå±
        m_chatArea->addUserMessage(prompt);
    }

    // 3. ç«‹å³æ·»åŠ â€œè½¬åœˆåœˆâ€æ°”æ³¡ï¼Œå¹¶æš‚å­˜æŒ‡é’ˆ
    // (è¿™ä¸ªæ°”æ³¡ä¼šä¸€ç›´è½¬ï¼Œç›´åˆ°æ–‡ç”Ÿå›¾çš„ä»»åŠ¡IDå›æ¥ï¼Œæˆ–è€…å›¾ç”Ÿå›¾çš„ä¸Šä¼ +ä»»åŠ¡IDå›æ¥)
    ChatBubble* loadingBubble = m_chatArea->addLoadingBubble();
    m_tempBubbleForId = loadingBubble;

    // 4. ä¸Šé”
    setJobRunning(true);

    // 5. å‡†å¤‡åŸºç¡€å‚æ•° (é€šç”¨éƒ¨åˆ†)
    QMap<QString, QVariant> params;
    params["prompt"] = prompt;

    qint64 seed = QRandomGenerator::global()->generate();
    if (seed < 0) seed = -seed;
    params["seed"] = seed;

    qDebug() << "å‡†å¤‡ç”Ÿæˆ, ç±»å‹:" << (int)m_currentWorkflowType << " ç§å­:" << seed;

    // =================================================
    // åˆ†æ”¯ A: å›¾ç”Ÿå›¾ (ImageToImage) -> éœ€è¦å…ˆä¸Šä¼ 
    // =================================================
    if (m_currentWorkflowType == WorkflowType::ImageToImage) {
        // è·å–æœ¬åœ°å‚è€ƒå›¾è·¯å¾„
        QString localPath = m_refPopup->currentPath();

        if (localPath.isEmpty()) {
            qDebug() << "âŒ å›¾ç”Ÿå›¾æ¨¡å¼å¿…é¡»å…ˆé€‰æ‹©å‚è€ƒå›¾";
            // å¤±è´¥å¤„ç†ï¼šè§£é”ï¼Œå¹¶æŠŠåˆšæ‰ç”Ÿæˆçš„è½¬åœˆæ°”æ³¡åˆ æ‰(æˆ–è€…æ˜¾ç¤ºé”™è¯¯)
            setJobRunning(false);
            // è¿™é‡Œç®€å•å¤„ç†ï¼Œä½ å¯ä»¥åŠ ä¸ª delete loadingBubble;
            return;
        }

        // æ ‡è®°çŠ¶æ€ï¼šè¿™æ¬¡ä¸Šä¼ æ˜¯ä¸ºäº† I2I
        m_isUploadingForI2I = true;

        // æš‚å­˜å‚æ•° (ç­‰ä¸Šä¼ å®Œäº†ï¼Œå†æŠŠ filename å¡è¿›å»)
        m_pendingI2IParams = params;

        // å¼€å§‹ä¸Šä¼  (ä¸Šä¼ æˆåŠŸåä¼šè§¦å‘ imageUploaded ä¿¡å·ï¼Œé€»è¾‘åœ¨é‚£è¾¹ç»§ç»­)
        if (m_apiService) {
            m_apiService->uploadImage(localPath);
        }

        // ã€é‡è¦ã€‘ç›´æ¥è¿”å›ï¼Œä¸è¦å¾€ä¸‹èµ°äº†ï¼Œç­‰å¾…å¼‚æ­¥å›è°ƒ
        return;
    }

    // =================================================
    // åˆ†æ”¯ B: æ–‡ç”Ÿå›¾ (TextToImage) -> ç›´æ¥å‘é€
    // =================================================
    if (m_currentWorkflowType == WorkflowType::TextToImage) {
        // è·å–åˆ†è¾¨ç‡è®¾ç½®
        QSize size = m_inputPanel->currentResolution();
        if (size.isEmpty()) size = QSize(1024, 1024);

        params["width"] = size.width();
        params["height"] = size.height();

        qDebug() << "è®¾å®šåˆ†è¾¨ç‡:" << size.width() << "x" << size.height();
    }

    // 6. æ„å»ºå·¥ä½œæµ JSON
    QJsonObject workflow = m_wfManager->buildWorkflow(m_currentWorkflowType, params);

    // 7. å‘é€ç»™ ComfyUI
    if (workflow.isEmpty()) {
        qDebug() << "âŒ å·¥ä½œæµæ„å»ºå¤±è´¥";
        setJobRunning(false); // è§£é”
        return;
    }

    if (m_apiService) {
        m_apiService->queuePrompt(workflow);
    } else {
        qDebug() << "âŒ ApiService æœªåˆå§‹åŒ–";
        setJobRunning(false);
    }
}

/**
 * @brief åˆ‡æ¢å·¦ä¾§å®¹å™¨æ˜¾ç¤ºçŠ¶æ€
 *
 * å½“å·¦ä¾§å®¹å™¨ä¸åœ¨åœºæ—¶ï¼Œå‘¼å‡ºå®¹å™¨ï¼›
 * å½“å·¦ä¾§å®¹å™¨åœ¨åœºæ—¶ï¼Œæ”¶èµ·å®¹å™¨ã€‚
 */
void MainWindow::onToggleLeftContainer()
{
    if (m_leftContainerVisible) {
        // æ”¶èµ·å·¦ä¾§å®¹å™¨ - å‘å·¦åŠ¨ç”»æ”¶ç¼©åˆ°0å®½åº¦
        m_leftContainerAnimation->setStartValue(m_leftStack->width());
        m_leftContainerAnimation->setEndValue(0);
        m_leftContainerAnimation->start();

        // è®¾ç½®maximumWidthä¸º0ï¼Œç¡®ä¿å®Œå…¨éšè—
        m_leftStack->setMaximumWidth(0);

        m_leftContainerVisible = false;

        // æ›´æ–°ä¾§è¾¹æ ä½ç½®
        QTimer::singleShot(300, this, [this]() {
            updateSidebarPosition();
        });
    } else {
        // å‘¼å‡ºå·¦ä¾§å®¹å™¨ - å‘å³åŠ¨ç”»æ¢å¤åˆ°åŸå§‹å®½åº¦
        // è®¾ç½®æœ€å¤§å®½åº¦é™åˆ¶ä¸º250
        m_leftStack->setMaximumWidth(250);

        // ä½¿ç”¨ä¿å­˜çš„åˆå§‹å®½åº¦
        m_leftContainerAnimation->setStartValue(0);
        m_leftContainerAnimation->setEndValue(m_leftContainerOriginalWidth);
        m_leftContainerAnimation->start();

        m_leftContainerVisible = true;

        // æ›´æ–°ä¾§è¾¹æ ä½ç½®
        QTimer::singleShot(300, this, [this]() {
            updateSidebarPosition();
        });
    }
}

/**
 * @brief æ›´æ–°ä¾§è¾¹æ ä½ç½®
 *
 * æ ¹æ®å·¦ä¾§å®¹å™¨çš„æ˜¾ç¤ºçŠ¶æ€ï¼Œè°ƒæ•´ä¾§è¾¹æ çš„ä½ç½®ã€‚
 * å·¦ä¾§å®¹å™¨æ˜¾ç¤ºæ—¶ä¾§è¾¹æ åœ¨å®¹å™¨å³ä¾§ä¸Šæ–¹ï¼Œå·¦ä¾§å®¹å™¨éšè—æ—¶ä¾§è¾¹æ åœ¨çª—å£å·¦ä¸Šè§’ã€‚
 */
void MainWindow::updateSidebarPosition()
{
    if (m_leftContainerVisible) {
        // å·¦ä¾§å®¹å™¨æ˜¾ç¤ºæ—¶ï¼Œä¾§è¾¹æ åœ¨å®¹å™¨å³ä¾§ä¸Šæ–¹
        // ä½¿ç”¨å®¹å™¨çš„å®é™…å®½åº¦æ¥è®¡ç®—ä½ç½®
        int containerWidth = m_leftStack->width();
        if (containerWidth <= 0) {
            containerWidth = 250; // é»˜è®¤å®½åº¦
        }
        // ä¾§è¾¹æ æ”¾åœ¨å®¹å™¨å³ä¾§ï¼Œè·ç¦»å®¹å™¨å³è¾¹æ¡†10åƒç´ 
        QPoint pos = m_leftStack->mapToParent(QPoint(containerWidth + 10, 10));
        m_sidebarControl->move(pos);
    } else {
        // å·¦ä¾§å®¹å™¨éšè—æ—¶ï¼Œä¾§è¾¹æ åœ¨çª—å£å·¦ä¸Šè§’
        m_sidebarControl->move(10, 10);
    }

    m_sidebarControl->raise(); // ç¡®ä¿ä¾§è¾¹æ åœ¨æœ€ä¸Šå±‚
}

/**
 * @brief åˆ‡æ¢å·¦ä¾§é¢æ¿
 * @param targetIndex ç›®æ ‡é¡µé¢ç´¢å¼•
 */
void MainWindow::switchLeftPanel(int targetIndex)
{
    if (!m_leftContainerVisible) {
        // å·¦ä¾§å®¹å™¨ä¸åœ¨åœºï¼Œå…ˆå‘¼å‡ºå®¹å™¨
        onToggleLeftContainer();
        // è®¾ç½®å½“å‰é¡µé¢ä¸ºç›®æ ‡é¡µé¢
        m_leftStack->setCurrentIndex(targetIndex);
        m_currentPageIndex = targetIndex;
    } else if (m_currentPageIndex != targetIndex) {
        // å·¦ä¾§å®¹å™¨åœ¨åœºä½†å½“å‰ä¸æ˜¯ç›®æ ‡é¡µé¢ï¼Œåˆ‡æ¢åˆ°ç›®æ ‡é¡µé¢
        m_leftStack->setCurrentIndex(targetIndex);
        m_currentPageIndex = targetIndex;
    } else {
        // å·¦ä¾§å®¹å™¨åœ¨åœºä¸”å½“å‰æ˜¯ç›®æ ‡é¡µé¢ï¼Œæ”¶èµ·å®¹å™¨
        onToggleLeftContainer();
    }
}

/**
 * @brief çª—å£å¤§å°æ”¹å˜äº‹ä»¶å¤„ç†
 * @param event çª—å£å¤§å°æ”¹å˜äº‹ä»¶
 *
 * å½“çª—å£å¤§å°æ”¹å˜æ—¶ï¼Œæ›´æ–°ä¾§è¾¹æ çš„ä½ç½®ã€‚
 */
void MainWindow::resizeEvent(QResizeEvent* event)
{
    QMainWindow::resizeEvent(event);
    updateSidebarPosition();
}

/**
 * @brief åˆ‡æ¢åˆ°ä¼šè¯åˆ—è¡¨é¡µé¢
 *
 * å½“å·¦ä¾§å®¹å™¨ä¸åœ¨åœºæ—¶ï¼Œå‘¼å‡ºå®¹å™¨å¹¶æ˜¾ç¤ºä¼šè¯åˆ—è¡¨ï¼›
 * å½“å·¦ä¾§å®¹å™¨åœ¨åœºæ—¶ï¼Œåˆ‡æ¢åˆ°ä¼šè¯åˆ—è¡¨é¡µé¢ã€‚
 */
void MainWindow::switchToSessionList()
{
    switchLeftPanel(0);
}

/**
 * @brief åˆ‡æ¢åˆ°å†å²è®°å½•é¡µé¢
 *
 * å½“å·¦ä¾§å®¹å™¨ä¸åœ¨åœºæ—¶ï¼Œå‘¼å‡ºå®¹å™¨å¹¶æ˜¾ç¤ºå†å²è®°å½•ï¼›
 * å½“å·¦ä¾§å®¹å™¨åœ¨åœºæ—¶ï¼Œåˆ‡æ¢åˆ°å†å²è®°å½•é¡µé¢ã€‚
 */
void MainWindow::switchToHistoryWindow()
{
    // 1. åˆ‡æ¢ç•Œé¢
    switchLeftPanel(1);

    // 2. æ¯æ¬¡åˆ‡æ¢è¿‡æ¥æ—¶ï¼Œåˆ·æ–°æ•°æ®
    // è¿™æ ·åˆšç”Ÿæˆçš„å›¾ä¹Ÿèƒ½ç«‹åˆ»çœ‹åˆ°
    if (m_leftStack->currentIndex() == 1) {
        m_historyGallery->loadImages();
    }
}

void MainWindow::setJobRunning(bool running)
{
    m_isJobRunning = running;

    // 1. ã€å…³é”®ã€‘é”å®šåº•éƒ¨é¢æ¿çš„æ‰€æœ‰æ“ä½œ (åŒ…æ‹¬æ¯”ä¾‹ã€å·¥ä½œæµã€è¾“å…¥æ¡†ç­‰)
    if (m_inputPanel) {
        m_inputPanel->setLocked(running);
        // è™½ç„¶æŒ‰é’®è¢«ç¦ç”¨äº†ï¼Œä½†æ”¹ä¸ªæ–‡å­—æç¤ºä¸€ä¸‹ç”¨æˆ·å½“å‰çŠ¶æ€è¿˜æ˜¯å‹å¥½çš„
        m_inputPanel->getGenerateBtn()->setText(running ? "ç”Ÿæˆä¸­..." : "ç”Ÿæˆ");
    }

    // 2. é”å®šå·¦ä¾§ä¼šè¯åˆ—è¡¨ (ç¦æ­¢åˆ‡æ¢ã€åˆ é™¤)
    if (m_sessionList) {
        m_sessionList->setEnabled(!running);
    }

    // 3. ã€æ–°å¢ã€‘é”å®šå·¦ä¸Šè§’çš„åˆ‡æ¢æŒ‰é’®å’Œå†å²æŒ‰é’®
    // é˜²æ­¢ç”¨æˆ·åœ¨ç”Ÿæˆæ—¶æŠŠä¾§è¾¹æ æ”¶èµ·æ¥ï¼Œæˆ–è€…è·³åˆ°å†å²è®°å½•é¡µ
    if (m_sidebarControl->toggleBtn()) m_sidebarControl->toggleBtn()->setEnabled(!running);
    if (m_sidebarControl->historyBtn()) m_sidebarControl->historyBtn()->setEnabled(!running);

}


void MainWindow::onInterrogateClicked()
{
    // 1. æ£€æŸ¥å¿™ç¢Œé”
    if (m_isJobRunning) return;

    // 2. ã€ä¿®æ”¹ã€‘ä¸å†æ‰“å¼€æ–‡ä»¶å¯¹è¯æ¡†ï¼Œè€Œæ˜¯ä»å‚è€ƒå›¾é¢æ¿è·å–è·¯å¾„
    QString localPath = m_refPopup->currentPath();

    // 3. æ ¡éªŒï¼šå¦‚æœæ²¡æœ‰é€‰å‚è€ƒå›¾
    if (localPath.isEmpty()) {
        // è‡ªåŠ¨å¼¹å‡ºå‚è€ƒå›¾é¢æ¿ï¼Œå¼•å¯¼ç”¨æˆ·
        QToolButton* btn = m_inputPanel->getRefBtn();
        if (btn) {
            QPoint btnPos = btn->mapToGlobal(QPoint(btn->width() / 2, 0));
            m_refPopup->popup(btnPos);
            // è¿™é‡Œå¯ä»¥åŠ ä¸€ä¸ª ToolTip æˆ–è€…ç®€å•çš„ Message æç¤ºç”¨æˆ·
            // btn->showToolTip("è¯·å…ˆåœ¨è¿™é‡Œä¸Šä¼ å›¾ç‰‡");
        }
        return;
    }

    // ã€æ–°å¢ã€‘å¼€å§‹æ–°ä»»åŠ¡å‰ï¼ŒåŠ¡å¿…æ¸…ç©ºæ–‡æœ¬ç¼“å­˜
    m_accumulatedStreamText.clear();

    // 4. ç•Œé¢åé¦ˆï¼šåœ¨èŠå¤©åŒºæ˜¾ç¤ºè¿™å¼ å›¾
    // è·å– ReferencePopup é‡Œçš„ç¼“å­˜å›¾ç‰‡ (QPixmap) ç›´æ¥æ˜¾ç¤ºï¼Œä¸ç”¨é‡æ–°åŠ è½½æ–‡ä»¶
    QPixmap pix = m_refPopup->currentImage();
    if (!pix.isNull()) {
        if (m_chatArea) m_chatArea->addUserImage(pix); // è¿˜æ˜¯æš‚æ—¶å€Ÿç”¨è¿™ä¸ªæ¥å£
    }

    // 5. ä¸Šé”å¹¶æ ‡è®°çŠ¶æ€
    setJobRunning(true);
    m_isUploadingForInterrogate = true; // æ ‡è®°ï¼šè¿™æ˜¯ä¸ºäº†åæ¨

    // 6. å¼€å§‹ä¸Šä¼ æœ¬åœ°æ–‡ä»¶
    if (m_apiService) {
        m_apiService->uploadImage(localPath);
    }
}

void MainWindow::loadSessionList()
{
    // 1. ä»æ•°æ®åº“æŸ¥æ•°æ® (é€šå¸¸æ˜¯æŒ‰æ—¶é—´å€’åºï¼Œæœ€æ–°çš„åœ¨ç¬¬0ä¸ª)
    QVector<SessionData> sessions = DatabaseManager::instance().getAllSessions();

    // 2. åˆ·æ–°å·¦ä¾§ UI
    m_sessionList->loadSessions(sessions);

    // 3. ã€æ ¸å¿ƒé€»è¾‘ã€‘åˆå§‹åŒ–é€‰ä¸­çŠ¶æ€
    if (!sessions.isEmpty()) {
        // --- æƒ…å†µ A: æ•°æ®åº“é‡Œæœ‰å†å²è®°å½• ---

        // è·å–æœ€æ–°çš„ä¼šè¯ ID (å³åˆ—è¡¨ç¬¬ä¸€ä¸ª)
        int firstId = sessions.first().id;

        // 1. è®©å·¦ä¾§åˆ—è¡¨è§†è§‰ä¸Šé€‰ä¸­å®ƒ
        m_sessionList->selectSession(firstId);

        // 2. è®©å³ä¾§èŠå¤©åŒºåŠ è½½å®ƒçš„å†å²è®°å½•
        loadSessionHistory(firstId);

        // 3. ç¡®ä¿å½“å‰ä¼šè¯ ID è¢«æ­£ç¡®è®°å½• (åŒé‡ä¿é™©)
        m_chatArea->setCurrentSessionId(firstId);
    }
    else {
        // --- æƒ…å†µ B: ç¬¬ä¸€æ¬¡å®‰è£…è½¯ä»¶ï¼Œæˆ–è€…æ˜¯ç©ºçš„ ---
        qDebug() << "æ•°æ®åº“ä¸ºç©ºï¼Œè‡ªåŠ¨åˆ›å»ºæ–°ä¼šè¯...";
        createNewSession();
        // createNewSession å†…éƒ¨ä¼šè‡ªåŠ¨åˆ·æ–°åˆ—è¡¨å¹¶é€‰ä¸­æ–°å»ºçš„é‚£ä¸ªï¼Œ
        // æ‰€ä»¥è¿™é‡Œä¸éœ€è¦å†å†™é¢å¤–çš„åŠ è½½é€»è¾‘
    }
}

void MainWindow::createNewSession()
{
    int newId = DatabaseManager::instance().createSession("æ–°ä¼šè¯");
    if (newId != -1) {
        // åˆ·æ–°åˆ—è¡¨
        loadSessionList();
        // æ³¨æ„ï¼šloadSessionList åˆšæ‰è¢«æˆ‘ä»¬æ”¹è¿‡äº†ã€‚
        // å› ä¸ºç°åœ¨æœ‰äº†æ–°ä¼šè¯ï¼Œå®ƒä¼šè¿›å…¥ "æƒ…å†µ A"ï¼Œè‡ªåŠ¨é€‰ä¸­è¿™ä¸ªæ–° IDã€‚
        // æ‰€ä»¥è¿™é‡Œä¸éœ€è¦å†æ‰‹åŠ¨ loadSessionHistory äº†ï¼Œé€»è¾‘é—­ç¯äº†ã€‚

        if (!m_leftContainerVisible) onToggleLeftContainer();
    }
}

QString MainWindow::saveImageToLocal(const QPixmap& img)
{
    // 1. ç¡®å®šä¿å­˜ç›®å½•
    QString dataDir = QStandardPaths::writableLocation(QStandardPaths::AppDataLocation);
    QString outputDir = dataDir + "/outputs";

    QDir dir(outputDir);
    if (!dir.exists()) dir.mkpath(".");

    // 2. ç”Ÿæˆå”¯ä¸€æ–‡ä»¶å (æ—¶é—´æˆ³.png)
    QString fileName = QString::number(QDateTime::currentMSecsSinceEpoch()) + ".png";
    QString fullPath = outputDir + "/" + fileName;

    // 3. ä¿å­˜
    if (img.save(fullPath, "PNG")) {
        return fullPath;
    }
    return QString();
}


void MainWindow::loadSessionHistory(int sessionId)
{
    qDebug() << "æ­£åœ¨åŠ è½½ä¼šè¯å†å²:" << sessionId;

    // 1. æ¸…ç©ºå½“å‰ç•Œé¢
    m_chatArea->clear();
    m_chatArea->setCurrentSessionId(sessionId);

    // 2. ä»æ•°æ®åº“æŸ¥æ•°æ®
    QVector<MessageData> messages = DatabaseManager::instance().getMessages(sessionId);

    // 3. éå†å¹¶æ¢å¤æ˜¾ç¤º
    for (const auto& msg : messages) {

        // åˆ¤æ–­è§’è‰²
        // æ³¨æ„ï¼šæ•°æ®åº“å­˜çš„æ˜¯å­—ç¬¦ä¸² "user"/"ai"ï¼ŒMessageDataé‡Œè½¬æˆäº†æšä¸¾
        // æˆ‘ä»¬çš„ ChatBubble ç”¨çš„æ˜¯ ChatRoleï¼Œå¯èƒ½éœ€è¦å¯¹åº”ä¸€ä¸‹
        ChatRole role = (msg.role == MessageRole::User) ? ChatRole::User : ChatRole::AI;

        if (msg.isImage()) {
            // --- å›¾ç‰‡æ¶ˆæ¯ ---
            // msg.imagePath æ˜¯æœ¬åœ°ç»å¯¹è·¯å¾„
            QPixmap pix(msg.imagePath);
            if (!pix.isNull()) {
                if (role == ChatRole::User) {
                    // å¦‚æœä½ ä¹‹å‰å†™äº† addUserImage å°±ç”¨é‚£ä¸ª
                    m_chatArea->addUserImage(pix);
                } else {
                    m_chatArea->addAiImage(pix);
                }
            } else {
                // å›¾ç‰‡æ–‡ä»¶ä¸¢å¤±çš„æƒ…å†µ
                if (role == ChatRole::User) m_chatArea->addUserMessage("[å›¾ç‰‡æ–‡ä»¶å·²ä¸¢å¤±]");
                else m_chatArea->addAiMessage("[å›¾ç‰‡æ–‡ä»¶å·²ä¸¢å¤±]");
            }
        }
        else {
            // --- æ–‡å­—æ¶ˆæ¯ ---
            if (role == ChatRole::User) {
                m_chatArea->addUserMessage(msg.text);
            } else {
                // AI çš„æ–‡å­— (åæ¨ç»“æœ)
                m_chatArea->addAiMessage(msg.text);
            }
        }
    }

    // 4. æ»šåˆ°åº•éƒ¨ (ç»™ç‚¹å»¶æ—¶è®©å¸ƒå±€ç®—å¥½)
    QTimer::singleShot(100, this, [this](){ m_chatArea->scrollToBottom(); });
}

// ã€æ–°å¢å‡½æ•°çš„å®ç°ã€‘
void MainWindow::loadAndConnect()
{
    QSettings settings("CloudArt", "AppConfig");
    QString url = settings.value("Server/Url", "http://127.0.0.1:8000").toString();

    if (url.isEmpty()) return;

    // ã€æ–°å¢ã€‘ç«‹å³æ›´æ–° UI çŠ¶æ€ä¸ºæ­£åœ¨è¿æ¥
    this->setWindowTitle("CloudArt - æ­£åœ¨è¿æ¥... ğŸ”„");
    qDebug() << "æ­£åœ¨å°è¯•è¿æ¥æœåŠ¡å™¨:" << url;

    m_inputPanel->setConnectionStatus(false);

    if (m_apiService) {
        m_apiService->connectToHost(url);
    }
}


--- æ–‡ä»¶ç»“æŸ: src\Ui\MainWindow.cpp ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\MainWindow.h ---

/**
 * @file MainWindow.h
 * @brief ä¸»çª—å£å¤´æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†MainWindowç±»ï¼Œä½œä¸ºåº”ç”¨ç¨‹åºçš„ä¸»çª—å£ã€‚
 * åŒ…å«ç•Œé¢ç»„ä»¶ç®¡ç†ã€ä¿¡å·æ§½å£°æ˜å’Œæˆå‘˜å˜é‡å®šä¹‰ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#pragma once

#include <QMainWindow>
#include <QPropertyAnimation>
#include <QHBoxLayout>
#include <QStackedWidget>
#include "../Model/WorkflowTypes.h"
#include "../Network/ComfyApiService.h"
#include "../Database/DatabaseManager.h"
#include "Components/SettingsDialog.h"

class InputPanel;
class WorkflowSelector;
class ReferencePopup;
class SessionList;
class ChatArea;
class QToolButton;
class ComfyApiService;
class WorkflowManager;
class ChatBubble;
class SidebarControl;
class HistoryGallery;

/**
 * @brief ä¸»çª—å£ç±»
 * 
 * ç»§æ‰¿è‡ªQMainWindowï¼Œä½œä¸ºåº”ç”¨ç¨‹åºçš„ä¸»çª—å£å®¹å™¨ã€‚
 * ç®¡ç†å·¦ä¾§ä¼šè¯åˆ—è¡¨ã€å³ä¾§èŠå¤©åŒºåŸŸå’Œè¾“å…¥é¢æ¿ï¼Œä»¥åŠæµ®åŠ¨çª—å£ç»„ä»¶ã€‚
 */
class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param parent çˆ¶çª—å£æŒ‡é’ˆ
     */
    explicit MainWindow(QWidget *parent = nullptr);

    /**
     * @brief ææ„å‡½æ•°
     */
    ~MainWindow();

private slots:
    /**
     * @brief å·¥ä½œæµæŒ‰é’®ç‚¹å‡»æ§½å‡½æ•°
     */
    void onWorkflowBtnClicked();

    /**
     * @brief å‚è€ƒå›¾æŒ‰é’®ç‚¹å‡»æ§½å‡½æ•°
     */
    void onRefBtnClicked();

    /**
     * @brief å·¥ä½œæµé€‰æ‹©æ§½å‡½æ•°
     * @param info é€‰ä¸­çš„å·¥ä½œæµä¿¡æ¯
     */
    void onWorkflowSelected(const WorkflowInfo& info);

    /**
     * @brief ç”ŸæˆæŒ‰é’®ç‚¹å‡»æ§½å‡½æ•°
     * @param prompt ç”¨æˆ·è¾“å…¥çš„æç¤ºè¯
     */
    void onGenerateClicked(const QString& prompt);

    /**
     * @brief åˆ‡æ¢å·¦ä¾§å®¹å™¨æ˜¾ç¤ºçŠ¶æ€
     */
    void onToggleLeftContainer();

    /**
     * @brief åˆ‡æ¢åˆ°ä¼šè¯åˆ—è¡¨é¡µé¢
     */
    void switchToSessionList();

    /**
     * @brief åˆ‡æ¢åˆ°å†å²è®°å½•é¡µé¢
     */
    void switchToHistoryWindow();

    /**
     * @brief å¤„ç†åæ¨æŒ‰é’®ç‚¹å‡»
     */
    void onInterrogateClicked();

    /**
     * @brief åŠ è½½å¹¶è¿æ¥å„ä¸ªç»„ä»¶
     */
    void loadAndConnect();

protected:
    /**
     * @brief çª—å£å¤§å°æ”¹å˜äº‹ä»¶å¤„ç†å‡½æ•°
     * @param event å¤§å°æ”¹å˜äº‹ä»¶
     */
    void resizeEvent(QResizeEvent* event) override;

private:
    /**
     * @brief åˆå§‹åŒ–UIå¸ƒå±€
     */
    void setupUi();

    /**
     * @brief æ›´æ–°ä¾§è¾¹æ ä½ç½®
     */
    void updateSidebarPosition();

    /**
     * @brief åŠ è½½æ‰€æœ‰å†å²ä¼šè¯
     */
    void loadSessionList();

    /**
     * @brief åˆ›å»ºæ–°ä¼šè¯
     */
    void createNewSession();

    /**
     * @brief åˆ‡æ¢å·¦ä¾§é¢æ¿
     * @param targetIndex ç›®æ ‡é¡µé¢ç´¢å¼•
     */
    void switchLeftPanel(int targetIndex);

    /**
     * @brief ä¿å­˜å›¾ç‰‡åˆ°æœ¬åœ°
     * @param img è¦ä¿å­˜çš„å›¾ç‰‡
     * @return QString ä¿å­˜åçš„æ–‡ä»¶è·¯å¾„
     */
    QString saveImageToLocal(const QPixmap& img);

    /**
     * @brief åŠ è½½æŒ‡å®šä¼šè¯çš„å†å²è®°å½•åˆ°èŠå¤©åŒº
     * @param sessionId ä¼šè¯ID
     */
    void loadSessionHistory(int sessionId);

    /**
     * @brief åˆ‡æ¢å¿™ç¢ŒçŠ¶æ€
     * @param running æ˜¯å¦æ­£åœ¨æ‰§è¡Œä»»åŠ¡
     */
    void setJobRunning(bool running);

private:
    QStackedWidget* m_leftStack; ///< å·¦ä¾§å®¹å™¨å †æ ˆ
    SessionList* m_sessionList; ///< ä¼šè¯åˆ—è¡¨ç»„ä»¶
    ChatArea* m_chatArea; ///< èŠå¤©åŒºåŸŸç»„ä»¶
    InputPanel* m_inputPanel; ///< åº•éƒ¨æ§åˆ¶é¢æ¿ç»„ä»¶
    WorkflowSelector* m_wfSelector; ///< å·¥ä½œæµé€‰æ‹©é¢æ¿ç»„ä»¶
    ReferencePopup* m_refPopup; ///< å‚è€ƒå›¾ä¸Šä¼ é¢æ¿ç»„ä»¶
    SidebarControl* m_sidebarControl; ///< ä¾§è¾¹æ æ§åˆ¶ç»„ä»¶
    QPropertyAnimation* m_leftContainerAnimation; ///< å·¦ä¾§å®¹å™¨åŠ¨ç”»æ•ˆæœ
    bool m_leftContainerVisible; ///< å·¦ä¾§å®¹å™¨æ˜¯å¦å¯è§
    int m_leftContainerOriginalWidth; ///< å·¦ä¾§å®¹å™¨çš„åˆå§‹å®½åº¦
    int m_currentPageIndex; ///< å½“å‰æ˜¾ç¤ºçš„é¡µé¢ç´¢å¼•
    HistoryGallery* m_historyGallery; ///< å†å²è®°å½•ç”»å»Šç»„ä»¶
    QHBoxLayout* m_mainLayout; ///< ä¸»å¸ƒå±€
    ComfyApiService* m_apiService; ///< APIæœåŠ¡
    WorkflowManager* m_wfManager; ///< ä¸šåŠ¡é€»è¾‘ç®¡ç†å™¨
    WorkflowType m_currentWorkflowType; ///< å½“å‰é€‰ä¸­çš„å·¥ä½œæµç±»å‹
    ChatBubble* m_tempBubbleForId; ///< æš‚å­˜åˆšåˆšåˆ›å»ºçš„åŠ è½½æ°”æ³¡
    QMap<QString, ChatBubble*> m_pendingBubbles; ///< ä»»åŠ¡IDåˆ°æ°”æ³¡æŒ‡é’ˆçš„æ˜ å°„è¡¨
    bool m_isUploadingForUpscale; ///< æ ‡è®°å½“å‰ä¸Šä¼ æ“ä½œæ˜¯å¦ä¸ºäº†é«˜æ¸…ä¿®å¤
    ChatBubble* m_tempUpscaleBubble; ///< æš‚å­˜é«˜æ¸…ä¿®å¤çš„æ°”æ³¡
    bool m_isJobRunning; ///< æ˜¯å¦æ­£åœ¨æ‰§è¡Œä»»åŠ¡ï¼ˆå¿™ç¢ŒçŠ¶æ€ï¼‰
    bool m_isUploadingForInterrogate; ///< æ ‡è®°å½“å‰ä¸Šä¼ æ˜¯å¦ä¸ºäº†åæ¨æç¤ºè¯
    QString m_currentServerRefImg; ///< è®°ä½åæ¨ç”¨çš„å›¾ç‰‡å
    bool m_isUploadingForI2I; ///< æ ‡è®°å½“å‰ä¸Šä¼ æ˜¯å¦ä¸ºäº†å›¾ç”Ÿå›¾ç”Ÿæˆ
    QMap<QString, QVariant> m_pendingI2IParams; ///< æš‚å­˜å›¾ç”Ÿå›¾éœ€è¦çš„å‚æ•°
    QString m_accumulatedStreamText; ///< ç”¨äºæš‚å­˜æµå¼ä¼ è¾“çš„å®Œæ•´æ–‡æœ¬
};


--- æ–‡ä»¶ç»“æŸ: src\Ui\MainWindow.h ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\ChatArea.cpp ---

/**
 * @file ChatArea.cpp
 * @brief èŠå¤©åŒºåŸŸç»„ä»¶å®ç°æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®ç°äº†ChatAreaç±»ï¼Œæä¾›èŠå¤©æ¶ˆæ¯çš„å±•ç¤ºåŠŸèƒ½ï¼Œæ”¯æŒç”¨æˆ·æ¶ˆæ¯ã€AIæ¶ˆæ¯å’Œå›¾ç‰‡çš„æ˜¾ç¤ºã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#include "ChatArea.h"
#include "ChatBubble.h"
#include <QScrollBar>
#include <QTimer>

ChatArea::ChatArea(QWidget *parent) : QWidget(parent)
{
    setupUi();
}

void ChatArea::setupUi()
{
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);

    m_scrollArea = new QScrollArea(this);
    m_scrollArea->setWidgetResizable(true);
    m_scrollArea->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_scrollArea->setFrameShape(QFrame::NoFrame);

    m_scrollArea->setStyleSheet(
        "QScrollArea { background: #343541; border: none; }"
        "QScrollBar:vertical { border: none; background: #343541; width: 10px; margin: 0px; }"
        "QScrollBar::handle:vertical { background: #565869; min-height: 20px; border-radius: 5px; }"
        "QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0px; }"
        "QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical { background: none; }"
        );

    m_scrollContent = new QWidget();
    m_scrollContent->setStyleSheet("background-color: transparent;");

    m_contentLayout = new QVBoxLayout(m_scrollContent);
    m_contentLayout->setContentsMargins(20, 20, 20, 20);
    m_contentLayout->setSpacing(20);
    m_contentLayout->addStretch();

    m_scrollArea->setWidget(m_scrollContent);
    mainLayout->addWidget(m_scrollArea);
}

void ChatArea::addUserMessage(const QString& text)
{
    ChatBubble* bubble = new ChatBubble(ChatRole::User, text, m_scrollContent);

    m_contentLayout->insertWidget(m_contentLayout->count() - 1, bubble);

    scrollToBottom();
}

ChatBubble* ChatArea::addLoadingBubble()
{
    ChatBubble* bubble = new ChatBubble(ChatRole::AI, "", m_scrollContent);

    connect(bubble, &ChatBubble::upscaleRequested, this, &ChatArea::upscaleRequested);

    m_contentLayout->insertWidget(m_contentLayout->count() - 1, bubble);
    scrollToBottom();

    return bubble;
}

void ChatArea::addAiImage(const QPixmap& img)
{
    ChatBubble* bubble = new ChatBubble(ChatRole::AI, img, m_scrollContent);
    connect(bubble, &ChatBubble::upscaleRequested, this, &ChatArea::upscaleRequested);
    m_contentLayout->insertWidget(m_contentLayout->count() - 1, bubble);
    scrollToBottom();
}

void ChatArea::scrollToBottom()
{
    QTimer::singleShot(10, this, [=](){
        QScrollBar* bar = m_scrollArea->verticalScrollBar();
        bar->setValue(bar->maximum());
    });
}

void ChatArea::clear()
{
    while (m_contentLayout->count() > 1) {
        QLayoutItem *item = m_contentLayout->takeAt(0);

        if (item->widget()) {
            delete item->widget();
        }
        delete item;
    }

    m_currentSessionId = -1;
    m_currentStreamBubble = nullptr;

    this->update();
}

void ChatArea::handleStreamToken(const QString& token, bool finished)
{
    if (finished && token.isEmpty() && !m_currentStreamBubble) {
        return;
    }

    if (token.isEmpty() && !finished) {
        return;
    }

    if (!m_currentStreamBubble) {
        m_currentStreamBubble = new ChatBubble(ChatRole::AI, token, m_scrollContent);
        m_contentLayout->insertWidget(m_contentLayout->count() - 1, m_currentStreamBubble);
    }
    else {
        if (!token.isEmpty()) {
            m_currentStreamBubble->appendText(token);
        }
    }

    QTimer::singleShot(10, this, [this](){ scrollToBottom(); });

    if (finished) {
        m_currentStreamBubble = nullptr;
    }
}

void ChatArea::addUserImage(const QPixmap& img)
{
    ChatBubble* bubble = new ChatBubble(ChatRole::User, img, m_scrollContent);
    m_contentLayout->insertWidget(m_contentLayout->count() - 1, bubble);
    scrollToBottom();
}

void ChatArea::addAiMessage(const QString& text)
{
    ChatBubble* bubble = new ChatBubble(ChatRole::AI, text, m_scrollContent);
    m_contentLayout->insertWidget(m_contentLayout->count() - 1, bubble);
    scrollToBottom();
}


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\ChatArea.cpp ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\ChatArea.h ---

/**
 * @file ChatArea.h
 * @brief èŠå¤©åŒºåŸŸç»„ä»¶å¤´æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†ChatAreaç±»ï¼Œä½œä¸ºåº”ç”¨ç¨‹åºå³ä¾§çš„èŠå¤©æ˜¾ç¤ºåŒºåŸŸã€‚
 * åŒ…å«ç”¨æˆ·æ¶ˆæ¯å’ŒAIå›¾ç‰‡çš„æ˜¾ç¤ºã€ä¼šè¯åˆ‡æ¢å’Œæ¸…ç©ºåŠŸèƒ½ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#pragma once
#include <QWidget>
#include <QScrollArea>
#include <QVBoxLayout>


class ChatBubble;

/**
 * @brief èŠå¤©åŒºåŸŸç±»
 * 
 * ç»§æ‰¿è‡ªQWidgetï¼Œç®¡ç†èŠå¤©æ¶ˆæ¯çš„æ˜¾ç¤ºå’Œä¼šè¯åˆ‡æ¢ã€‚
 * æ”¯æŒç”¨æˆ·æ–‡å­—æ¶ˆæ¯å’ŒAIå›¾ç‰‡æ¶ˆæ¯çš„æ·»åŠ å’Œæ˜¾ç¤ºã€‚
 */
class ChatArea : public QWidget
{
    Q_OBJECT
public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param parent çˆ¶çª—å£æŒ‡é’ˆ
     */
    explicit ChatArea(QWidget *parent = nullptr);

    /**
     * @brief æ¸…ç©ºå½“å‰èŠå¤©ç•Œé¢
     */
    void clear();

    /**
     * @brief è®¾ç½®å½“å‰ä¼šè¯ID
     * @param id ä¼šè¯ID
     */
    void setCurrentSessionId(int id) { m_currentSessionId = id; }
    
    /**
     * @brief è·å–å½“å‰ä¼šè¯ID
     * @return int å½“å‰ä¼šè¯IDï¼Œ-1è¡¨ç¤ºæ— é€‰ä¸­ä¼šè¯
     */
    int currentSessionId() const { return m_currentSessionId; }

    /**
     * @brief æ·»åŠ ç”¨æˆ·æ–‡å­—æ¶ˆæ¯
     * @param text ç”¨æˆ·æ¶ˆæ¯æ–‡æœ¬
     */
    void addUserMessage(const QString& text);

    /**
     * @brief æ·»åŠ AIå›¾ç‰‡æ¶ˆæ¯
     * @param img AIç”Ÿæˆçš„å›¾ç‰‡
     */
    void addAiImage(const QPixmap& img);

    /**
     * @brief æ·»åŠ åŠ è½½æ€æ°”æ³¡
     * @return ChatBubble* æ–°åˆ›å»ºçš„åŠ è½½æ°”æ³¡æŒ‡é’ˆ
     */
    ChatBubble* addLoadingBubble();

    /**
     * @brief è‡ªåŠ¨æ»šåŠ¨åˆ°åº•éƒ¨
     */
    void scrollToBottom();

    /**
     * @brief å¤„ç†æµå¼æ–‡å­—
     * @param token æµå¼æ–‡æœ¬ç‰‡æ®µ
     * @param finished æ˜¯å¦å®Œæˆ
     */
    void handleStreamToken(const QString& token, bool finished);

    /**
     * @brief æ·»åŠ ç”¨æˆ·å›¾ç‰‡æ¶ˆæ¯
     * @param img ç”¨æˆ·ä¸Šä¼ çš„å›¾ç‰‡
     */
    void addUserImage(const QPixmap& img);

    /**
     * @brief ç›´æ¥æ·»åŠ AIæ–‡æœ¬æ¶ˆæ¯ï¼ˆç”¨äºåŠ è½½å†å²ï¼Œæ— åŠ¨ç”»ï¼‰
     * @param text AIå›å¤çš„æ–‡æœ¬å†…å®¹
     */
    void addAiMessage(const QString& text);

signals:
    /**
     * @brief é«˜æ¸…ä¿®å¤è¯·æ±‚ä¿¡å·
     * @param filename æœåŠ¡å™¨æ–‡ä»¶å
     * @param img å›¾ç‰‡æ•°æ®
     */
    void upscaleRequested(const QString& filename, const QPixmap& img);

private:
    /**
     * @brief åˆå§‹åŒ–UIå¸ƒå±€
     */
    void setupUi();
    


private:
    QScrollArea* m_scrollArea; ///< æ»šåŠ¨åŒºåŸŸç»„ä»¶
    QWidget* m_scrollContent; ///< æ»šåŠ¨å†…å®¹ç»„ä»¶
    QVBoxLayout* m_contentLayout; ///< å†…å®¹å¸ƒå±€
    int m_currentSessionId = -1; ///< å½“å‰ä¼šè¯IDï¼Œ-1è¡¨ç¤ºæ— é€‰ä¸­ä¼šè¯
    // ã€æ–°å¢ã€‘è®°å½•å½“å‰æ­£åœ¨â€œæ‰“å­—â€çš„æ°”æ³¡æŒ‡é’ˆ
    ChatBubble* m_currentStreamBubble = nullptr;

};


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\ChatArea.h ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\ChatBubble.cpp ---

/**
 * @file ChatBubble.cpp
 * @brief èŠå¤©æ°”æ³¡ç»„ä»¶å®ç°æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®ç°äº†ChatBubbleç±»ï¼Œæä¾›èŠå¤©æ¶ˆæ¯æ°”æ³¡çš„æ˜¾ç¤ºå’Œäº¤äº’åŠŸèƒ½ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#include "ChatBubble.h"
#include "ImageViewer.h"
#include <QFrame>
#include <QDebug>
#include <QGraphicsDropShadowEffect>
#include <QMouseEvent>
#include <QStandardPaths>
#include <QFileDialog>
#include <QClipboard>
#include <QApplication>

/**
 * @brief æ„é€ å‡½æ•°
 * @param role æ¶ˆæ¯è§’è‰²
 * @param data æ¶ˆæ¯æ•°æ®
 * @param parent çˆ¶çª—å£æŒ‡é’ˆ
 */
ChatBubble::ChatBubble(ChatRole role, const QVariant& data, QWidget *parent)
    : QWidget(parent)
    , m_role(role)
{
    this->setAttribute(Qt::WA_StyledBackground, true);

    m_layout = new QHBoxLayout(this);
    m_layout->setContentsMargins(10, 10, 10, 10);
    m_layout->setSpacing(0);

    m_loadingMovie = new QMovie(":/images/loading.gif", QByteArray(), this);
    m_loadingMovie->setScaledSize(QSize(40, 40));

    setupUi(data);
}

/**
 * @brief åˆå§‹åŒ–UIå¸ƒå±€
 * @param data æ¶ˆæ¯æ•°æ®
 */
void ChatBubble::setupUi(const QVariant& data)
{
    if (m_role == ChatRole::User) {
        m_layout->addStretch();

        if (data.canConvert<QPixmap>()) {
            initImageBubble(data.value<QPixmap>());
        } else {
            initTextBubble(data.toString());
        }
    }
    else {
        if (data.canConvert<QPixmap>()) {
            initImageBubble(data.value<QPixmap>());
        }
        else if (data.typeId() == QMetaType::QString && data.toString().isEmpty()) {
            initImageBubble(QPixmap());
            setLoading(true);
        }
        else {
            initTextBubble(data.toString());
        }
        m_layout->addStretch();
    }
}

/**
 * @brief åˆå§‹åŒ–æ–‡æœ¬æ°”æ³¡
 * @param text æ–‡æœ¬å†…å®¹
 */
void ChatBubble::initTextBubble(const QString& text)
{
    QFrame* frame = new QFrame(this);

    QString style = (m_role == ChatRole::User)
                        ? "background-color: #444654; border-radius: 8px; color: #ECECF1; padding: 10px;"
                        : "background-color: #2A2B32; border-radius: 8px; color: #ECECF1; padding: 10px; border: 1px solid #444;";
    frame->setStyleSheet(style);

    QHBoxLayout* frameLayout = new QHBoxLayout(frame);
    frameLayout->setContentsMargins(0, 0, 0, 0);

    m_contentLabel = new QLabel(text, frame);

    m_contentLabel->setWordWrap(true);
    m_contentLabel->setStyleSheet("border: none; background: transparent;");
    m_contentLabel->setTextInteractionFlags(Qt::TextSelectableByMouse);
    m_contentLabel->setMaximumWidth(600);

    m_contentLabel->setContextMenuPolicy(Qt::CustomContextMenu);

    connect(m_contentLabel, &QLabel::customContextMenuRequested, this, [=](const QPoint& pos){
        QMenu menu;
        menu.setStyleSheet(
            "QMenu { background: #2D2D2D; color: white; border: 1px solid #555; padding: 5px; }"
            "QMenu::item { padding: 5px 20px; }"
            "QMenu::item:selected { background-color: #40414F; }"
            );

        QAction* actCopyAll = menu.addAction("ğŸ“‹ å¤åˆ¶å…¨éƒ¨å†…å®¹");
        connect(actCopyAll, &QAction::triggered, [=](){
            QClipboard *clipboard = QApplication::clipboard();
            clipboard->setText(m_contentLabel->text());
        });

        if (m_contentLabel->hasSelectedText()) {
            QAction* actCopySelected = menu.addAction("âœ‚ï¸ å¤åˆ¶é€‰ä¸­å†…å®¹");
            connect(actCopySelected, &QAction::triggered, [=](){
                QClipboard *clipboard = QApplication::clipboard();
                clipboard->setText(m_contentLabel->selectedText());
            });
        }

        menu.exec(m_contentLabel->mapToGlobal(pos));
    });

    frameLayout->addWidget(m_contentLabel);
    m_layout->addWidget(frame);
}

/**
 * @brief åˆå§‹åŒ–å›¾ç‰‡æ°”æ³¡
 * @param originalImg åŸå§‹å›¾ç‰‡
 */
void ChatBubble::initImageBubble(const QPixmap& originalImg)
{
    m_currentImage = originalImg;

    m_contentLabel = new QLabel(this);
    m_contentLabel->setStyleSheet("border-radius: 8px; border: 2px solid #444;");

    if (!originalImg.isNull()) {
        QSize maxDisplaySize(512, 512);
        QPixmap scaledImg = originalImg.scaled(maxDisplaySize, Qt::KeepAspectRatio, Qt::SmoothTransformation);
        m_contentLabel->setPixmap(scaledImg);
        m_contentLabel->setFixedSize(scaledImg.size());

        m_contentLabel->setCursor(Qt::PointingHandCursor);
        m_contentLabel->installEventFilter(this);
    } else {
        m_contentLabel->setFixedSize(200, 200);
        m_contentLabel->setAlignment(Qt::AlignCenter);
    }

    auto *shadow = new QGraphicsDropShadowEffect(this);
    shadow->setBlurRadius(15);
    shadow->setColor(QColor(0, 0, 0, 80));
    shadow->setOffset(0, 5);
    m_contentLabel->setGraphicsEffect(shadow);

    m_layout->addWidget(m_contentLabel);
}

/**
 * @brief æ˜¾ç¤ºå›¾ç‰‡æŸ¥çœ‹å™¨
 */
void ChatBubble::showViewer() {
    ImageViewer* viewer = new ImageViewer(m_currentImage, this);
    viewer->exec();
    delete viewer;
}

/**
 * @brief ä¿å­˜å›¾ç‰‡
 */
void ChatBubble::saveImage() {
    QString desktopPath = QStandardPaths::writableLocation(QStandardPaths::PicturesLocation);
    QString fileName = QFileDialog::getSaveFileName(this, "ä¿å­˜å›¾ç‰‡",
                                                    desktopPath + "/cloudart_gen.png",
                                                    "Images (*.png *.jpg)");
    if (!fileName.isEmpty()) {
        m_currentImage.save(fileName);
    }
}

/**
 * @brief åˆ‡æ¢åŠ è½½çŠ¶æ€
 * @param loading æ˜¯å¦æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
 */
void ChatBubble::setLoading(bool loading)
{
    if (!m_contentLabel) return;

    if (loading) {
        m_contentLabel->setMovie(m_loadingMovie);
        m_loadingMovie->start();
    } else {
        m_loadingMovie->stop();
        m_contentLabel->setMovie(nullptr);
    }
}

/**
 * @brief æ›´æ–°å›¾ç‰‡æ•°æ®
 * @param img ç”Ÿæˆçš„å›¾ç‰‡æ•°æ®
 * @param serverFileName æœåŠ¡å™¨æ–‡ä»¶å
 */
void ChatBubble::updateImage(const QPixmap& img, const QString& serverFileName)
{
    setLoading(false);

    m_currentImage = img;
    m_serverFileName = serverFileName;

    QSize maxDisplaySize(512, 512);
    QPixmap scaledImg = img.scaled(maxDisplaySize, Qt::KeepAspectRatio, Qt::SmoothTransformation);

    m_contentLabel->setPixmap(scaledImg);
    m_contentLabel->setFixedSize(scaledImg.size());

    m_contentLabel->setCursor(Qt::PointingHandCursor);
    m_contentLabel->removeEventFilter(this);
    m_contentLabel->installEventFilter(this);
}

/**
 * @brief äº‹ä»¶è¿‡æ»¤å™¨å¤„ç†
 * @param watched è¢«ç›‘è§†çš„å¯¹è±¡
 * @param event äº‹ä»¶
 * @return bool æ˜¯å¦å¤„ç†äº‹ä»¶
 */
bool ChatBubble::eventFilter(QObject *watched, QEvent *event)
{
    if (qobject_cast<QLabel*>(watched) && event->type() == QEvent::MouseButtonPress) {
        QMouseEvent* mouseEvent = static_cast<QMouseEvent*>(event);

        if (mouseEvent->button() == Qt::LeftButton) {
            if (!m_currentImage.isNull()) showViewer();
            return true;
        }
        else if (mouseEvent->button() == Qt::RightButton) {
            QMenu menu;
            menu.setStyleSheet(
                "QMenu { background: #2D2D2D; color: white; border: 1px solid #555; padding: 5px; }"
                "QMenu::item { padding: 5px 20px; }"
                "QMenu::item:selected { background-color: #40414F; }"
                );

            if (!m_currentImage.isNull()) {

                QAction* actCopy = menu.addAction("â å¤åˆ¶å›¾ç‰‡");
                connect(actCopy, &QAction::triggered, this, [=](){
                    QClipboard *clipboard = QApplication::clipboard();
                    clipboard->setPixmap(m_currentImage);
                });

                QAction* actSave = menu.addAction("ğŸ’¾ å¦å­˜ä¸º...");
                connect(actSave, &QAction::triggered, this, &ChatBubble::saveImage);

                menu.addSeparator();

                QAction* actUpscale = menu.addAction("âœ¨ é«˜æ¸…ä¿®å¤ (1.5x)");
                connect(actUpscale, &QAction::triggered, this, [=](){
                    emit upscaleRequested(m_serverFileName, m_currentImage);
                });
            }

            else if (m_contentLabel && !m_contentLabel->text().isEmpty()) {
                QAction* actCopyText = menu.addAction("ğŸ“‹ å¤åˆ¶å†…å®¹");
                connect(actCopyText, &QAction::triggered, [=](){
                    QApplication::clipboard()->setText(m_contentLabel->text());
                });
            }

            menu.exec(mouseEvent->globalPosition().toPoint());
            return true;
        }
    }
    return QWidget::eventFilter(watched, event);
}

/**
 * @brief è¿½åŠ æ–‡æœ¬
 * @param text è¦è¿½åŠ çš„æ–‡æœ¬å†…å®¹
 */
void ChatBubble::appendText(const QString& text)
{
    if (!m_contentLabel) {
        initTextBubble("");
    }

    if (m_loadingMovie && m_loadingMovie->state() == QMovie::Running) {
        setLoading(false);
    }

    QString current = m_contentLabel->text();
    m_contentLabel->setText(current + text);
}


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\ChatBubble.cpp ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\ChatBubble.h ---

/**
 * @file ChatBubble.h
 * @brief èŠå¤©æ°”æ³¡ç»„ä»¶å¤´æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†ChatBubbleç±»ï¼Œä½œä¸ºèŠå¤©åŒºåŸŸä¸­çš„æ¶ˆæ¯æ°”æ³¡ã€‚
 * æ”¯æŒç”¨æˆ·æ–‡æœ¬æ¶ˆæ¯å’ŒAIå›¾ç‰‡æ¶ˆæ¯çš„æ˜¾ç¤ºï¼ŒåŒ…å«ä¿å­˜å’ŒæŸ¥çœ‹åŠŸèƒ½ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#pragma once
#include <QWidget>
#include <QLabel>
#include <QHBoxLayout>
#include <QMenu>
#include <QMovie>

/**
 * @brief èŠå¤©è§’è‰²æšä¸¾
 * 
 * å®šä¹‰æ¶ˆæ¯å‘é€è€…çš„è§’è‰²ç±»å‹ã€‚
 */
enum class ChatRole {
    User, ///< ç”¨æˆ·è§’è‰²ï¼ˆé å³æ˜¾ç¤ºï¼Œæ–‡æœ¬æ¶ˆæ¯ï¼‰
    AI    ///< AIè§’è‰²ï¼ˆé å·¦æ˜¾ç¤ºï¼Œå›¾ç‰‡æ¶ˆæ¯ï¼‰
};

/**
 * @brief èŠå¤©æ°”æ³¡ç±»
 * 
 * ç»§æ‰¿è‡ªQWidgetï¼Œè¡¨ç¤ºèŠå¤©åŒºåŸŸä¸­çš„å•ä¸ªæ¶ˆæ¯æ°”æ³¡ã€‚
 * æ”¯æŒä¸åŒè§’è‰²çš„æ¶ˆæ¯æ˜¾ç¤ºã€å›¾ç‰‡ä¿å­˜å’ŒæŸ¥çœ‹åŠŸèƒ½ã€‚
 */
class ChatBubble : public QWidget
{
    Q_OBJECT
public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param role æ¶ˆæ¯è§’è‰²
     * @param data æ¶ˆæ¯æ•°æ®ï¼ˆæ–‡æœ¬æˆ–å›¾ç‰‡ï¼‰
     * @param parent çˆ¶çª—å£æŒ‡é’ˆ
     */
    explicit ChatBubble(ChatRole role, const QVariant& data, QWidget *parent = nullptr);

    /**
     * @brief æ§åˆ¶åŠ è½½åŠ¨ç”»
     * @param loading æ˜¯å¦æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
     */
    void setLoading(bool loading);

    /**
     * @brief æ›´æ–°å›¾ç‰‡æ•°æ®ï¼ˆç”Ÿæˆå®Œæˆåè°ƒç”¨ï¼‰
     * @param img ç”Ÿæˆçš„å›¾ç‰‡æ•°æ®
     * @param serverFileName æœåŠ¡å™¨æ–‡ä»¶å
     */
    void updateImage(const QPixmap& img, const QString& serverFileName);

    /**
     * @brief è·å–æœåŠ¡å™¨æ–‡ä»¶åï¼ˆç”¨äºé«˜æ¸…ä¿®å¤ï¼‰
     * @return QString æœåŠ¡å™¨æ–‡ä»¶å
     */
    QString serverFileName() const { return m_serverFileName; }

    /**
     * @brief å¾€æ°”æ³¡é‡Œè¿½åŠ æ–‡å­—
     * @param text è¦è¿½åŠ çš„æ–‡æœ¬å†…å®¹
     */
    void appendText(const QString& text);

signals:
    /**
     * @brief é«˜æ¸…ä¿®å¤è¯·æ±‚ä¿¡å·
     * @param fileName æœåŠ¡å™¨æ–‡ä»¶å
     * @param img å›¾ç‰‡æ•°æ®
     */
    void upscaleRequested(const QString& fileName, const QPixmap& img);

protected:
    /**
     * @brief äº‹ä»¶è¿‡æ»¤å™¨å¤„ç†
     * @param watched è¢«ç›‘è§†çš„å¯¹è±¡
     * @param event äº‹ä»¶
     * @return bool æ˜¯å¦å¤„ç†äº‹ä»¶
     */
    bool eventFilter(QObject *watched, QEvent *event) override;

private:
    /**
     * @brief åˆå§‹åŒ–UIå¸ƒå±€
     * @param data æ¶ˆæ¯æ•°æ®
     */
    void setupUi(const QVariant& data);

    /**
     * @brief åˆå§‹åŒ–æ–‡æœ¬æ°”æ³¡
     * @param text æ–‡æœ¬å†…å®¹
     */
    void initTextBubble(const QString& text);
    
    /**
     * @brief åˆå§‹åŒ–å›¾ç‰‡æ°”æ³¡
     * @param img å›¾ç‰‡æ•°æ®
     */
    void initImageBubble(const QPixmap& img);
    
    /**
     * @brief ä¿å­˜å›¾ç‰‡
     */
    void saveImage();
    
    /**
     * @brief æ˜¾ç¤ºå›¾ç‰‡æŸ¥çœ‹å™¨
     */
    void showViewer();

private:
    ChatRole m_role; ///< æ¶ˆæ¯è§’è‰²
    QHBoxLayout* m_layout; ///< æ°´å¹³å¸ƒå±€
    QPixmap m_currentImage; ///< å½“å‰å›¾ç‰‡æ•°æ®
    // ã€æ–°å¢ã€‘æˆå‘˜å˜é‡
    QLabel* m_contentLabel = nullptr; // ç»Ÿä¸€ç®¡ç†æ˜¾ç¤ºå†…å®¹çš„ Label
    QMovie* m_loadingMovie = nullptr; // åŠ è½½åŠ¨ç”»å¯¹è±¡
    QString m_serverFileName;         // æœåŠ¡å™¨ä¸Šçš„åŸå§‹æ–‡ä»¶å
};


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\ChatBubble.h ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\HistoryGallery.cpp ---

/**
 * @file HistoryGallery.cpp
 * @brief ç”Ÿæˆå†å²ç”»å»Šç»„ä»¶å®ç°æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®ç°äº†HistoryGalleryç±»ï¼Œæä¾›ç”Ÿæˆå†å²å›¾ç‰‡çš„å±•ç¤ºåŠŸèƒ½ï¼Œæ”¯æŒæŸ¥çœ‹å¤§å›¾ã€å¤åˆ¶å›¾ç‰‡å’Œå¤åˆ¶è·¯å¾„ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#include "HistoryGallery.h"
#include "../../Database/DatabaseManager.h"
#include <QScrollArea>
#include <QMouseEvent>
#include <QFileInfo>
#include <QScrollBar>
#include <QPainter>
#include <QDebug>
#include <QMenu>
#include <QClipboard>
#include <QApplication>

class GalleryItem : public QLabel
{
public:
    QString imagePath;
    std::function<void(QString)> onClick;

    GalleryItem(const QString& path, int targetWidth, QWidget* parent = nullptr)
        : QLabel(parent), imagePath(path)
    {
        this->setStyleSheet(
            "QLabel { "
            "  background-color: black; "
            "  border: 1px solid #333; "
            "  border-radius: 6px; "
            "}"
            "QLabel:hover { "
            "  border: 1px solid #19C37D; "
            "  cursor: pointer; "
            "}"
            );
        this->setAlignment(Qt::AlignCenter);

        QPixmap pix(path);
        if (!pix.isNull()) {
            QPixmap scaled = pix.scaledToWidth(targetWidth, Qt::SmoothTransformation);
            this->setPixmap(scaled);
            this->setFixedSize(scaled.size());
        } else {
            this->setText("âŒ å›¾ç‰‡ä¸¢å¤±");
            this->setFixedSize(targetWidth, 60);
            this->setStyleSheet("color: #666; border: 1px dashed #444; border-radius: 6px;");
        }
    }

protected:
    void mousePressEvent(QMouseEvent* event) override {
        if (event->button() == Qt::LeftButton) {
            if (onClick) onClick(imagePath);
        }
        else if (event->button() == Qt::RightButton) {
            showContextMenu(event->globalPosition().toPoint());
        }

        QLabel::mousePressEvent(event);
    }

private:
    void showContextMenu(const QPoint& pos) {
        QMenu menu;
        menu.setStyleSheet(
            "QMenu { background-color: #2D2D2D; color: white; border: 1px solid #555; padding: 5px; }"
            "QMenu::item { padding: 5px 20px; }"
            "QMenu::item:selected { background-color: #40414F; }"
            );

        QAction* actCopy = menu.addAction("â å¤åˆ¶å›¾ç‰‡");
        QObject::connect(actCopy, &QAction::triggered, [this](){
            QPixmap originalPix(imagePath);
            if (!originalPix.isNull()) {
                QClipboard *clipboard = QApplication::clipboard();
                clipboard->setPixmap(originalPix);
                qDebug() << "å›¾ç‰‡å·²å¤åˆ¶åˆ°å‰ªè´´æ¿:" << imagePath;
            }
        });

        QAction* actPath = menu.addAction("ğŸ“‚ å¤åˆ¶è·¯å¾„");
        QObject::connect(actPath, &QAction::triggered, [this](){
            QClipboard *clipboard = QApplication::clipboard();
            clipboard->setText(imagePath);
        });

        menu.exec(pos);
    }
};

HistoryGallery::HistoryGallery(QWidget *parent) : QWidget(parent)
{
    setupUi();
}

void HistoryGallery::setupUi()
{
    this->setFixedWidth(260);
    this->setStyleSheet("background-color: #202123; border-right: 1px solid #4D4D4F;");

    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 20, 0, 0);
    mainLayout->setSpacing(10);

    QLabel* title = new QLabel("ğŸ¨ ç”Ÿæˆå†å²", this);
    title->setStyleSheet("color: #ECECF1; font-weight: bold; font-size: 14px; padding-left: 15px; border: none;");
    mainLayout->addWidget(title);

    m_scrollArea = new QScrollArea(this);
    m_scrollArea->setWidgetResizable(true);
    m_scrollArea->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_scrollArea->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOn);
    m_scrollArea->setFrameShape(QFrame::NoFrame);

    m_scrollArea->verticalScrollBar()->setSingleStep(20);

    m_scrollArea->setStyleSheet(
        "QScrollArea { "
        "   background: transparent; "
        "   border: none; "
        "}"

        "QScrollBar:vertical { "
        "    border: none; "
        "    background: #111111; "
        "    width: 14px; "
        "    margin: 0px; "
        "}"

        "QScrollBar::handle:vertical { "
        "    background: #666666; "
        "    min-height: 30px; "
        "    border-radius: 7px; "
        "    margin: 2px; "
        "}"

        "QScrollBar::handle:vertical:hover { "
        "    background: #999999; "
        "}"

        "QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { "
        "    height: 0px; "
        "}"
        "QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical { "
        "    background: none; "
        "}"
        );

    m_scrollContent = new QWidget();
    m_scrollContent->setStyleSheet("background: transparent;");

    m_scrollLayout = new QVBoxLayout(m_scrollContent);
    m_scrollLayout->setContentsMargins(15, 10, 5, 10);
    m_scrollLayout->setSpacing(15);
    m_scrollLayout->setAlignment(Qt::AlignTop);

    m_scrollArea->setWidget(m_scrollContent);
    mainLayout->addWidget(m_scrollArea);
}

void HistoryGallery::clearLayout()
{
    QLayoutItem* item;
    while ((item = m_scrollLayout->takeAt(0)) != nullptr) {
        if (item->widget()) {
            delete item->widget();
        }
        delete item;
    }
}

void HistoryGallery::loadImages()
{
    clearLayout();

    QVector<QString> paths = DatabaseManager::instance().getAllAiImages();

    if (paths.isEmpty()) {
        QLabel* empty = new QLabel("æš‚æ— è®°å½•", m_scrollContent);
        empty->setStyleSheet("color: #666; font-size: 12px; margin-top: 20px; border:none;");
        empty->setAlignment(Qt::AlignHCenter);
        m_scrollLayout->addWidget(empty);
        return;
    }

    int cardWidth = 220;

    for (const QString& path : paths) {
        if (!QFileInfo::exists(path)) continue;

        GalleryItem* item = new GalleryItem(path, cardWidth, m_scrollContent);

        item->onClick = [this](QString p){
            emit imageClicked(p);
        };

        m_scrollLayout->addWidget(item);
    }
}


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\HistoryGallery.cpp ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\HistoryGallery.h ---

/**
 * @file HistoryGallery.h
 * @brief å†å²è®°å½•ç”»å»Šç»„ä»¶å¤´æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†HistoryGalleryç±»ï¼Œç”¨äºæ˜¾ç¤ºæ‰€æœ‰ç”Ÿæˆçš„å›¾ç‰‡å†å²è®°å½•ã€‚
 * æ”¯æŒå›¾ç‰‡åˆ—è¡¨å±•ç¤ºã€æ»šåŠ¨æµè§ˆå’Œç‚¹å‡»æŸ¥çœ‹åŠŸèƒ½ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#pragma once

#include <QWidget>
#include <QScrollArea>
#include <QVBoxLayout>
#include <QLabel>
#include <QVector>

/**
 * @brief å†å²è®°å½•ç”»å»Šç±»
 * 
 * ç»§æ‰¿è‡ªQWidgetï¼Œæä¾›å†å²å›¾ç‰‡çš„å±•ç¤ºåŠŸèƒ½ã€‚
 * ä½¿ç”¨æ»šåŠ¨åŒºåŸŸæ”¯æŒå¤§é‡å›¾ç‰‡çš„æµè§ˆï¼Œç‚¹å‡»å›¾ç‰‡å¯è§¦å‘æŸ¥çœ‹äº‹ä»¶ã€‚
 */
class HistoryGallery : public QWidget
{
    Q_OBJECT

public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param parent çˆ¶çª—å£æŒ‡é’ˆ
     */
    explicit HistoryGallery(QWidget *parent = nullptr);

    /**
     * @brief åˆ·æ–°æ˜¾ç¤ºå›¾ç‰‡
     * 
     * ä»æ•°æ®åº“åŠ è½½æ‰€æœ‰ç”Ÿæˆçš„å›¾ç‰‡å¹¶æ˜¾ç¤ºåœ¨ç”»å»Šä¸­
     */
    void loadImages();

signals:
    /**
     * @brief å›¾ç‰‡ç‚¹å‡»ä¿¡å·
     * @param imagePath è¢«ç‚¹å‡»çš„å›¾ç‰‡è·¯å¾„
     */
    void imageClicked(const QString& imagePath);

private:
    /**
     * @brief åˆå§‹åŒ–UIå¸ƒå±€
     */
    void setupUi();

    /**
     * @brief æ¸…é™¤å½“å‰çš„åˆ—è¡¨é¡¹
     * 
     * æ¸…ç©ºæ»šåŠ¨åŒºåŸŸä¸­çš„æ‰€æœ‰å›¾ç‰‡é¡¹
     */
    void clearLayout();

private:
    QScrollArea* m_scrollArea; ///< æ»šåŠ¨åŒºåŸŸç»„ä»¶
    QWidget* m_scrollContent; ///< æ»šåŠ¨åŒºåŸŸé‡Œçš„å®ä½“å®¹å™¨
    QVBoxLayout* m_scrollLayout; ///< å‚ç›´å¸ƒå±€ï¼ˆå•åˆ—ï¼‰
};


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\HistoryGallery.h ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\ImageViewer.cpp ---

/**
 * @file ImageViewer.cpp
 * @brief å›¾ç‰‡æŸ¥çœ‹å™¨ç»„ä»¶å®ç°æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®ç°äº†ImageViewerç±»ï¼Œæä¾›å›¾ç‰‡æŸ¥çœ‹åŠŸèƒ½ï¼Œæ”¯æŒè‡ªé€‚åº”æ˜¾ç¤ºã€ç¼©æ”¾å’ŒåŒå‡»è¿˜åŸã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#include "ImageViewer.h"
#include <QVBoxLayout>
#include <QResizeEvent>
#include <QScreen>
#include <QApplication>
#include <QTimer>

ImageViewer::ImageViewer(const QPixmap& pixmap, QWidget* parent) : QDialog(parent) {
    this->setWindowTitle("æŸ¥çœ‹å›¾ç‰‡ (æ»šè½®ç¼©æ”¾/å·¦é”®æ‹–æ‹½/åŒå‡»è¿˜åŸ)");
    this->setWindowFlags(Qt::Window | Qt::WindowMinMaxButtonsHint | Qt::WindowCloseButtonHint);

    QScreen *screen = QGuiApplication::primaryScreen();
    QSize screenSize = screen->availableGeometry().size();
    this->resize(screenSize * 0.7);

    QVBoxLayout* layout = new QVBoxLayout(this);
    layout->setContentsMargins(0, 0, 0, 0);

    m_scene = new QGraphicsScene(this);
    m_view = new QGraphicsView(m_scene, this);

    m_view->setRenderHints(QPainter::Antialiasing | QPainter::SmoothPixmapTransform);
    m_view->setDragMode(QGraphicsView::ScrollHandDrag);
    m_view->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_view->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    m_view->setStyleSheet("background-color: #1e1e1e; border: none;");
    m_view->setTransformationAnchor(QGraphicsView::AnchorUnderMouse);
    m_view->setResizeAnchor(QGraphicsView::AnchorUnderMouse);

    m_view->viewport()->installEventFilter(this);

    m_item = new QGraphicsPixmapItem(pixmap);
    m_scene->addItem(m_item);

    layout->addWidget(m_view);

    QTimer::singleShot(0, this, [=](){
        fitImageToWindow();
    });
}

void ImageViewer::fitImageToWindow() {
    if (!m_item || !m_view) return;

    m_view->fitInView(m_item, Qt::KeepAspectRatio);

    m_isFitWindow = true;
}

void ImageViewer::resizeEvent(QResizeEvent *event) {
    QDialog::resizeEvent(event);

    if (m_isFitWindow) {
        fitImageToWindow();
    }
}

void ImageViewer::mouseDoubleClickEvent(QMouseEvent *event) {
    Q_UNUSED(event);
    fitImageToWindow();
}

/**
 * @brief äº‹ä»¶è¿‡æ»¤å™¨
 * @param watched ç›‘å¬çš„å¯¹è±¡
 * @param event äº‹ä»¶å¯¹è±¡
 * @return bool æ˜¯å¦å¤„ç†äº†è¯¥äº‹ä»¶
 *
 * å¤„ç†é¼ æ ‡æ»šè½®äº‹ä»¶ï¼Œå®ç°å›¾ç‰‡ç¼©æ”¾åŠŸèƒ½ã€‚
 * å‘ä¸Šæ»šåŠ¨æ”¾å¤§ï¼Œå‘ä¸‹æ»šåŠ¨ç¼©å°ã€‚
 */
bool ImageViewer::eventFilter(QObject *watched, QEvent *event) {
    if (watched == m_view->viewport() && event->type() == QEvent::Wheel) {
        QWheelEvent* wheelEvent = static_cast<QWheelEvent*>(event);

        m_isFitWindow = false;

        double angle = wheelEvent->angleDelta().y();
        double factor;
        if (angle > 0) {
            factor = 1.15;
        } else {
            factor = 1.0 / 1.15;
        }

        m_view->scale(factor, factor);

        return true;
    }
    return QDialog::eventFilter(watched, event);
}


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\ImageViewer.cpp ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\ImageViewer.h ---

/**
 * @file ImageViewer.h
 * @brief å›¾ç‰‡æŸ¥çœ‹å™¨ç»„ä»¶å¤´æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†ImageViewerç±»ï¼Œæä¾›å›¾ç‰‡æŸ¥çœ‹åŠŸèƒ½ï¼Œæ”¯æŒè‡ªé€‚åº”æ˜¾ç¤ºã€ç¼©æ”¾å’ŒåŒå‡»è¿˜åŸã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#pragma once
#include <QDialog>
#include <QGraphicsView>
#include <QGraphicsScene>
#include <QGraphicsPixmapItem>

/**
 * @brief å›¾ç‰‡æŸ¥çœ‹å™¨ç±»
 * 
 * ç»§æ‰¿è‡ªQDialogï¼Œæä¾›å›¾ç‰‡æŸ¥çœ‹åŠŸèƒ½ï¼Œæ”¯æŒè‡ªé€‚åº”æ˜¾ç¤ºã€é¼ æ ‡æ»šè½®ç¼©æ”¾å’ŒåŒå‡»è¿˜åŸæ“ä½œã€‚
 */
class ImageViewer : public QDialog {
    Q_OBJECT
public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param pixmap è¦æ˜¾ç¤ºçš„å›¾ç‰‡
     * @param parent çˆ¶çª—å£æŒ‡é’ˆ
     */
    explicit ImageViewer(const QPixmap& pixmap, QWidget* parent = nullptr);

protected:
    /**
     * @brief çª—å£å¤§å°å˜åŒ–äº‹ä»¶å¤„ç†
     * @param event å¤§å°å˜åŒ–äº‹ä»¶
     * 
     * å®ç°å›¾ç‰‡è‡ªé€‚åº”çª—å£å¤§å°åŠŸèƒ½ã€‚
     */
    void resizeEvent(QResizeEvent *event) override;
    
    /**
     * @brief äº‹ä»¶è¿‡æ»¤å™¨å¤„ç†
     * @param watched è¢«ç›‘è§†çš„å¯¹è±¡
     * @param event äº‹ä»¶
     * @return bool æ˜¯å¦å¤„ç†äº‹ä»¶
     * 
     * ç›‘å¬é¼ æ ‡æ»šè½®äº‹ä»¶ï¼Œå®ç°å›¾ç‰‡ç¼©æ”¾åŠŸèƒ½ã€‚
     */
    bool eventFilter(QObject *watched, QEvent *event) override;
    
    /**
     * @brief é¼ æ ‡åŒå‡»äº‹ä»¶å¤„ç†
     * @param event é¼ æ ‡äº‹ä»¶
     * 
     * ç›‘å¬åŒå‡»äº‹ä»¶ï¼Œå®ç°å›¾ç‰‡è¿˜åŸåˆ°è‡ªé€‚åº”æ¨¡å¼ã€‚
     */
    void mouseDoubleClickEvent(QMouseEvent *event) override;

private:
    /**
     * @brief å›¾ç‰‡è‡ªé€‚åº”çª—å£åŠŸèƒ½
     * 
     * æ ¸å¿ƒåŠŸèƒ½ï¼šå°†å›¾ç‰‡é€‚é…åˆ°å½“å‰çª—å£å¤§å°ã€‚
     */
    void fitImageToWindow();

private:
    QGraphicsView* m_view;          ///< å›¾å½¢è§†å›¾çª—å£
    QGraphicsScene* m_scene;        ///< å›¾å½¢åœºæ™¯å®¹å™¨
    QGraphicsPixmapItem* m_item;    ///< å›¾ç‰‡å›¾å…ƒå¯¹è±¡

    /**
     * @brief è‡ªé€‚åº”çª—å£æ¨¡å¼æ ‡è®°
     * 
     * true: çª—å£å˜å¤§ï¼Œå›¾ç‰‡è·Ÿç€å˜å¤§ï¼ˆè‡ªé€‚åº”æ¨¡å¼ï¼‰
     * false: ç”¨æˆ·å·²æ‰‹åŠ¨ç¼©æ”¾ï¼Œçª—å£å˜å¤§ä¸å†å½±å“å›¾ç‰‡æ¯”ä¾‹
     */
    bool m_isFitWindow = true;
};


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\ImageViewer.h ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\InputPanel.cpp ---

/**
 * @file InputPanel.cpp
 * @brief è¾“å…¥é¢æ¿ç»„ä»¶å®ç°æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®ç°äº†InputPanelç±»ï¼Œæä¾›æç¤ºè¯è¾“å…¥ã€å‚è€ƒå›¾ä¸Šä¼ ã€ç”»å¹…æ¯”ä¾‹é€‰æ‹©å’Œå·¥ä½œæµé€‰æ‹©ç­‰åŠŸèƒ½ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#include "InputPanel.h"
#include <QHBoxLayout>
#include <QLabel>
#include <QActionGroup>
#include <QScrollBar>
#include <QKeyEvent>

InputPanel::InputPanel(QWidget *parent) : QWidget(parent) {
    m_currentResolution = QSize(1024, 1024);

    this->setStyleSheet("InputPanel { background-color: #343541; border-top: 1px solid #5D5D67; }");

    this->setSizePolicy(QSizePolicy::Preferred, QSizePolicy::Minimum);

    QHBoxLayout* layout = new QHBoxLayout(this);
    layout->setAlignment(Qt::AlignBottom);
    layout->setContentsMargins(20, 20, 20, 20);
    layout->setSpacing(15);

    m_btnRef = new QToolButton(this);
    m_btnRef->setText("ğŸ“");
    m_btnRef->setFixedSize(40, 40);
    m_btnRef->setStyleSheet(
        "QToolButton { background-color: transparent; border: 1px solid #555; border-radius: 20px; color: white; font-size: 20px; }"
        "QToolButton:hover { background-color: #444; }"
        "QToolButton:disabled { color: #555; border-color: #333; }"
        );
    layout->addWidget(m_btnRef);

    m_btnInterrogate = new QToolButton(this);
    m_btnInterrogate->setText("ğŸª„");
    m_btnInterrogate->setFixedSize(40, 40);
    m_btnInterrogate->setToolTip("ä¸Šä¼ å›¾ç‰‡åæ¨æç¤ºè¯");
    m_btnInterrogate->setStyleSheet(
        "QToolButton { background-color: transparent; border: 1px solid #555; border-radius: 20px; color: white; font-size: 20px; }"
        "QToolButton:hover { background-color: #444; }"
        );
    layout->addWidget(m_btnInterrogate);

    m_btnRatio = new QToolButton(this);
    m_btnRatio->setText("1:1");
    m_btnRatio->setFixedSize(60, 40);
    m_btnRatio->setPopupMode(QToolButton::InstantPopup);
    m_btnRatio->setStyleSheet(
        "QToolButton { background-color: transparent; border: 1px solid #555; border-radius: 4px; color: white; font-weight: bold; }"
        "QToolButton:hover { background-color: #444; }"
        "QToolButton::menu-indicator { image: none; }"
        );

    setupRatioMenu();
    layout->addWidget(m_btnRatio);

    m_btnWorkflow = new QPushButton("ğŸ¨ é€‰æ‹©å·¥ä½œæµ", this);
    m_btnWorkflow->setFixedSize(120, 40);
    m_btnWorkflow->setStyleSheet(
        "QPushButton { background-color: #40414F; color: white; border-radius: 4px; }"
        "QPushButton:hover { background-color: #50515F; }"
    );
    layout->addWidget(m_btnWorkflow);

    m_inputEdit = new QPlainTextEdit(this);
    m_inputEdit->setPlaceholderText("è¾“å…¥æç¤ºè¯... (Shift+Enter æ¢è¡Œ)");

    m_inputEdit->setStyleSheet(
        "QPlainTextEdit { "
        "   background-color: #40414F; "
        "   color: white; "
        "   border: 1px solid #555; "
        "   border-radius: 4px; "
        "   padding: 8px; "
        "   font-size: 14px; "
        "}"
        "QPlainTextEdit:focus { border-color: #19C37D; }"

        "QScrollBar:vertical { width: 8px; background: transparent; }"
        "QScrollBar::handle:vertical { background: #666; border-radius: 4px; }"
        );

    m_inputEdit->setFixedHeight(40);
    m_inputEdit->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Fixed);

    m_inputEdit->installEventFilter(this);

    connect(m_inputEdit, &QPlainTextEdit::textChanged, this, &InputPanel::adjustInputHeight);

    layout->addWidget(m_inputEdit);

    m_btnGenerate = new QPushButton("ç”Ÿæˆ", this);
    m_btnGenerate->setFixedSize(80, 40);
    m_btnGenerate->setStyleSheet(
        "QPushButton { background-color: #19C37D; color: white; border-radius: 4px; font-weight: bold; }"
        "QPushButton:hover { background-color: #1AD48A; }"
        "QPushButton:disabled { background-color: #2A2B32; color: #888; }"
        );
    layout->addWidget(m_btnGenerate);

    connect(m_btnGenerate, &QPushButton::clicked, this, &InputPanel::onGenerateClicked);
}

bool InputPanel::eventFilter(QObject *obj, QEvent *e)
{
    if (obj == m_inputEdit && e->type() == QEvent::KeyPress) {
        QKeyEvent *keyEvent = static_cast<QKeyEvent*>(e);

        if (keyEvent->key() == Qt::Key_Return || keyEvent->key() == Qt::Key_Enter) {
            if (keyEvent->modifiers() & Qt::ShiftModifier) {
                return false;
            } else {
                onGenerateClicked();
                return true;
            }
        }
    }
    return QWidget::eventFilter(obj, e);
}

void InputPanel::adjustInputHeight()
{
    QTextDocument *doc = m_inputEdit->document();
    doc->setTextWidth(m_inputEdit->viewport()->width());

    int contentHeight = doc->size().height();

    int margins = 16;
    int totalHeight = contentHeight + margins;

    int minHeight = 40;
    int maxHeight = 120;

    int finalHeight = qBound(minHeight, totalHeight, maxHeight);

    if (m_inputEdit->height() != finalHeight) {
        m_inputEdit->setFixedHeight(finalHeight);
    }

    if (totalHeight > maxHeight) {
        m_inputEdit->setVerticalScrollBarPolicy(Qt::ScrollBarAsNeeded);
    } else {
        m_inputEdit->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    }
}

void InputPanel::onGenerateClicked() {
    QString prompt = m_inputEdit->toPlainText().trimmed();
    if (!prompt.isEmpty()) {
        emit generateClicked(prompt);
        m_inputEdit->clear();
        adjustInputHeight();
    }
}

/**
 * @brief è®¾ç½®ç”»å¹…æ¯”ä¾‹èœå•
 *
 * åˆ›å»ºç”»å¹…æ¯”ä¾‹é€‰æ‹©èœå•ï¼ŒåŒ…å«1:1ã€3:4ã€4:3ã€9:16ã€16:9ç­‰å¸¸ç”¨æ¯”ä¾‹ã€‚
 */
void InputPanel::setupRatioMenu()
{
    m_ratioMenu = new QMenu(this);
    m_ratioMenu->setStyleSheet("QMenu { background-color: #2D2D2D; color: white; border: 1px solid #555; } QMenu::item:selected { background-color: #40414F; }");

    QActionGroup* group = new QActionGroup(this);

    struct Ratio { QString name; int w; int h; };
    QList<Ratio> ratios = {
        {"1:1 (æ–¹å›¾)", 1024, 1024},
        {"3:4 (ç«–å›¾)", 896, 1152},
        {"4:3 (æ¨ªå›¾)", 1152, 896},
        {"9:16 (æ‰‹æœº)", 832, 1216},
        {"16:9 (ç”µè„‘)", 1216, 832}
    };

    for (const auto& r : ratios) {
        QAction* action = m_ratioMenu->addAction(r.name);
        action->setData(QSize(r.w, r.h));
        action->setCheckable(true);
        group->addAction(action);

        if (r.name.startsWith("1:1")) {
            action->setChecked(true);
            m_currentResolution = QSize(r.w, r.h);
        }
    }

    connect(m_ratioMenu, &QMenu::triggered, this, &InputPanel::onRatioSelected);
    m_btnRatio->setMenu(m_ratioMenu);
}

/**
 * @brief ç”»å¹…æ¯”ä¾‹é€‰æ‹©æ§½å‡½æ•°
 * @param action é€‰ä¸­çš„èœå•é¡¹
 *
 * æ›´æ–°å½“å‰ç”»å¹…æ¯”ä¾‹å¹¶å‘å‡ºåˆ†è¾¨ç‡å˜åŒ–ä¿¡å·ã€‚
 */
void InputPanel::onRatioSelected(QAction* action)
{
    QSize size = action->data().toSize();
    m_currentResolution = size;

    QString text = action->text().split(" ").first();
    m_btnRatio->setText(text);

    emit resolutionChanged(size.width(), size.height());
}

/**
 * @brief æ›´æ–°é¢æ¿çŠ¶æ€
 * @param type å·¥ä½œæµç±»å‹
 *
 * æ ¹æ®å·¥ä½œæµç±»å‹å¯ç”¨æˆ–ç¦ç”¨ç›¸å…³æŒ‰é’®ã€‚
 * æ–‡ç”Ÿå›¾æ¨¡å¼ç¦ç”¨å‚è€ƒå›¾å’Œåæ¨æŒ‰é’®ï¼Œå›¾ç”Ÿå›¾æ¨¡å¼ç¦ç”¨ç”»å¹…æ¯”ä¾‹é€‰æ‹©ã€‚
 */
void InputPanel::updateState(WorkflowType type) {
    if (type == WorkflowType::TextToImage) {
        m_btnRef->setEnabled(false);

        m_btnRatio->setEnabled(true);

        if (m_btnInterrogate) m_btnInterrogate->setEnabled(false);

    } else {
        m_btnRef->setEnabled(true);

        m_btnRatio->setEnabled(false);
        m_btnRatio->setText("Auto");

        if (m_btnInterrogate) m_btnInterrogate->setEnabled(true);
    }
}

QSize InputPanel::currentResolution() const {
    return m_currentResolution;
}

void InputPanel::setLocked(bool locked)
{
    bool enabled = !locked;

    m_btnRef->setEnabled(enabled);
    m_btnInterrogate->setEnabled(enabled);
    m_btnRatio->setEnabled(enabled);
    m_btnWorkflow->setEnabled(enabled);

    m_inputEdit->setEnabled(enabled);
    if (locked) {
        m_inputEdit->setPlaceholderText("ç”Ÿæˆä¸­ï¼Œè¯·ç¨å€™...");
    } else {
        m_inputEdit->setPlaceholderText("è¾“å…¥æç¤ºè¯... (Shift+Enter æ¢è¡Œ)");
    }

    m_btnGenerate->setEnabled(enabled);
}

/**
 * @brief è®¾ç½®è¿æ¥çŠ¶æ€
 * @param isConnected æ˜¯å¦å·²è¿æ¥
 *
 * æ ¹æ®æœåŠ¡å™¨è¿æ¥çŠ¶æ€æ›´æ–°UIæ˜¾ç¤ºï¼Œæœªè¿æ¥æ—¶ç¦ç”¨ç”ŸæˆåŠŸèƒ½å¹¶æ˜¾ç¤ºæç¤ºä¿¡æ¯ã€‚
 */
void InputPanel::setConnectionStatus(bool isConnected)
{
    bool enable = isConnected;

    m_btnGenerate->setEnabled(enable);
    m_btnWorkflow->setEnabled(enable);
    m_btnRef->setEnabled(enable);
    m_inputEdit->setEnabled(enable);

    if (m_btnInterrogate) m_btnInterrogate->setEnabled(enable);
    if (m_btnRatio) m_btnRatio->setEnabled(enable);

    if (isConnected) {
        m_inputEdit->setPlaceholderText("è¾“å…¥æç¤ºè¯... (Shift+Enter æ¢è¡Œ)");
        m_btnGenerate->setText("ç”Ÿæˆ");
    } else {
        m_inputEdit->setPlaceholderText("âš ï¸ æœªè¿æ¥æœåŠ¡å™¨ï¼Œè¯·ç‚¹å‡»å·¦ä¸‹è§’è®¾ç½®è¿›è¡Œè¿æ¥...");
        m_btnGenerate->setText("æœªè¿æ¥");
    }
}


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\InputPanel.cpp ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\InputPanel.h ---

/**
 * @file InputPanel.h
 * @brief è¾“å…¥é¢æ¿ç»„ä»¶å¤´æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†InputPanelç±»ï¼Œä½œä¸ºåº”ç”¨ç¨‹åºåº•éƒ¨çš„è¾“å…¥æ§åˆ¶é¢æ¿ã€‚
 * åŒ…å«å·¥ä½œæµæŒ‰é’®ã€å‚è€ƒå›¾æŒ‰é’®å’ŒçŠ¶æ€æ›´æ–°åŠŸèƒ½ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#pragma once
#include <QWidget>
#include <QPushButton>
#include <QToolButton>
#include <QLineEdit>
#include <QMenu>
#include <QPlainTextEdit>
#include "../../Model/WorkflowTypes.h"

/**
 * @brief è¾“å…¥é¢æ¿ç±»
 * 
 * ç»§æ‰¿è‡ªQWidgetï¼Œæä¾›å·¥ä½œæµé€‰æ‹©ã€å‚è€ƒå›¾ä¸Šä¼ å’Œæ–‡æœ¬è¾“å…¥åŠŸèƒ½ã€‚
 * åŒ…å«æŒ‰é’®ç»„ä»¶ã€è¾“å…¥æ¡†å’ŒçŠ¶æ€ç®¡ç†åŠŸèƒ½ã€‚
 */
class InputPanel : public QWidget
{
    Q_OBJECT

public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param parent çˆ¶çª—å£æŒ‡é’ˆ
     */
    explicit InputPanel(QWidget *parent = nullptr);

    /**
     * @brief è·å–å·¥ä½œæµæŒ‰é’®
     * @return QPushButton* å·¥ä½œæµæŒ‰é’®æŒ‡é’ˆ
     */
    QPushButton* getWorkflowBtn() const { return m_btnWorkflow; }

    /**
     * @brief è·å–å‚è€ƒå›¾æŒ‰é’®
     * @return QToolButton* å‚è€ƒå›¾æŒ‰é’®æŒ‡é’ˆ
     */
    QToolButton* getRefBtn() const { return m_btnRef; }

    /**
     * @brief è·å–ç”ŸæˆæŒ‰é’®
     * @return QPushButton* ç”ŸæˆæŒ‰é’®æŒ‡é’ˆ
     */
    QPushButton* getGenerateBtn() const { return m_btnGenerate; }

    /**
     * @brief è·å–è¾“å…¥æ¡†
     * @return QPlainTextEdit* è¾“å…¥æ¡†æŒ‡é’ˆ
     */
    QPlainTextEdit* getInputEdit() const { return m_inputEdit; }

    /**
     * @brief æ ¹æ®å·¥ä½œæµç±»å‹æ›´æ–°UIçŠ¶æ€
     * @param type å·¥ä½œæµç±»å‹
     */
    void updateState(WorkflowType type);

    /**
     * @brief è·å–å½“å‰é€‰æ‹©çš„åˆ†è¾¨ç‡
     * @return QSize å½“å‰åˆ†è¾¨ç‡
     */
    QSize currentResolution() const;

    /**
     * @brief è·å–åæ¨æŒ‰é’®
     * @return QToolButton* åæ¨æŒ‰é’®æŒ‡é’ˆ
     */
    QToolButton* getInterrogateBtn() const { return m_btnInterrogate; }

    /**
     * @brief é”å®š/è§£é”é¢æ¿æ‰€æœ‰æ§ä»¶
     * @param locked æ˜¯å¦é”å®š
     */
    void setLocked(bool locked);

    /**
     * @brief è®¾ç½®è¿æ¥çŠ¶æ€
     * @param isConnected æ˜¯å¦å·²è¿æ¥
     * 
     * ä¸“é—¨ç”¨äºç½‘ç»œæ–­å¼€æ—¶çš„é”å®š
     */
    void setConnectionStatus(bool isConnected);

signals:
    /**
     * @brief ç”ŸæˆæŒ‰é’®ç‚¹å‡»ä¿¡å·
     * @param prompt è¾“å…¥çš„æç¤ºè¯æ–‡æœ¬
     */
    void generateClicked(const QString& prompt);

    /**
     * @brief åˆ†è¾¨ç‡æ”¹å˜ä¿¡å·
     * @param w å®½åº¦
     * @param h é«˜åº¦
     */
    void resolutionChanged(int w, int h);

protected:
    /**
     * @brief é‡å†™äº‹ä»¶è¿‡æ»¤å™¨ï¼Œå¤„ç†å›è½¦é”®
     * @param obj è¢«ç›‘è§†çš„å¯¹è±¡
     * @param e äº‹ä»¶å¯¹è±¡
     * @return bool æ˜¯å¦å¤„ç†äº†è¯¥äº‹ä»¶
     */
    bool eventFilter(QObject *obj, QEvent *e) override;

private slots:
    /**
     * @brief å¤„ç†ç”ŸæˆæŒ‰é’®ç‚¹å‡»
     */
    void onGenerateClicked();

    /**
     * @brief å¤„ç†æ¯”ä¾‹é€‰æ‹©
     * @param action è¢«é€‰ä¸­çš„åŠ¨ä½œ
     */
    void onRatioSelected(QAction* action);

    /**
     * @brief æ–‡æœ¬å˜åŒ–æ—¶è°ƒæ•´é«˜åº¦
     */
    void adjustInputHeight();

private:
    /**
     * @brief åˆå§‹åŒ–èœå•
     */
    void setupRatioMenu();

private:
    QPushButton* m_btnWorkflow; ///< å·¥ä½œæµæŒ‰é’®
    QToolButton* m_btnRef; ///< å‚è€ƒå›¾æŒ‰é’®
    QToolButton* m_btnRatio; ///< æ¯”ä¾‹æŒ‰é’®
    QMenu* m_ratioMenu; ///< æ¯”ä¾‹èœå•
    QSize m_currentResolution; ///< å½“å‰é€‰ä¸­çš„åˆ†è¾¨ç‡
    QPlainTextEdit* m_inputEdit; ///< è¾“å…¥æ¡†
    QPushButton* m_btnGenerate; ///< ç”ŸæˆæŒ‰é’®
    QToolButton* m_btnInterrogate; ///< åæ¨æŒ‰é’®
};


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\InputPanel.h ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\ReferencePopup.cpp ---

/**
 * @file ReferencePopup.cpp
 * @brief å‚è€ƒå›¾å¼¹çª—ç»„ä»¶å®ç°æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®ç°äº†ReferencePopupç±»ï¼Œæä¾›å‚è€ƒå›¾ä¸Šä¼ å’Œé¢„è§ˆåŠŸèƒ½ï¼Œæ”¯æŒæ‹–æ‹½å’Œæ–‡ä»¶é€‰æ‹©ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#include "ReferencePopup.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QLabel>
#include <QPushButton>
#include <QDragEnterEvent>
#include <QMimeData>
#include <QFileDialog>
#include <QStackedLayout>
#include <QPainter>
#include <QPainterPath>
#include <QStandardPaths>
#include <QFileInfo>

/**
 * @brief æ„é€ å‡½æ•°
 * @param parent çˆ¶çª—å£æŒ‡é’ˆ
 *
 * åˆå§‹åŒ–å‚è€ƒå›¾å¼¹çª—ï¼Œè®¾ç½®çª—å£å±æ€§ä¸ºæ— è¾¹æ¡†ã€é€æ˜èƒŒæ™¯ã€ç½®é¡¶æ˜¾ç¤ºã€‚
 */
ReferencePopup::ReferencePopup(QWidget *parent) : QWidget(parent) {
    this->setAcceptDrops(true);

    this->setWindowFlags(Qt::Tool | Qt::FramelessWindowHint | Qt::WindowStaysOnTopHint);
    this->setAttribute(Qt::WA_TranslucentBackground);
    
    this->setFocusPolicy(Qt::StrongFocus);

    this->setFixedSize(320, 240);

    m_currentImage = QPixmap();
    m_currentPath.clear();

    setupUi();
}

void ReferencePopup::setupUi() {
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);

    QWidget* container = new QWidget(this);
    container->setStyleSheet(
        "QWidget { background-color: #2D2D2D; border: 1px solid #444; border-radius: 8px; }"
        );

    QVBoxLayout* containerLayout = new QVBoxLayout(container);
    containerLayout->setContentsMargins(15, 15, 15, 15);

    QLabel* title = new QLabel("å‚è€ƒå›¾ (Reference)", container);
    title->setStyleSheet("color: #ECECF1; font-weight: bold; border: none;");
    containerLayout->addWidget(title);

    m_stackLayout = new QStackedLayout();

    m_pageEmpty = new QWidget(container);
    m_pageEmpty->setStyleSheet("background: transparent; border: none;");
    QVBoxLayout* emptyLayout = new QVBoxLayout(m_pageEmpty);
    emptyLayout->setContentsMargins(0, 10, 0, 0);

    QLabel* lblDropZone = new QLabel("æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„\n\næˆ–", m_pageEmpty);
    lblDropZone->setAlignment(Qt::AlignCenter);
    lblDropZone->setStyleSheet(
        "QLabel { "
        "  border: 2px dashed #555; "
        "  border-radius: 6px; "
        "  color: #888; "
        "  background-color: #343541; "
        "}"
        );

    QPushButton* btnUpload = new QPushButton("é€‰æ‹©æœ¬åœ°æ–‡ä»¶", m_pageEmpty);
    btnUpload->setCursor(Qt::PointingHandCursor);
    btnUpload->setFixedHeight(36);
    btnUpload->setStyleSheet(
        "QPushButton { background-color: #40414F; color: white; border-radius: 4px; border: none; }"
        "QPushButton:hover { background-color: #50515F; }"
        );
    connect(btnUpload, &QPushButton::clicked, this, [=](){
        QString path = QFileDialog::getOpenFileName(this, "é€‰æ‹©å‚è€ƒå›¾",
                                                    QStandardPaths::writableLocation(QStandardPaths::PicturesLocation),
                                                    "Images (*.png *.jpg *.jpeg *.bmp)");
        if (!path.isEmpty()) {
            loadImage(path);
        }
    });

    emptyLayout->addWidget(lblDropZone);
    emptyLayout->addWidget(btnUpload);

    m_pagePreview = new QWidget(container);
    m_pagePreview->setStyleSheet("background: transparent; border: none;");
    QVBoxLayout* previewLayout = new QVBoxLayout(m_pagePreview);
    previewLayout->setContentsMargins(0, 10, 0, 0);

    m_lblPreview = new QLabel(m_pagePreview);
    m_lblPreview->setAlignment(Qt::AlignCenter);
    m_lblPreview->setStyleSheet("border: 1px solid #444; border-radius: 4px; background-color: #000;");
    m_lblPreview->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);

    QPushButton* btnRemove = new QPushButton("ğŸ—‘ ç§»é™¤å‚è€ƒå›¾", m_pagePreview);
    btnRemove->setCursor(Qt::PointingHandCursor);
    btnRemove->setFixedHeight(36);
    btnRemove->setStyleSheet(
        "QPushButton { background-color: #7f1d1d; color: #fecaca; border-radius: 4px; border: none; }"
        "QPushButton:hover { background-color: #991b1b; }"
        );
    connect(btnRemove, &QPushButton::clicked, this, [=](){
        m_currentImage = QPixmap();
        m_currentPath.clear();
        updateUiState();
    });

    previewLayout->addWidget(m_lblPreview);
    previewLayout->addWidget(btnRemove);

    m_stackLayout->addWidget(m_pageEmpty);
    m_stackLayout->addWidget(m_pagePreview);

    containerLayout->addLayout(m_stackLayout);
    mainLayout->addWidget(container);

    updateUiState();
}

void ReferencePopup::popup(const QPoint& pos) {
    int x = pos.x() - (this->width() / 2);
    int y = pos.y() - this->height() - 10;
    this->move(x, y);
    this->show();
    this->raise();
    this->setFocus();
}

void ReferencePopup::hide() {
    QWidget::hide();
    this->clearFocus();
}

void ReferencePopup::dragEnterEvent(QDragEnterEvent *event) {
    if (event->mimeData()->hasUrls()) {
        QList<QUrl> urls = event->mimeData()->urls();
        if (urls.isEmpty()) return;

        QString filePath = urls.first().toLocalFile();
        QFileInfo info(filePath);
        QString suffix = info.suffix().toLower();

        if (suffix == "jpg" || suffix == "jpeg" || suffix == "png" || suffix == "bmp" || suffix == "webp") {
            event->acceptProposedAction();
        }
    }
}

void ReferencePopup::dropEvent(QDropEvent *event) {
    const QMimeData* mime = event->mimeData();
    if (mime->hasUrls()) {
        QString filePath = mime->urls().first().toLocalFile();
        loadImage(filePath);
        event->acceptProposedAction();
    }
}

void ReferencePopup::loadImage(const QString& path) {
    QPixmap img(path);
    if (img.isNull()) return;

    m_currentPath = path;
    m_currentImage = img;

    QSize targetSize = m_lblPreview->size();
    if (targetSize.isEmpty()) targetSize = QSize(280, 150);

    QPixmap scaled = img.scaled(targetSize, Qt::KeepAspectRatio, Qt::SmoothTransformation);
    m_lblPreview->setPixmap(scaled);

    updateUiState();
}

/**
 * @brief æ›´æ–°UIçŠ¶æ€
 *
 * æ ¹æ®å½“å‰æ˜¯å¦æœ‰å›¾ç‰‡ï¼Œåˆ‡æ¢æ˜¾ç¤ºç©ºçŠ¶æ€é¡µé¢æˆ–é¢„è§ˆé¡µé¢ã€‚
 */
void ReferencePopup::updateUiState() {
    if (m_currentImage.isNull()) {
        m_stackLayout->setCurrentWidget(m_pageEmpty);
    } else {
        m_stackLayout->setCurrentWidget(m_pagePreview);

        if (!m_currentImage.isNull()) {
            QSize s = QSize(280, 150);
            m_lblPreview->setPixmap(m_currentImage.scaled(s, Qt::KeepAspectRatio, Qt::SmoothTransformation));
        }
    }
}


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\ReferencePopup.cpp ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\ReferencePopup.h ---

/**
 * @file ReferencePopup.h
 * @brief å‚è€ƒå›¾ä¸Šä¼ å¼¹çª—ç»„ä»¶å¤´æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†ReferencePopupç±»ï¼Œä½œä¸ºå‚è€ƒå›¾ä¸Šä¼ çš„æµ®åŠ¨çª—å£ã€‚
 * æ”¯æŒæ‹–æ‹½ä¸Šä¼ å›¾ç‰‡ã€å›¾ç‰‡é¢„è§ˆå’ŒçŠ¶æ€ç®¡ç†åŠŸèƒ½ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#pragma once
#include <QWidget>
#include <QPixmap>

class QLabel;
class QStackedLayout;

/**
 * @brief å‚è€ƒå›¾ä¸Šä¼ å¼¹çª—ç±»
 * 
 * ç»§æ‰¿è‡ªQWidgetï¼Œæä¾›å‚è€ƒå›¾ä¸Šä¼ åŠŸèƒ½ï¼Œæ”¯æŒæ‹–æ‹½æ“ä½œã€‚
 * åŒ…å«å›¾ç‰‡é¢„è§ˆã€çŠ¶æ€åˆ‡æ¢å’Œæ•°æ®ç®¡ç†åŠŸèƒ½ã€‚
 */
class ReferencePopup : public QWidget {
    Q_OBJECT

public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param parent çˆ¶çª—å£æŒ‡é’ˆ
     */
    explicit ReferencePopup(QWidget *parent = nullptr);

    /**
     * @brief æ˜¾ç¤ºå¼¹çª—
     * @param pos å¼¹çª—æ˜¾ç¤ºä½ç½®
     */
    void popup(const QPoint& pos);
    
    /**
     * @brief éšè—å¼¹çª—
     */
    void hide();

    /**
     * @brief è·å–å½“å‰å›¾ç‰‡
     * @return QPixmap å½“å‰å›¾ç‰‡
     */
    QPixmap currentImage() const { return m_currentImage; }
    
    /**
     * @brief è·å–å›¾ç‰‡è·¯å¾„
     * @return QString å›¾ç‰‡æ–‡ä»¶è·¯å¾„
     */
    QString currentPath() const { return m_currentPath; }
    
    /**
     * @brief æ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡
     * @return bool æ˜¯å¦æœ‰å›¾ç‰‡
     */
    bool hasImage() const { return !m_currentImage.isNull(); }

protected:
    /**
     * @brief æ‹–æ‹½è¿›å…¥äº‹ä»¶å¤„ç†
     * @param event æ‹–æ‹½è¿›å…¥äº‹ä»¶
     */
    void dragEnterEvent(QDragEnterEvent *event) override;
    
    /**
     * @brief æ‹–æ‹½é‡Šæ”¾äº‹ä»¶å¤„ç†
     * @param event æ‹–æ‹½é‡Šæ”¾äº‹ä»¶
     */
    void dropEvent(QDropEvent *event) override;

private:
    /**
     * @brief åˆå§‹åŒ–UIå¸ƒå±€
     */
    void setupUi();
    
    /**
     * @brief åŠ è½½å›¾ç‰‡å¤„ç†é€»è¾‘
     * @param path å›¾ç‰‡æ–‡ä»¶è·¯å¾„
     */
    void loadImage(const QString& path);
    
    /**
     * @brief åˆ‡æ¢UIçŠ¶æ€
     */
    void updateUiState();

private:
    // æ•°æ®
    QPixmap m_currentImage; ///< å½“å‰å›¾ç‰‡æ•°æ®
    QString m_currentPath; ///< å½“å‰å›¾ç‰‡è·¯å¾„

    // UI ç»„ä»¶
    QStackedLayout* m_stackLayout; ///< å †å å¸ƒå±€ï¼Œç”¨äºç•Œé¢åˆ‡æ¢
    QWidget* m_pageEmpty; ///< ç©ºçŠ¶æ€é¡µé¢
    QWidget* m_pagePreview; ///< é¢„è§ˆçŠ¶æ€é¡µé¢

    QLabel* m_lblPreview; ///< å›¾ç‰‡é¢„è§ˆæ ‡ç­¾
};


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\ReferencePopup.h ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\SessionItem.cpp ---

/**
 * @file SessionItem.cpp
 * @brief ä¼šè¯é¡¹ç»„ä»¶å®ç°æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®ç°äº†SessionItemç±»ï¼Œæä¾›ä¼šè¯åˆ—è¡¨é¡¹çš„UIæ˜¾ç¤ºå’Œäº¤äº’åŠŸèƒ½ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#include "SessionItem.h"
#include <QApplication>
#include <QClipboard>
#include <QInputDialog>
#include <QMessageBox>
#include <QFontMetrics>
#include <QResizeEvent>

/**
 * @brief æ„é€ å‡½æ•°
 * @param id ä¼šè¯ID
 * @param title ä¼šè¯æ ‡é¢˜
 * @param parent çˆ¶çª—å£æŒ‡é’ˆ
 */
SessionItem::SessionItem(int id, const QString& title, QWidget *parent)
    : QWidget(parent), m_id(id), m_fullTitle(title)
{
    this->setAttribute(Qt::WA_StyledBackground, true);
    this->setFixedHeight(50);
    this->setStyleSheet("SessionItem { background-color: transparent; border-radius: 6px; border: none; }");
    setupUi();
}

/**
 * @brief åˆå§‹åŒ–UIå¸ƒå±€
 */
void SessionItem::setupUi()
{
    QHBoxLayout* layout = new QHBoxLayout(this);
    layout->setContentsMargins(10, 0, 5, 0);
    layout->setSpacing(0);

    m_lblTitle = new QLabel(this);
    m_lblTitle->setStyleSheet("color: #ECECF1; font-size: 13px; background: transparent;border: none;");
    m_lblTitle->setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Preferred);
    m_lblTitle->setAttribute(Qt::WA_TransparentForMouseEvents, true);

    m_btnOption = new QToolButton(this);
    m_btnOption->setText("Â·Â·Â·");
    m_btnOption->setFixedSize(30, 30);
    m_btnOption->setCursor(Qt::PointingHandCursor);

    m_btnOption->setStyleSheet(
        "QToolButton { "
        "    border: none; "
        "    background: transparent; "
        "    color: transparent; "
        "}"
        );

    connect(m_btnOption, &QToolButton::clicked, this, &SessionItem::showMenu);

    layout->addWidget(m_lblTitle);
    layout->addWidget(m_btnOption);

    updateTitleText();
}

/**
 * @brief é¼ æ ‡è¿›å…¥äº‹ä»¶å¤„ç†
 * @param event é¼ æ ‡è¿›å…¥äº‹ä»¶
 */
void SessionItem::enterEvent(QEnterEvent *event)
{
    if (!m_isSelected) {
        this->setStyleSheet("SessionItem { background-color: #2A2B32; border-radius: 6px; }");
    }

    m_btnOption->setStyleSheet(
        "QToolButton { "
        "    color: #ECECF1; "
        "    background-color: #40414F; "
        "    border-radius: 4px; "
        "    border: none; "
        "    font-weight: bold; "
        "}"
        "QToolButton:hover { color: white; background-color: #50515F; }"
        );

    QWidget::enterEvent(event);
}

/**
 * @brief é¼ æ ‡ç¦»å¼€äº‹ä»¶å¤„ç†
 * @param event é¼ æ ‡ç¦»å¼€äº‹ä»¶
 */
void SessionItem::leaveEvent(QEvent *event)
{
    if (!m_isSelected) {
        this->setStyleSheet("SessionItem { background-color: transparent; border-radius: 6px; border: none; }");
    }

    m_btnOption->setStyleSheet(
        "QToolButton { "
        "    border: none; "
        "    background: transparent; "
        "    color: transparent; "
        "}"
        );

    QWidget::leaveEvent(event);
}

/**
 * @brief é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶å¤„ç†
 * @param event é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
 */
void SessionItem::mousePressEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton) {
        emit itemClicked(this);
    }
    QWidget::mousePressEvent(event);
}

/**
 * @brief è®¾ç½®é€‰ä¸­çŠ¶æ€
 * @param selected æ˜¯å¦é€‰ä¸­
 */
void SessionItem::setSelected(bool selected)
{
    m_isSelected = selected;
    if (selected) {
        this->setStyleSheet("SessionItem { background-color: #343541; border-radius: 6px; border: 1px solid #565869; }");
    } else {
        this->setStyleSheet("SessionItem { background-color: transparent; border-radius: 6px; border: none; }");
    }
}

/**
 * @brief æ›´æ–°æ ‡é¢˜
 * @param newTitle æ–°æ ‡é¢˜
 */
void SessionItem::setTitle(const QString& newTitle)
{
    m_fullTitle = newTitle;
    updateTitleText();
}

/**
 * @brief çª—å£å¤§å°æ”¹å˜äº‹ä»¶å¤„ç†
 * @param event å¤§å°æ”¹å˜äº‹ä»¶
 */
void SessionItem::resizeEvent(QResizeEvent *event)
{
    updateTitleText();
    QWidget::resizeEvent(event);
}

/**
 * @brief æ›´æ–°æ ‡é¢˜æ–‡æœ¬æ˜¾ç¤º
 */
void SessionItem::updateTitleText()
{
    int availableWidth = this->width() - m_btnOption->width() - 20;
    if (availableWidth <= 0) return;

    QFontMetrics metrics(m_lblTitle->font());
    QString elidedText = metrics.elidedText(m_fullTitle, Qt::ElideRight, availableWidth);
    m_lblTitle->setText(elidedText);

    if (elidedText != m_fullTitle) {
        this->setToolTip(m_fullTitle);
    } else {
        this->setToolTip("");
    }
}

/**
 * @brief æ˜¾ç¤ºå³é”®èœå•
 */
void SessionItem::showMenu()
{
    QMenu menu(this);
    menu.setStyleSheet("QMenu { background-color: #2D2D2D; color: white; border: 1px solid #555; border-radius: 8px }"
                       "QMenu::item:selected { background-color: #40414F; }");

    QAction* actRename = menu.addAction("âœ é‡å‘½å");
    connect(actRename, &QAction::triggered, this, [=](){
        bool ok;
        QString text = QInputDialog::getText(this, "é‡å‘½åä¼šè¯",
                                             "è¯·è¾“å…¥æ–°åç§°:", QLineEdit::Normal,
                                             m_fullTitle, &ok);
        if (ok && !text.isEmpty()) {
            setTitle(text);
            emit itemRenamed(m_id, text);
        }
    });

    QAction* actCopy = menu.addAction("â å¤åˆ¶æ ‡é¢˜");
    connect(actCopy, &QAction::triggered, this, [=](){
        QClipboard *clipboard = QApplication::clipboard();
        clipboard->setText(m_fullTitle);
    });

    menu.addSeparator();

    QAction* actDelete = menu.addAction("ğŸ—‘ åˆ é™¤ä¼šè¯");
    connect(actDelete, &QAction::triggered, this, [=](){
        QMessageBox::StandardButton reply;
        reply = QMessageBox::question(this, "ç¡®è®¤åˆ é™¤", "ç¡®å®šè¦åˆ é™¤è¿™ä¸ªä¼šè¯å—ï¼Ÿ\næ­¤æ“ä½œæ— æ³•æ’¤é”€ã€‚",
                                      QMessageBox::Yes|QMessageBox::No);
        if (reply == QMessageBox::Yes) {
            emit itemDeleted(m_id);
        }
    });

    menu.exec(m_btnOption->mapToGlobal(QPoint(0, m_btnOption->height())));
}


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\SessionItem.cpp ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\SessionItem.h ---

/**
 * @file SessionItem.h
 * @brief ä¼šè¯é¡¹ç»„ä»¶å¤´æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†SessionItemç±»ï¼Œä½œä¸ºä¼šè¯åˆ—è¡¨ä¸­çš„å•ä¸ªä¼šè¯é¡¹ã€‚
 * åŒ…å«ä¼šè¯æ ‡é¢˜æ˜¾ç¤ºã€é€‰ä¸­çŠ¶æ€ã€å³é”®èœå•å’Œäº‹ä»¶å¤„ç†åŠŸèƒ½ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#pragma once

#include <QWidget>
#include <QLabel>
#include <QToolButton>
#include <QHBoxLayout>
#include <QMenu>

class QLabel;
class QToolButton;

/**
 * @brief ä¼šè¯é¡¹ç±»
 * 
 * ç»§æ‰¿è‡ªQWidgetï¼Œè¡¨ç¤ºä¼šè¯åˆ—è¡¨ä¸­çš„å•ä¸ªä¼šè¯é¡¹ç›®ã€‚
 * æ”¯æŒé€‰ä¸­çŠ¶æ€ã€æ ‡é¢˜ç¼–è¾‘ã€åˆ é™¤å’Œé‡å‘½åæ“ä½œã€‚
 */
class SessionItem : public QWidget
{
    Q_OBJECT
public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param id ä¼šè¯ID
     * @param title ä¼šè¯æ ‡é¢˜
     * @param parent çˆ¶çª—å£æŒ‡é’ˆ
     */
    explicit SessionItem(int id, const QString& title, QWidget *parent = nullptr);

    /**
     * @brief è·å–ä¼šè¯ID
     * @return int ä¼šè¯ID
     */
    int id() const { return m_id; }

    /**
     * @brief è®¾ç½®é€‰ä¸­çŠ¶æ€
     * @param selected æ˜¯å¦é€‰ä¸­
     */
    void setSelected(bool selected);

    /**
     * @brief æ›´æ–°æ ‡é¢˜
     * @param newTitle æ–°æ ‡é¢˜
     */
    void setTitle(const QString& newTitle);



signals:
    /**
     * @brief é¡¹ç‚¹å‡»ä¿¡å·
     * @param item è¢«ç‚¹å‡»çš„ä¼šè¯é¡¹æŒ‡é’ˆ
     */
    void itemClicked(SessionItem* item);
    
    /**
     * @brief é¡¹åˆ é™¤ä¿¡å·
     * @param id è¢«åˆ é™¤çš„ä¼šè¯ID
     */
    void itemDeleted(int id);
    
    /**
     * @brief é¡¹é‡å‘½åä¿¡å·
     * @param id è¢«é‡å‘½åçš„ä¼šè¯ID
     * @param newName æ–°ä¼šè¯åç§°
     */
    void itemRenamed(int id, const QString& newName);

protected:
    /**
     * @brief é¼ æ ‡è¿›å…¥äº‹ä»¶å¤„ç†
     * @param event é¼ æ ‡è¿›å…¥äº‹ä»¶
     */
    void enterEvent(QEnterEvent *event) override;
    
    /**
     * @brief é¼ æ ‡ç¦»å¼€äº‹ä»¶å¤„ç†
     * @param event é¼ æ ‡ç¦»å¼€äº‹ä»¶
     */
    void leaveEvent(QEvent *event) override;
    
    /**
     * @brief é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶å¤„ç†
     * @param event é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶
     */
    void mousePressEvent(QMouseEvent *event) override;
    
    /**
     * @brief çª—å£å¤§å°æ”¹å˜äº‹ä»¶å¤„ç†
     * @param event å¤§å°æ”¹å˜äº‹ä»¶
     */
    void resizeEvent(QResizeEvent *event) override;

private:
    /**
     * @brief åˆå§‹åŒ–UIå¸ƒå±€
     */
    void setupUi();
    
    /**
     * @brief æ›´æ–°æ ‡é¢˜æ–‡æœ¬æ˜¾ç¤º
     */
    void updateTitleText();
    
    /**
     * @brief æ˜¾ç¤ºå³é”®èœå•
     */
    void showMenu();

private:
    int m_id; ///< ä¼šè¯ID
    QString m_fullTitle; ///< å®Œæ•´æ ‡é¢˜
    bool m_isSelected = false; ///< æ˜¯å¦é€‰ä¸­çŠ¶æ€

    QLabel *m_lblTitle; ///< æ ‡é¢˜æ ‡ç­¾
    QToolButton *m_btnOption; ///< é€‰é¡¹æŒ‰é’®
};


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\SessionItem.h ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\SessionList.cpp ---

/**
 * @file SessionList.cpp
 * @brief ä¼šè¯åˆ—è¡¨ç»„ä»¶å®ç°æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®ç°äº†SessionListç±»ï¼Œæä¾›ä¼šè¯åˆ—è¡¨ç®¡ç†åŠŸèƒ½ï¼ŒåŒ…æ‹¬ä¼šè¯çš„æ·»åŠ ã€é€‰æ‹©ã€é‡å‘½åå’Œåˆ é™¤ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#include "SessionList.h"
#include "SessionItem.h"
#include <QPushButton>
#include <QLabel>
#include <QScrollArea>
#include <QScrollBar>

SessionList::SessionList(QWidget *parent)
    : QWidget(parent)
    , m_currentSessionItem(nullptr)
{
    setupUi();
}

void SessionList::setupUi()
{
    this->setFixedWidth(260);
    this->setStyleSheet("background-color: #202123; border-right: 1px solid #4D4D4F;");

    QVBoxLayout* rootLayout = new QVBoxLayout(this);
    rootLayout->setContentsMargins(0, 20, 0, 0);
    rootLayout->setSpacing(10);

    QWidget* topContainer = new QWidget(this);
    QVBoxLayout* topLayout = new QVBoxLayout(topContainer);
    topLayout->setContentsMargins(10, 0, 10, 0);

    m_btnNew = new QPushButton("+ æ–°å»ºä¼šè¯", this);
    m_btnNew->setFixedHeight(45);
    m_btnNew->setCursor(Qt::PointingHandCursor);
    m_btnNew->setStyleSheet(
        "QPushButton { "
        "   background-color: transparent; "
        "   border: 1px solid #565869; "
        "   border-radius: 5px; "
        "   color: white; "
        "   text-align: left; "
        "   padding-left: 15px;"
        "}"
        "QPushButton:hover { background-color: #2A2B32; }"
        );
    connect(m_btnNew, &QPushButton::clicked, this, &SessionList::createNewSessionRequest);

    topLayout->addWidget(m_btnNew);
    rootLayout->addWidget(topContainer);

    QScrollArea* scrollArea = new QScrollArea(this);
    scrollArea->setWidgetResizable(true);
    scrollArea->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    scrollArea->setFrameShape(QFrame::NoFrame);

    scrollArea->setStyleSheet(
        "QScrollArea { "
        "   background: transparent; "
        "   border: none; "
        "}"

        "QScrollBar:vertical { "
        "    border: none; "
        "    background: #111111; "
        "    width: 14px; "
        "    margin: 0px; "
        "}"

        "QScrollBar::handle:vertical { "
        "    background: #666666; "
        "    min-height: 30px; "
        "    border-radius: 7px; "
        "    margin: 2px; "
        "}"

        "QScrollBar::handle:vertical:hover { "
        "    background: #999999; "
        "}"

        "QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { "
        "    height: 0px; "
        "}"
        "QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical { "
        "    background: none; "
        "}"
        );

    QWidget* scrollContent = new QWidget();
    scrollContent->setStyleSheet("background: transparent;");

    m_scrollLayout = new QVBoxLayout(scrollContent);
    m_scrollLayout->setContentsMargins(10, 10, 10, 10);
    m_scrollLayout->setSpacing(5);

    QLabel* labelTitle = new QLabel("æœ€è¿‘å†å²", scrollContent);
    labelTitle->setStyleSheet("color: #8E8EA0; font-size: 12px; margin-bottom: 5px; border: none;");
    m_scrollLayout->addWidget(labelTitle);

    scrollArea->setWidget(scrollContent);
    rootLayout->addWidget(scrollArea);

    m_scrollLayout->addStretch();
}

void SessionList::addSession(int id, const QString& title)
{
    SessionItem* item = new SessionItem(id, title, this);

    connect(item, &SessionItem::itemClicked, this, [=](SessionItem* clickedItem){
        handleItemSelection(clickedItem);
        emit sessionSwitchRequest(clickedItem->id());
    });

    connect(item, &SessionItem::itemRenamed, this, [=](int itemId, const QString& newName){
        emit sessionRenameRequest(itemId, newName);
    });

    connect(item, &SessionItem::itemDeleted, this, [=](int deletedId){
        if (m_currentSessionItem == item) {
            m_currentSessionItem = nullptr;
        }
        emit sessionDeleteRequest(deletedId);

        m_scrollLayout->removeWidget(item);
        item->deleteLater();
    });

    m_items.append(item);

    m_scrollLayout->insertWidget(m_scrollLayout->count() - 1, item);

    if (m_currentSessionItem == nullptr) {
        handleItemSelection(item);
    }
}

void SessionList::handleItemSelection(SessionItem* clickedItem)
{
    if (m_currentSessionItem == clickedItem) return;
    if (m_currentSessionItem) m_currentSessionItem->setSelected(false);
    if (clickedItem) clickedItem->setSelected(true);
    m_currentSessionItem = clickedItem;
}

void SessionList::clear()
{
    m_currentSessionItem = nullptr;

    for (auto* item : m_items) {
        m_scrollLayout->removeWidget(item);
        delete item;
    }
    m_items.clear();
}

void SessionList::loadSessions(const QVector<SessionData>& sessions)
{
    clear();

    for (const auto& s : sessions) {
        addSession(s.id, s.name);
    }
}

void SessionList::selectSession(int id)
{
    for (SessionItem* item : m_items) {
        if (item->id() == id) {
            handleItemSelection(item);
            return;
        }
    }
}

int SessionList::getFirstSessionId() const
{
    if (m_items.isEmpty()) return -1;
    return m_items.first()->id();
}


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\SessionList.cpp ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\SessionList.h ---

/**
 * @file SessionList.h
 * @brief ä¼šè¯åˆ—è¡¨ç»„ä»¶å¤´æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†SessionListç±»ï¼Œä½œä¸ºåº”ç”¨ç¨‹åºå·¦ä¾§çš„ä¼šè¯ç®¡ç†é¢æ¿ã€‚
 * åŒ…å«ä¼šè¯é¡¹çš„æ·»åŠ ã€é€‰æ‹©ã€åˆ é™¤ã€é‡å‘½åç­‰åŠŸèƒ½ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#pragma once

#include <QWidget>
#include <QVBoxLayout>
#include <QList>
#include <QScrollArea>
#include "../../Model/DataModels.h"

class SessionItem;
class QPushButton;

/**
 * @brief ä¼šè¯åˆ—è¡¨ç±»
 * 
 * ç»§æ‰¿è‡ªQWidgetï¼Œç®¡ç†å¤šä¸ªä¼šè¯é¡¹ï¼Œæä¾›ä¼šè¯çš„å¢åˆ æ”¹æŸ¥åŠŸèƒ½ã€‚
 * æ”¯æŒä¼šè¯åˆ‡æ¢ã€åˆ é™¤ã€é‡å‘½åå’Œæ–°å»ºæ“ä½œã€‚
 */
class SessionList : public QWidget
{
    Q_OBJECT

public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param parent çˆ¶çª—å£æŒ‡é’ˆ
     */
    explicit SessionList(QWidget *parent = nullptr);

    /**
     * @brief æ·»åŠ æ–°ä¼šè¯
     * @param id ä¼šè¯ID
     * @param title ä¼šè¯æ ‡é¢˜
     */
    void addSession(int id, const QString& title);

    /**
     * @brief æ¸…ç©ºåˆ—è¡¨
     */
    void clear();

    /**
     * @brief åŠ è½½ä¼šè¯åˆ—è¡¨æ•°æ®
     * @param sessions ä¼šè¯æ•°æ®åˆ—è¡¨
     */
    void loadSessions(const QVector<SessionData>& sessions);

    /**
     * @brief é€šè¿‡IDé€‰ä¸­æŒ‡å®šä¼šè¯
     * @param id ä¼šè¯ID
     * 
     * ç”¨äºåˆå§‹åŒ–æ—¶é«˜äº®
     */
    void selectSession(int id);

    /**
     * @brief è·å–åˆ—è¡¨é‡Œçš„ç¬¬ä¸€ä¸ªä¼šè¯ID
     * @return int ç¬¬ä¸€ä¸ªä¼šè¯IDï¼Œå¦‚æœæ²¡æœ‰åˆ™è¿”å›-1
     */
    int getFirstSessionId() const;

signals:
    /**
     * @brief ä¼šè¯åˆ‡æ¢è¯·æ±‚ä¿¡å·
     * @param id ç›®æ ‡ä¼šè¯ID
     */
    void sessionSwitchRequest(int id);

    /**
     * @brief ä¼šè¯åˆ é™¤è¯·æ±‚ä¿¡å·
     * @param id ç›®æ ‡ä¼šè¯ID
     */
    void sessionDeleteRequest(int id);

    /**
     * @brief ä¼šè¯é‡å‘½åè¯·æ±‚ä¿¡å·
     * @param id ç›®æ ‡ä¼šè¯ID
     * @param newName æ–°ä¼šè¯åç§°
     */
    void sessionRenameRequest(int id, const QString& newName);

    /**
     * @brief æ–°å»ºä¼šè¯è¯·æ±‚ä¿¡å·
     */
    void createNewSessionRequest();

private:
    /**
     * @brief åˆå§‹åŒ–UIå¸ƒå±€
     */
    void setupUi();

    /**
     * @brief å¤„ç†ä¼šè¯é¡¹é€‰æ‹©äº‹ä»¶
     * @param clickedItem è¢«ç‚¹å‡»çš„ä¼šè¯é¡¹æŒ‡é’ˆ
     */
    void handleItemSelection(SessionItem* clickedItem);

private:
    QVBoxLayout* m_mainLayout; ///< ä¸»å¸ƒå±€
    QVBoxLayout* m_scrollLayout; ///< æ»šåŠ¨åŒºåŸŸå¸ƒå±€
    QPushButton* m_btnNew; ///< æ–°å»ºä¼šè¯æŒ‰é’®
    SessionItem* m_currentSessionItem; ///< å½“å‰é€‰ä¸­çš„ä¼šè¯é¡¹æŒ‡é’ˆ
    QList<SessionItem*> m_items; ///< ç®¡ç†æ‰€æœ‰ItemæŒ‡é’ˆ
};


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\SessionList.h ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\SettingsDialog.cpp ---

/**
 * @file SettingsDialog.cpp
 * @brief æœåŠ¡å™¨è®¾ç½®å¯¹è¯æ¡†ç»„ä»¶å®ç°æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®ç°äº†SettingsDialogç±»ï¼Œæä¾›æœåŠ¡å™¨åœ°å€é…ç½®åŠŸèƒ½ï¼Œæ”¯æŒä¿å­˜å’Œè¯»å–æœåŠ¡å™¨é…ç½®ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#include "SettingsDialog.h"
#include <QVBoxLayout>
#include <QDialogButtonBox>
#include <QLabel>
#include <QSettings>

SettingsDialog::SettingsDialog(QWidget *parent) : QDialog(parent) {
    setWindowTitle("æœåŠ¡å™¨è®¾ç½®");
    setFixedSize(400, 200);

    QSettings settings("CloudArt", "AppConfig");
    QString savedUrl = settings.value("Server/Url", "http://127.0.0.1:8000").toString();

    QVBoxLayout* mainLayout = new QVBoxLayout(this);

    QLabel* lbl = new QLabel("åœ°å€:", this);
    m_editUrl = new QLineEdit(savedUrl, this);
    m_editUrl->setPlaceholderText("ä¾‹å¦‚: http://frp-fly.top:12345");

    mainLayout->addWidget(lbl);
    mainLayout->addWidget(m_editUrl);

    QLabel* tip = new QLabel("å¤åˆ¶å®Œæ•´çš„ç©¿é€é“¾æ¥å¡«å…¥", this);
    tip->setStyleSheet("color: #666; font-size: 12px; margin-top: 5px;");
    tip->setWordWrap(true);
    mainLayout->addWidget(tip);

    mainLayout->addStretch();

    QDialogButtonBox* buttons = new QDialogButtonBox(QDialogButtonBox::Ok | QDialogButtonBox::Cancel, this);
    connect(buttons, &QDialogButtonBox::accepted, this, [=](){
        QSettings settings("CloudArt", "AppConfig");
        settings.setValue("Server/Url", m_editUrl->text().trimmed());
        accept();
    });
    connect(buttons, &QDialogButtonBox::rejected, this, &QDialog::reject);
    mainLayout->addWidget(buttons);
}

QString SettingsDialog::getUrl() const {
    return m_editUrl->text().trimmed();
}


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\SettingsDialog.cpp ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\SettingsDialog.h ---

/**
 * @file SettingsDialog.h
 * @brief è®¾ç½®å¯¹è¯æ¡†ç»„ä»¶å¤´æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†SettingsDialogç±»ï¼Œç”¨äºé…ç½®åº”ç”¨ç¨‹åºçš„è¿æ¥è®¾ç½®ã€‚
 * æä¾›ComfyUIæœåŠ¡å™¨åœ°å€çš„é…ç½®ç•Œé¢ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#pragma once

#include <QDialog>
#include <QLineEdit>

/**
 * @brief è®¾ç½®å¯¹è¯æ¡†ç±»
 * 
 * ç»§æ‰¿è‡ªQDialogï¼Œæä¾›åº”ç”¨ç¨‹åºè®¾ç½®ç•Œé¢ã€‚
 * ç”¨äºé…ç½®ComfyUIæœåŠ¡å™¨çš„è¿æ¥åœ°å€ã€‚
 */
class SettingsDialog : public QDialog
{
    Q_OBJECT

public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param parent çˆ¶çª—å£æŒ‡é’ˆ
     */
    explicit SettingsDialog(QWidget *parent = nullptr);

    /**
     * @brief è·å–é…ç½®çš„URL
     * @return QString ComfyUIæœåŠ¡å™¨åœ°å€
     */
    QString getUrl() const;

private:
    QLineEdit* m_editUrl; ///< URLè¾“å…¥æ¡†
};


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\SettingsDialog.h ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\SidebarControl.cpp ---

/**
 * @file SidebarControl.cpp
 * @brief ä¾§è¾¹æ æ§åˆ¶ç»„ä»¶å®ç°æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®ç°äº†SidebarControlç±»ï¼Œæä¾›ä¾§è¾¹æ æ§åˆ¶æŒ‰é’®ï¼ŒåŒ…æ‹¬å¯¹è¯è®°å½•ã€ç”Ÿæˆè®°å½•å’ŒæœåŠ¡å™¨è®¾ç½®ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#include "SidebarControl.h"

#include <QVBoxLayout>
#include <QToolButton>
#include <QIcon>

SidebarControl::SidebarControl(QWidget* parent)
    : QWidget(parent)
    , m_layout(nullptr)
    , m_toggleBtn(nullptr)
    , m_historyBtn(nullptr)
    , m_settingsBtn(nullptr)
{
    setAttribute(Qt::WA_TranslucentBackground);
    
    m_layout = new QVBoxLayout(this);
    m_layout->setSpacing(20);
    m_layout->setContentsMargins(0, 10, 0, 10);
    
    m_toggleBtn = createBtn(":/images/HideConversation.png", "å¯¹è¯è®°å½•");
    m_historyBtn = createBtn(":/images/historypic.png", "ç”Ÿæˆè®°å½•");
    
    m_layout->addWidget(m_toggleBtn);
    m_layout->addWidget(m_historyBtn);
    
    m_layout->addStretch();

    m_settingsBtn = createBtn(":/images/setting.png", "æœåŠ¡å™¨è®¾ç½®");

    m_layout->addWidget(m_settingsBtn);

    setFixedWidth(40);
    adjustSize();
}

SidebarControl::~SidebarControl()
{
}

QToolButton* SidebarControl::toggleBtn() const
{
    return m_toggleBtn;
}

QToolButton* SidebarControl::historyBtn() const
{
    return m_historyBtn;
}

void SidebarControl::updateToggleState(bool isExpanded)
{
    if (m_toggleBtn) {
        m_toggleBtn->setToolTip(isExpanded ? "å¯¹è¯è®°å½•" : "å¯¹è¯è®°å½•");
    }
}

QToolButton* SidebarControl::createBtn(const QString& iconPath, const QString& tooltip)
{
    QToolButton* btn = new QToolButton(this);
    btn->setIcon(QIcon(iconPath));
    btn->setIconSize(QSize(24, 24));
    btn->setFixedSize(32, 32);
    btn->setCursor(Qt::PointingHandCursor);
    btn->setStyleSheet(
        "QToolButton { "
        "  background-color: #40414F; "
        "  border: none; "
        "  border-radius: 4px; "
        "}"
        "QToolButton:hover { "
        "  background-color: #50515F; "
        "}"
    );
    btn->setToolTip(tooltip);
    return btn;
}

QToolButton* SidebarControl::settingsBtn() const
{
    return m_settingsBtn;
}


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\SidebarControl.cpp ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\SidebarControl.h ---

/**
 * @file SidebarControl.h
 * @brief ä¾§è¾¹æ æ§åˆ¶ç»„ä»¶å¤´æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†SidebarControlç±»ï¼Œæä¾›ä¾§è¾¹æ çš„åˆ‡æ¢ã€å†å²è®°å½•å’Œè®¾ç½®åŠŸèƒ½ã€‚
 * åŒ…å«ä¾§è¾¹æ å±•å¼€/æ”¶èµ·ã€å†å²è®°å½•æŸ¥çœ‹å’Œè®¾ç½®æŒ‰é’®ç­‰åŠŸèƒ½ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#pragma once

#include <QWidget>
#include <QToolButton>

class QVBoxLayout;

/**
 * @brief ä¾§è¾¹æ æ§åˆ¶ç»„ä»¶ç±»
 * 
 * ç»§æ‰¿è‡ªQWidgetï¼Œæä¾›ä¾§è¾¹æ çš„æ§åˆ¶åŠŸèƒ½ã€‚
 * åŒ…å«ä¾§è¾¹æ å±•å¼€/æ”¶èµ·æŒ‰é’®ã€å†å²è®°å½•æŒ‰é’®å’Œè®¾ç½®æŒ‰é’®ã€‚
 */
class SidebarControl : public QWidget
{
    Q_OBJECT

public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param parent çˆ¶çª—å£æŒ‡é’ˆ
     */
    explicit SidebarControl(QWidget* parent = nullptr);

    /**
     * @brief ææ„å‡½æ•°
     */
    ~SidebarControl();

    /**
     * @brief è·å–åˆ‡æ¢æŒ‰é’®
     * @return QToolButton* åˆ‡æ¢æŒ‰é’®æŒ‡é’ˆ
     */
    QToolButton* toggleBtn() const;

    /**
     * @brief è·å–å†å²è®°å½•æŒ‰é’®
     * @return QToolButton* å†å²è®°å½•æŒ‰é’®æŒ‡é’ˆ
     */
    QToolButton* historyBtn() const;

    /**
     * @brief è·å–è®¾ç½®æŒ‰é’®
     * @return QToolButton* è®¾ç½®æŒ‰é’®æŒ‡é’ˆ
     */
    QToolButton* settingsBtn() const;

    /**
     * @brief æ›´æ–°åˆ‡æ¢æŒ‰é’®çŠ¶æ€
     * @param isExpanded ä¾§è¾¹æ æ˜¯å¦å±•å¼€
     */
    void updateToggleState(bool isExpanded);

private:
    /**
     * @brief åˆ›å»ºå·¥å…·æŒ‰é’®
     * @param iconPath å›¾æ ‡è·¯å¾„
     * @param tooltip å·¥å…·æç¤ºæ–‡æœ¬
     * @return QToolButton* åˆ›å»ºçš„æŒ‰é’®æŒ‡é’ˆ
     */
    QToolButton* createBtn(const QString& iconPath, const QString& tooltip);

private:
    QVBoxLayout* m_layout; ///< ä¸»å¸ƒå±€
    QToolButton* m_toggleBtn; ///< åˆ‡æ¢æŒ‰é’®
    QToolButton* m_historyBtn; ///< å†å²è®°å½•æŒ‰é’®
    QToolButton* m_settingsBtn; ///< è®¾ç½®æŒ‰é’®
};


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\SidebarControl.h ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\WorkflowCard.cpp ---

/**
 * @file WorkflowCard.cpp
 * @brief å·¥ä½œæµå¡ç‰‡ç»„ä»¶å®ç°æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®ç°äº†WorkflowCardç±»ï¼Œç”¨äºæ˜¾ç¤ºå·¥ä½œæµå¡ç‰‡ï¼Œæ”¯æŒé™æ€å›¾ç‰‡å’ŒGIFåŠ¨ç”»èƒŒæ™¯ï¼Œ
 * åŒ…å«é¼ æ ‡æ‚¬åœæ•ˆæœã€ç¼©æ”¾åŠ¨ç”»å’Œæ–‡å­—ä¿¡æ¯å±•ç¤ºåŠŸèƒ½ã€‚
 * 
 * @author ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆ
 * @version 1.0
 * @date 2024
 */

#include "WorkflowCard.h"
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QPainter>
#include <QEnterEvent>
#include <QMouseEvent>
#include <QDebug>
#include <QLinearGradient>
#include <QPixmap>
#include <QFile>
#include <QPainterPath>
#include <QMovie>

/**
 * @brief WorkflowCardæ„é€ å‡½æ•°
 * @param info å·¥ä½œæµä¿¡æ¯ç»“æ„ä½“ï¼ŒåŒ…å«åç§°ã€æè¿°ã€å›¾ç‰‡è·¯å¾„ç­‰
 * @param parent çˆ¶çª—å£æŒ‡é’ˆ
 * 
 * åˆå§‹åŒ–å·¥ä½œæµå¡ç‰‡ï¼Œè®¾ç½®UIå¸ƒå±€ã€åŠ¨ç”»æ•ˆæœå’Œäº‹ä»¶å¤„ç†ã€‚
 * æ”¯æŒGIFåŠ¨ç”»çš„å»¶è¿Ÿåˆå§‹åŒ–ä»¥ä¼˜åŒ–æ€§èƒ½ã€‚
 */
WorkflowCard::WorkflowCard(const WorkflowInfo& info, QWidget* parent)
    : QWidget(parent)
    , m_info(info)
    , m_scale(1.0)
    , m_currentScale(1.0)
    , m_isHovering(false)
    , m_backgroundLabel(nullptr)
{
    setupUi();
    
    // è®¾ç½®ç¼©æ”¾åŠ¨ç”»
    m_scaleAnimation->setDuration(200);
    m_scaleAnimation->setEasingCurve(QEasingCurve::OutCubic);
    
    // åˆå§‹åŒ–GIFåŠ¨ç”» - å»¶è¿Ÿåˆå§‹åŒ–
    if (!m_info.gifPath.isEmpty()) {
        m_movie = nullptr; // å»¶è¿Ÿåˆå§‹åŒ–ï¼Œåœ¨enterEventä¸­åˆ›å»º
        qDebug() << "GIFè·¯å¾„å·²è®¾ç½®ï¼Œå°†å»¶è¿Ÿåˆå§‹åŒ–:" << m_info.gifPath;
    }
    
    // æ·»åŠ é˜´å½±æ•ˆæœ
    auto *shadowEffect = new QGraphicsDropShadowEffect(this);
    shadowEffect->setBlurRadius(15);
    shadowEffect->setColor(QColor(0, 0, 0, 80));
    shadowEffect->setOffset(0, 5);
    this->setGraphicsEffect(shadowEffect);
    
    // è®¾ç½®é¼ æ ‡è·Ÿè¸ª
    this->setMouseTracking(true);
}

/**
 * @brief è®¾ç½®UIç•Œé¢
 * 
 * åˆ›å»ºå¡ç‰‡çš„ä¸»è¦UIç»„ä»¶ï¼ŒåŒ…æ‹¬èƒŒæ™¯å›¾ç‰‡ã€æ–‡å­—å®¹å™¨ã€åç§°å’Œæè¿°æ ‡ç­¾ã€‚
 * è®¾ç½®16:9æ¯”ä¾‹çš„å¡ç‰‡å¤§å°ï¼Œå¹¶é…ç½®æ ·å¼è¡¨å’Œå¸ƒå±€ã€‚
 */
void WorkflowCard::setupUi()
{
    // è®¾ç½®16:9æ¯”ä¾‹çš„å¡ç‰‡å¤§å° (320x180)
    this->setFixedSize(320, 180);
    this->setStyleSheet(
        "WorkflowCard {"
        "    background-color: #252525;"
        "    border: 1px solid #444444;"
        "    border-radius: 12px;"
        "}"
        "WorkflowCard:hover {"
        "    border: 1px solid #666666;"
        "}"
    );
    
    // ä¸»å¸ƒå±€
    QVBoxLayout *mainLayout = new QVBoxLayout(this);
    mainLayout->setContentsMargins(0, 0, 0, 0);
    mainLayout->setSpacing(0);
    
    // åˆ›å»ºèƒŒæ™¯å›¾ç‰‡æ ‡ç­¾
    m_backgroundLabel = new QLabel(this);
    m_backgroundLabel->setFixedSize(320, 180);
    m_backgroundLabel->setScaledContents(true);
    m_backgroundLabel->lower(); // ç¡®ä¿èƒŒæ™¯åœ¨æœ€åº•å±‚
    
    // æ–‡å­—å®¹å™¨ï¼ˆåœ¨æœ€å·¦ä¸Šè§’ï¼‰
    QWidget *textContainer = new QWidget(m_backgroundLabel);
    textContainer->setStyleSheet(
        "background: rgba(0, 0, 0, 120);"
        "border-radius: 8px;"
    );
    textContainer->setGeometry(0, 0, 288, 80); // å¢åŠ é«˜åº¦ä»¥å®¹çº³æ›´å¤§çš„æ–‡å­—
    
    QVBoxLayout *textLayout = new QVBoxLayout(textContainer);// è®¾ç½®å¸ƒå±€è¾¹è·å’Œé—´è·
    textLayout->setContentsMargins(8, 8, 8, 8); // è°ƒæ•´è¾¹è·ä»¥é€‚åº”æ›´å¤§çš„å®¹å™¨
    textLayout->setSpacing(6); // å¢åŠ é—´è·ä»¥é€‚åº”æ›´å¤§çš„æ–‡å­—
    textLayout->setAlignment(Qt::AlignTop | Qt::AlignLeft);
    
    // åç§°æ ‡ç­¾
    m_nameLabel = new QLabel(m_info.name, textContainer);
    m_nameLabel->setStyleSheet(
        "font-size: 18px;"
        "font-weight: 600;"
        "color: white;"
        "background: transparent;"
        "padding: 0;"
        "margin: 0;"
        "border: none"
    );
    
    // æè¿°æ ‡ç­¾
    m_descriptionLabel = new QLabel(m_info.description, textContainer);
    m_descriptionLabel->setStyleSheet(
        "font-size: 14px;"
        "font-weight: 400;"
        "color: #cccccc;"
        "background: transparent;"
        "padding: 0;"
        "margin: 0;"
        "border: none;"
        "min-height: 40px;" // å¢åŠ æœ€å°é«˜åº¦
    );
    m_descriptionLabel->setWordWrap(true);
    m_descriptionLabel->setMaximumWidth(250);
    m_descriptionLabel->setMinimumHeight(40); // è®¾ç½®æœ€å°é«˜åº¦
    
    textLayout->addWidget(m_nameLabel);
    textLayout->addWidget(m_descriptionLabel);
    
    mainLayout->addWidget(m_backgroundLabel);
    
    // åˆ›å»ºç¼©æ”¾åŠ¨ç”»
    m_scaleAnimation = new QPropertyAnimation(this, "scale", this);
    
    // è®¾ç½®åˆå§‹é™æ€å›¾ç‰‡
    updateBackgroundImage();
}

/**
 * @brief æ›´æ–°èƒŒæ™¯å›¾ç‰‡
 * 
 * æ ¹æ®å½“å‰çŠ¶æ€æ›´æ–°èƒŒæ™¯å›¾ç‰‡ï¼Œä¼˜å…ˆä½¿ç”¨GIFåŠ¨ç”»çš„å½“å‰å¸§ï¼Œ
 * å¦‚æœæ²¡æœ‰GIFåŠ¨ç”»åˆ™ä½¿ç”¨é™æ€å›¾ç‰‡ï¼Œå¦‚æœéƒ½æ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤èƒŒæ™¯ã€‚
 */
void WorkflowCard::updateBackgroundImage()
{
    // å¦‚æœæœ‰GIFåŠ¨ç”»æ­£åœ¨æ’­æ”¾ï¼Œä½¿ç”¨GIFå½“å‰å¸§
    if (m_movie && m_movie->isValid() && m_movie->state() == QMovie::Running) {
        QPixmap currentFrame = m_movie->currentPixmap();
        if (!currentFrame.isNull()) {
            m_backgroundLabel->setPixmap(currentFrame);
            m_backgroundLabel->setVisible(true);
            qDebug() << "æ›´æ–°èƒŒæ™¯å›¾ç‰‡ä¸ºGIFå½“å‰å¸§";
        } else {
            qDebug() << "GIFå½“å‰å¸§ä¸ºç©º";
        }
    } else {
        // ä½¿ç”¨é™æ€å›¾ç‰‡
        if (!m_info.imagePath.isEmpty()) {
            QPixmap pixmap(m_info.imagePath);
            if (!pixmap.isNull()) {
                m_backgroundLabel->setPixmap(pixmap);
                m_backgroundLabel->setVisible(true);
                qDebug() << "æ›´æ–°èƒŒæ™¯å›¾ç‰‡ä¸ºé™æ€å›¾ç‰‡:" << m_info.imagePath;
            } else {
                qDebug() << "æ— æ³•åŠ è½½é™æ€å›¾ç‰‡:" << m_info.imagePath;
                // ä½¿ç”¨é»˜è®¤èƒŒæ™¯
                QPixmap defaultPixmap(320, 180);
                defaultPixmap.fill(QColor(40, 40, 40));
                m_backgroundLabel->setPixmap(defaultPixmap);
            }
        } else {
            m_backgroundLabel->clear();
            m_backgroundLabel->setVisible(false);
            qDebug() << "èƒŒæ™¯å›¾ç‰‡è·¯å¾„ä¸ºç©ºï¼Œéšè—èƒŒæ™¯";
        }
    }
}

/**
 * @brief è®¾ç½®å¡ç‰‡ç¼©æ”¾æ¯”ä¾‹
 * @param scale ç¼©æ”¾æ¯”ä¾‹å€¼
 * 
 * è®¾ç½®å¡ç‰‡çš„ç¼©æ”¾æ¯”ä¾‹ï¼Œé™åˆ¶åœ¨0.5åˆ°2.0ä¹‹é—´ï¼Œ
 * è§¦å‘é‡ç»˜å¹¶å‘å‡ºç¼©æ”¾å˜åŒ–ä¿¡å·ã€‚
 */
void WorkflowCard::setScale(qreal scale)
{
    // é™åˆ¶ç¼©æ”¾èŒƒå›´åœ¨0.5åˆ°2.0ä¹‹é—´
    qreal boundedScale = qBound(0.5, scale, 2.0);
    
    if (m_scale != boundedScale) {
        m_scale = boundedScale;
        m_currentScale = boundedScale;
        
        // è§¦å‘é‡ç»˜ä»¥åº”ç”¨æ–°çš„ç¼©æ”¾
        this->update();
        
        // å¯é€‰ï¼šå‘å‡ºç¼©æ”¾å˜åŒ–ä¿¡å·
        emit scaleChanged(m_scale);
    }
}

/**
 * @brief é¼ æ ‡è¿›å…¥äº‹ä»¶å¤„ç†
 * @param event é¼ æ ‡è¿›å…¥äº‹ä»¶
 * 
 * å¤„ç†é¼ æ ‡æ‚¬åœæ•ˆæœï¼Œå¼€å§‹GIFåŠ¨ç”»ï¼Œæ›´æ–°èƒŒæ™¯å›¾ç‰‡å’Œé¼ æ ‡æ ·å¼ã€‚
 */
void WorkflowCard::enterEvent(QEnterEvent *event)
{
    m_isHovering = true;
    
    // ç§»é™¤ç¼©æ”¾åŠ¨ç”»ï¼Œä¿æŒå¡ç‰‡åŸå§‹å¤§å°
    // å¼€å§‹GIFåŠ¨ç”»
    startGifAnimation();
    
    // æ›´æ–°èƒŒæ™¯å›¾ç‰‡
    updateBackgroundImage();
    
    // æ›´æ–°é¼ æ ‡æ ·å¼
    this->setCursor(Qt::PointingHandCursor);
    
    QWidget::enterEvent(event);
}

/**
 * @brief é¼ æ ‡ç¦»å¼€äº‹ä»¶å¤„ç†
 * @param event é¼ æ ‡ç¦»å¼€äº‹ä»¶
 * 
 * å¤„ç†é¼ æ ‡ç¦»å¼€æ•ˆæœï¼Œåœæ­¢GIFåŠ¨ç”»ï¼Œæ¢å¤èƒŒæ™¯å›¾ç‰‡å’Œé¼ æ ‡æ ·å¼ã€‚
 */
void WorkflowCard::leaveEvent(QEvent *event)
{
    m_isHovering = false;
    
    // åœæ­¢GIFåŠ¨ç”»
    stopGifAnimation();
    
    // æ›´æ–°èƒŒæ™¯å›¾ç‰‡
    updateBackgroundImage();
    
    // æ¢å¤é¼ æ ‡æ ·å¼
    this->setCursor(Qt::ArrowCursor);
    
    QWidget::leaveEvent(event);
}

/**
 * @brief é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶å¤„ç†
 * @param event é¼ æ ‡äº‹ä»¶
 * 
 * å¤„ç†é¼ æ ‡ç‚¹å‡»äº‹ä»¶ï¼Œå½“å·¦é”®ç‚¹å‡»æ—¶å‘å‡ºclickedä¿¡å·ã€‚
 */
void WorkflowCard::mousePressEvent(QMouseEvent *event)
{
    if (event->button() == Qt::LeftButton) {
        emit clicked(m_info);
    }
    QWidget::mousePressEvent(event);
}

/**
 * @brief çª—å£å¤§å°æ”¹å˜äº‹ä»¶å¤„ç†
 * @param event å¤§å°æ”¹å˜äº‹ä»¶
 * 
 * å¤„ç†çª—å£å¤§å°æ”¹å˜ï¼Œè§¦å‘é‡ç»˜ä»¥ç¡®ä¿UIæ­£ç¡®æ˜¾ç¤ºã€‚
 */
void WorkflowCard::resizeEvent(QResizeEvent *event)
{
    QWidget::resizeEvent(event);
    this->update(); // ç›´æ¥è°ƒç”¨update()è§¦å‘é‡ç»˜
}

/**
 * @brief ç»˜åˆ¶äº‹ä»¶å¤„ç†
 * @param event ç»˜åˆ¶äº‹ä»¶
 * 
 * é‡å†™ç»˜åˆ¶äº‹ä»¶ï¼Œæ˜ç¡®ä¸å¤„ç†èƒŒæ™¯ç»˜åˆ¶ï¼Œå®Œå…¨ç”±QLabelè´Ÿè´£ã€‚
 * æ­¤æ–¹æ³•ä»…ä¿ç•™ä½œä¸ºå ä½ï¼Œç¡®ä¿ä¸ä¼šæ„å¤–ç»˜åˆ¶èƒŒæ™¯ã€‚
 */
void WorkflowCard::paintEvent(QPaintEvent *event)
{
    // æ˜ç¡®ä¸å¤„ç†èƒŒæ™¯ç»˜åˆ¶ï¼Œå®Œå…¨ç”±QLabelè´Ÿè´£
    // æ­¤æ–¹æ³•ä»…ä¿ç•™ä½œä¸ºå ä½ï¼Œç¡®ä¿ä¸ä¼šæ„å¤–ç»˜åˆ¶èƒŒæ™¯
    QWidget::paintEvent(event);
}

/**
 * @brief å¼€å§‹GIFåŠ¨ç”»
 * 
 * å»¶è¿Ÿåˆå§‹åŒ–GIFåŠ¨ç”»ï¼Œè¿æ¥å¸§æ›´æ–°ä¿¡å·ï¼Œå¯åŠ¨åŠ¨ç”»æ’­æ”¾ã€‚
 * æ”¯æŒGIFåŠ¨ç”»çš„ç¼“å­˜å’Œé”™è¯¯å¤„ç†ã€‚
 */
void WorkflowCard::startGifAnimation()
{
    // å»¶è¿Ÿåˆå§‹åŒ–GIF
    if (!m_info.gifPath.isEmpty() && !m_movie) {
        qDebug() << "å»¶è¿Ÿåˆå§‹åŒ–GIF:" << m_info.gifPath;
        m_movie = new QMovie(m_info.gifPath, QByteArray(), this);
        m_movie->setCacheMode(QMovie::CacheAll);
        
        if (!m_movie->isValid()) {
            qDebug() << "æ— æ³•åŠ è½½GIF:" << m_info.gifPath << "é”™è¯¯:" << m_movie->lastErrorString();
            delete m_movie;
            m_movie = nullptr;
            return;
        }
        
        qDebug() << "æˆåŠŸåŠ è½½GIF:" << m_info.gifPath << "å¸§æ•°:" << m_movie->frameCount();
        
        // è¿æ¥GIFå¸§æ›´æ–°ä¿¡å·ï¼Œè§¦å‘é‡ç»˜
        connect(m_movie, &QMovie::frameChanged, this, [this](int frameNumber) {
            Q_UNUSED(frameNumber)
            updateBackgroundImage();
        });
    }
    
    if (m_movie && m_movie->isValid()) {
        qDebug() << "å¯åŠ¨GIFåŠ¨ç”»:" << m_info.gifPath;
        m_movie->start();
        
        // ç¡®ä¿GIFæ­£åœ¨æ’­æ”¾
        if (m_movie->state() != QMovie::Running) {
            qDebug() << "GIFæœªèƒ½å¯åŠ¨ï¼ŒçŠ¶æ€:" << m_movie->state();
        }
        
        // æ›´æ–°èƒŒæ™¯å›¾ç‰‡
        updateBackgroundImage();
    } else {
        qDebug() << "æ— æ³•å¯åŠ¨GIFåŠ¨ç”»ï¼Œmovieæ— æ•ˆæˆ–è·¯å¾„ä¸ºç©º";
    }
}

/**
 * @brief åœæ­¢GIFåŠ¨ç”»
 * 
 * åœæ­¢GIFåŠ¨ç”»æ’­æ”¾ï¼Œé‡ç½®åˆ°ç¬¬ä¸€å¸§ï¼Œç¡®ä¿ä¸‹æ¬¡æ’­æ”¾ä»å¤´å¼€å§‹ã€‚
 */
void WorkflowCard::stopGifAnimation()
{
    if (m_movie && m_movie->isValid()) {
        qDebug() << "åœæ­¢GIFåŠ¨ç”»:" << m_info.gifPath;
        m_movie->stop();
        
        // é‡ç½®GIFåˆ°ç¬¬ä¸€å¸§ï¼Œç¡®ä¿ä¸‹æ¬¡æ’­æ”¾ä»å¤´å¼€å§‹
        m_movie->jumpToFrame(0);
        
        // æ›´æ–°èƒŒæ™¯å›¾ç‰‡
        updateBackgroundImage();
    }
}


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\WorkflowCard.cpp ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\WorkflowCard.h ---

/**
 * @file WorkflowCard.h
 * @brief å·¥ä½œæµå¡ç‰‡ç»„ä»¶å¤´æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†WorkflowCardç±»ï¼Œç”¨äºæ˜¾ç¤ºå·¥ä½œæµå¡ç‰‡ï¼Œæ”¯æŒé™æ€å›¾ç‰‡å’ŒGIFåŠ¨ç”»èƒŒæ™¯ï¼Œ
 * åŒ…å«é¼ æ ‡æ‚¬åœæ•ˆæœã€ç¼©æ”¾åŠ¨ç”»å’Œæ–‡å­—ä¿¡æ¯å±•ç¤ºåŠŸèƒ½ã€‚
 * 
 * @author ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆ
 * @version 1.0
 * @date 2024
 */

#pragma once
#include <QWidget>
#include <QLabel>
#include <QMovie>
#include <QPropertyAnimation>
#include <QGraphicsDropShadowEffect>
#include "../../Model/WorkflowTypes.h"

/**
 * @class WorkflowCard
 * @brief å·¥ä½œæµå¡ç‰‡ç»„ä»¶ç±»
 * 
 * è¯¥ç±»å®ç°äº†ä¸€ä¸ªå¯äº¤äº’çš„å·¥ä½œæµå¡ç‰‡ï¼Œæ”¯æŒä»¥ä¸‹åŠŸèƒ½ï¼š
 * - æ˜¾ç¤ºå·¥ä½œæµåç§°å’Œæè¿°
 * - æ”¯æŒé™æ€å›¾ç‰‡å’ŒGIFåŠ¨ç”»èƒŒæ™¯
 * - é¼ æ ‡æ‚¬åœæ—¶æ’­æ”¾GIFåŠ¨ç”»
 * - ç¼©æ”¾åŠ¨ç”»æ•ˆæœ
 * - ç‚¹å‡»äº‹ä»¶å¤„ç†
 */
class WorkflowCard : public QWidget {
    Q_OBJECT
    // æ·»åŠ ä¸€ä¸ªå±æ€§ç”¨äºç¼©æ”¾åŠ¨ç”»
    Q_PROPERTY(qreal scale READ scale WRITE setScale)

public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param info å·¥ä½œæµä¿¡æ¯ç»“æ„ä½“
     * @param parent çˆ¶çª—å£æŒ‡é’ˆ
     */
    explicit WorkflowCard(const WorkflowInfo& info, QWidget* parent = nullptr);
    
    /**
     * @brief è·å–å·¥ä½œæµä¿¡æ¯
     * @return å·¥ä½œæµä¿¡æ¯ç»“æ„ä½“å¼•ç”¨
     */
    const WorkflowInfo& workflowInfo() const { return m_info; }
    
    /**
     * @brief è·å–å½“å‰ç¼©æ”¾æ¯”ä¾‹
     * @return ç¼©æ”¾æ¯”ä¾‹å€¼
     */
    qreal scale() const { return m_scale; }
    
    /**
     * @brief è®¾ç½®ç¼©æ”¾æ¯”ä¾‹
     * @param scale ç¼©æ”¾æ¯”ä¾‹å€¼
     */
    void setScale(qreal scale);

signals:
    /**
     * @brief å¡ç‰‡ç‚¹å‡»ä¿¡å·
     * @param info è¢«ç‚¹å‡»çš„å·¥ä½œæµä¿¡æ¯
     */
    void clicked(const WorkflowInfo& info);
    
    /**
     * @brief ç¼©æ”¾å˜åŒ–ä¿¡å·
     * @param scale æ–°çš„ç¼©æ”¾æ¯”ä¾‹å€¼
     */
    void scaleChanged(qreal scale);

protected:
    /**
     * @brief ç»˜åˆ¶äº‹ä»¶å¤„ç†
     * @param event ç»˜åˆ¶äº‹ä»¶
     */
    void paintEvent(QPaintEvent* event) override;
    
    /**
     * @brief é¼ æ ‡è¿›å…¥äº‹ä»¶å¤„ç†
     * @param event é¼ æ ‡è¿›å…¥äº‹ä»¶
     */
    void enterEvent(QEnterEvent* event) override;
    
    /**
     * @brief é¼ æ ‡ç¦»å¼€äº‹ä»¶å¤„ç†
     * @param event é¼ æ ‡ç¦»å¼€äº‹ä»¶
     */
    void leaveEvent(QEvent* event) override;
    
    /**
     * @brief é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶å¤„ç†
     * @param event é¼ æ ‡äº‹ä»¶
     */
    void mousePressEvent(QMouseEvent* event) override;
    
    /**
     * @brief çª—å£å¤§å°æ”¹å˜äº‹ä»¶å¤„ç†
     * @param event å¤§å°æ”¹å˜äº‹ä»¶
     */
    void resizeEvent(QResizeEvent* event) override;

private:
    /**
     * @brief è®¾ç½®UIç•Œé¢
     */
    void setupUi();
    
    /**
     * @brief å¼€å§‹GIFåŠ¨ç”»
     */
    void startGifAnimation();
    
    /**
     * @brief åœæ­¢GIFåŠ¨ç”»
     */
    void stopGifAnimation();
    
    /**
     * @brief æ›´æ–°èƒŒæ™¯å›¾ç‰‡
     */
    void updateBackgroundImage();

private:
    WorkflowInfo m_info;              ///< å·¥ä½œæµä¿¡æ¯
    qreal m_scale = 1.0;              ///< å½“å‰ç¼©æ”¾æ¯”ä¾‹
    qreal m_currentScale = 1.0;       ///< å®é™…ç¼©æ”¾æ¯”ä¾‹
    bool m_isHovering = false;        ///< é¼ æ ‡æ‚¬åœçŠ¶æ€
    
    // UIç»„ä»¶
    QLabel* m_nameLabel = nullptr;        ///< åç§°æ ‡ç­¾
    QLabel* m_descriptionLabel = nullptr; ///< æè¿°æ ‡ç­¾
    QLabel* m_backgroundLabel = nullptr;  ///< èƒŒæ™¯å›¾ç‰‡æ ‡ç­¾
    
    // åŠ¨ç”»ç›¸å…³
    QMovie* m_movie = nullptr;                ///< GIFåŠ¨ç”»å¯¹è±¡
    QPropertyAnimation* m_scaleAnimation = nullptr; ///< ç¼©æ”¾åŠ¨ç”»å¯¹è±¡
    
    // é™æ€å›¾ç‰‡å’ŒGIFè·¯å¾„
    QString m_imagePath; ///< é™æ€å›¾ç‰‡è·¯å¾„
    QString m_gifPath;   ///< GIFåŠ¨ç”»è·¯å¾„
};

--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\WorkflowCard.h ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\WorkflowSelector.cpp ---

/**
 * @file WorkflowSelector.cpp
 * @brief å·¥ä½œæµé€‰æ‹©å™¨ç»„ä»¶å®ç°æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®ç°äº†WorkflowSelectorç±»ï¼Œç”¨äºæ˜¾ç¤ºå·¥ä½œæµé€‰æ‹©å¼¹å‡ºçª—å£ã€‚
 * åŒ…å«å·¥ä½œæµå¡ç‰‡çš„å¸ƒå±€ç®¡ç†ã€çª—å£æ ·å¼è®¾ç½®ã€äº‹ä»¶å¤„ç†ç­‰åŠŸèƒ½ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#include "WorkflowSelector.h"
#include "WorkflowCard.h"
#include <QVBoxLayout>
#include <QScrollArea>
#include <QPainter>
#include <QApplication>
#include <QScreen>
#include <QLabel>
#include <QMouseEvent>

/**
 * @brief æ„é€ å‡½æ•°
 * @param parent çˆ¶çª—å£æŒ‡é’ˆ
 * 
 * åˆå§‹åŒ–å·¥ä½œæµé€‰æ‹©å™¨çª—å£ï¼Œè®¾ç½®çª—å£å±æ€§å¹¶åˆ›å»ºUIç•Œé¢ã€‚
 * é¢„ç½®äº†å››ç§å·¥ä½œæµç±»å‹ï¼šæ–‡ç”Ÿå›¾ã€å›¾ç”Ÿå›¾ã€å±€éƒ¨é‡ç»˜ã€å›¾åƒæ”¾å¤§ã€‚
 */
WorkflowSelector::WorkflowSelector(QWidget* parent) : QWidget(parent) {
    // è®¾ç½®çª—å£å±æ€§ï¼šPopup ç±»å‹(æ— æ ‡é¢˜æ )ï¼Œé€æ˜èƒŒæ™¯
    setWindowFlags(Qt::Popup | Qt::FramelessWindowHint);
    setAttribute(Qt::WA_TranslucentBackground);
    
    // åˆå§‹åŒ–æµ‹è¯•å·¥ä½œæµæ•°æ®
    m_workflows.append(WorkflowInfo(1, "æ–‡ç”Ÿå›¾", ":/images/æ–‡ç”Ÿå›¾æ¼”ç¤º.png", ":/images/æ–‡ç”Ÿå›¾æ¼”ç¤º.gif", "åŸºç¡€ç”Ÿæˆæ¨¡å¼ï¼Œä»æ–‡å­—åˆ›å»ºå›¾åƒ", WorkflowType::TextToImage));
    m_workflows.append(WorkflowInfo(2, "å›¾ç”Ÿå›¾", ":/images/å›¾ç”Ÿå›¾æ¼”ç¤º.png", ":/images/å›¾ç”Ÿå›¾æ¼”ç¤º.gif", "åŸºäºå‚è€ƒå›¾ç”Ÿæˆæ–°å›¾åƒ", WorkflowType::ImageToImage));
    
    setupUi();
}

/**
 * @brief ææ„å‡½æ•°
 * 
 * Qtä¼šè‡ªåŠ¨æ¸…ç†å­æ§ä»¶ï¼Œæ— éœ€æ‰‹åŠ¨åˆ é™¤ã€‚
 */
WorkflowSelector::~WorkflowSelector() {
    // Qtä¼šè‡ªåŠ¨æ¸…ç†å­æ§ä»¶ï¼Œæ— éœ€æ‰‹åŠ¨åˆ é™¤
}

/**
 * @brief åˆå§‹åŒ–UIç•Œé¢
 * 
 * åˆ›å»ºå·¥ä½œæµé€‰æ‹©å™¨çš„æ‰€æœ‰UIç»„ä»¶ï¼ŒåŒ…æ‹¬ï¼š
 * - ä¸»å¸ƒå±€å’Œå®¹å™¨
 * - æ ‡é¢˜æ ‡ç­¾
 * - æ»šåŠ¨åŒºåŸŸå’Œå¡ç‰‡å¸ƒå±€
 * - å·¥ä½œæµå¡ç‰‡
 */
void WorkflowSelector::setupUi() {
    // ä¸»å¸ƒå±€ï¼šç•™å‡ºé˜´å½±çš„è¾¹è· (Margin = 3)
    m_mainLayout = new QVBoxLayout(this);
    m_mainLayout->setContentsMargins(3, 3, 3, 3);
    
    // å®ä½“å®¹å™¨ (æ·±è‰²åº•è‰²çš„æ¡†)
    m_container = new QWidget(this);
    m_container->setObjectName("Container");
    m_container->setStyleSheet(
        "QWidget#Container {"
        "  background-color: #2a2a2a;" // æ·±ç°èƒŒæ™¯
        "  border: 1px solid #444;"
        "  border-radius: 12px;"       // åœ†è§’
        "}"
    );
    
    // ç»™å®¹å™¨åŠ é˜´å½±
    QGraphicsDropShadowEffect* shadow = new QGraphicsDropShadowEffect(this);
    shadow->setBlurRadius(25);
    shadow->setColor(QColor(0, 0, 0, 100));
    shadow->setOffset(0, 8);
    m_container->setGraphicsEffect(shadow);
    
    // å®¹å™¨å†…éƒ¨å¸ƒå±€
    m_containerLayout = new QVBoxLayout(m_container);
    m_containerLayout->setContentsMargins(20, 20, 20, 20);
    m_containerLayout->setSpacing(15);
    
    // æ ‡é¢˜
    QLabel* title = new QLabel("é€‰æ‹©å·¥ä½œæµ", m_container);
    title->setStyleSheet("color: white; font-size: 18px; font-weight: bold; border: none; background: transparent;");
    m_containerLayout->addWidget(title);
    
    // æ»šåŠ¨åŒºåŸŸ
    m_scrollArea = new QScrollArea(m_container);
    m_scrollArea->setStyleSheet(
        "QScrollArea { background: #343541; border: none; }"
        "QScrollBar:vertical { border: none; background: #343541; width: 10px; margin: 0px; }"
        "QScrollBar::handle:vertical { background: #565869; min-height: 20px; border-radius: 5px; }"
        "QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0px; }"
        "QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical { background: none; }"
    );
    m_scrollArea->setWidgetResizable(true);
    m_scrollArea->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
    
    // å¡ç‰‡åˆ—è¡¨å®¹å™¨
    m_scrollContent = new QWidget();
    m_scrollContent->setStyleSheet("background: transparent;");
    
    // å‚ç›´å¸ƒå±€æ”¾å¡ç‰‡
    m_cardsLayout = new QVBoxLayout(m_scrollContent);
    m_cardsLayout->setContentsMargins(0, 0, 10, 0); // å³è¾¹ç•™ç‚¹ç©ºç»™æ»šåŠ¨æ¡
    m_cardsLayout->setSpacing(15);
    
    // æ·»åŠ å¡ç‰‡
    createWorkflowCards();
    
    m_scrollArea->setWidget(m_scrollContent);
    m_containerLayout->addWidget(m_scrollArea);
    
    m_mainLayout->addWidget(m_container);
    
    // è®¾ç½®çª—å£å¤§å°ï¼šå¡ç‰‡å®½320 + å†…å¤–è¾¹è·
    this->setFixedSize(380, 500);
}

/**
 * @brief åˆ›å»ºå·¥ä½œæµå¡ç‰‡
 * 
 * æ ¹æ®å·¥ä½œæµæ•°æ®åˆ›å»ºå¯¹åº”çš„å¡ç‰‡ç»„ä»¶ï¼Œå¹¶è®¾ç½®ç‚¹å‡»äº‹ä»¶è¿æ¥ã€‚
 * æ¸…é™¤ç°æœ‰å¡ç‰‡åé‡æ–°åˆ›å»ºï¼Œç¡®ä¿æ•°æ®åŒæ­¥ã€‚
 */
void WorkflowSelector::createWorkflowCards() {
    // æ¸…é™¤ç°æœ‰å¡ç‰‡
    QLayoutItem* item;
    while ((item = m_cardsLayout->takeAt(0)) != nullptr) {
        if (item->widget()) {
            item->widget()->deleteLater();
        }
        delete item;
    }
    m_workflowCards.clear();
    
    // åˆ›å»ºæ–°å¡ç‰‡
    for (const auto& workflow : m_workflows) {
        WorkflowCard* card = new WorkflowCard(workflow, m_scrollContent);
        
        connect(card, &WorkflowCard::clicked, this, [this](const WorkflowInfo& info) {
            emit workflowSelected(info);
            this->hide();
        });
        
        m_workflowCards.append(card);
        m_cardsLayout->addWidget(card, 0, Qt::AlignHCenter); // å±…ä¸­æ·»åŠ 
    }
    
    // æ·»åŠ åº•éƒ¨å¼¹ç°§ï¼Œé˜²æ­¢å¡ç‰‡ç´§è´´åº•éƒ¨
    m_cardsLayout->addStretch();
}

/**
 * @brief è®¾ç½®å·¥ä½œæµæ•°æ®
 * @param workflows å·¥ä½œæµä¿¡æ¯å‘é‡
 * 
 * æ›´æ–°å·¥ä½œæµæ•°æ®å¹¶é‡æ–°åˆ›å»ºå¡ç‰‡ï¼Œç”¨äºåŠ¨æ€æ›´æ–°å·¥ä½œæµåˆ—è¡¨ã€‚
 */
void WorkflowSelector::setWorkflows(const QVector<WorkflowInfo>& workflows) {
    m_workflows = workflows;
    createWorkflowCards();
}

/**
 * @brief ç»˜åˆ¶äº‹ä»¶å¤„ç†
 * @param event ç»˜åˆ¶äº‹ä»¶
 * 
 * ä½¿ç”¨é€æ˜æ¨¡å¼ç»˜åˆ¶çª—å£èƒŒæ™¯ï¼Œç¡®ä¿çª—å£å®Œå…¨é€æ˜ã€‚
 * è¿™æ˜¯å®ç°æ— è¾¹æ¡†é€æ˜çª—å£çš„å…³é”®æ–¹æ³•ã€‚
 */
void WorkflowSelector::paintEvent(QPaintEvent* event) {
    Q_UNUSED(event);
    QPainter p(this);
    // ç”¨ "Clear" æ¨¡å¼æŠŠæ•´ä¸ªçª—å£åˆ·æˆå®Œå…¨é€æ˜
    // è¿™æ ·æ“ä½œç³»ç»Ÿå°±ä¸ä¼šç»˜åˆ¶é»‘è‰²åº•è‰²äº†
    p.setCompositionMode(QPainter::CompositionMode_Clear);
    p.fillRect(rect(), Qt::transparent);
}

/**
 * @brief äº‹ä»¶å¤„ç†
 * @param event äº‹ä»¶å¯¹è±¡
 * @return æ˜¯å¦å¤„ç†äº†è¯¥äº‹ä»¶
 * 
 * å¤„ç†çª—å£å¤±å»ç„¦ç‚¹äº‹ä»¶ï¼Œå½“ç”¨æˆ·ç‚¹å‡»çª—å£å¤–éƒ¨æ—¶è‡ªåŠ¨å…³é—­çª—å£ã€‚
 */
bool WorkflowSelector::event(QEvent* event) {
    // å¦‚æœçª—å£å¤±å»ç„¦ç‚¹ï¼ˆç”¨æˆ·ç‚¹äº†åˆ«å¤„ï¼‰ï¼Œå°±éšè—
    if (event->type() == QEvent::WindowDeactivate) {
        this->hide();
        return true;
    }
    return QWidget::event(event);
}

/**
 * @brief å¼¹å‡ºçª—å£
 * @param pos å¼¹å‡ºä½ç½®ï¼ˆç›¸å¯¹äºå±å¹•åæ ‡ï¼‰
 * 
 * åœ¨æŒ‡å®šä½ç½®å¼¹å‡ºå·¥ä½œæµé€‰æ‹©çª—å£ï¼Œè‡ªåŠ¨è°ƒæ•´ä½ç½®ç¡®ä¿ä¸è¶…å‡ºå±å¹•è¾¹ç•Œã€‚
 * å¦‚æœä¸Šæ–¹ç©ºé—´ä¸è¶³ï¼Œä¼šè‡ªåŠ¨æ˜¾ç¤ºåœ¨ä¸‹æ–¹ã€‚
 */
void WorkflowSelector::popup(const QPoint& pos) {
    // è®¡ç®—çª—å£ä½ç½®ï¼Œç¡®ä¿ä¸è¶…å‡ºå±å¹•è¾¹ç•Œ
    int x = pos.x() - width() / 2;
    int y = pos.y() - height() - 10;
    
    // è·å–å±å¹•å°ºå¯¸
    QScreen* screen = QApplication::primaryScreen();
    QRect screenGeometry = screen->geometry();
    
    // é˜²æ­¢çª—å£è¶…å‡ºå±å¹•è¾¹ç•Œ
    if (x < 10) x = 10;
    if (x + width() > screenGeometry.width() - 10) x = screenGeometry.width() - width() - 10;
    
    if (y < 10) {
        // å¦‚æœä¸Šæ–¹ç©ºé—´ä¸è¶³ï¼Œæ˜¾ç¤ºåœ¨ä¸‹æ–¹
        y = pos.y() + 20;
    }
    if (y + height() > screenGeometry.height() - 10) {
        y = screenGeometry.height() - height() - 10;
    }
    
    move(x, y);
    show();
    raise();
    setFocus();
}


--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\WorkflowSelector.cpp ---

--- æ–‡ä»¶å¼€å§‹: src\Ui\Components\WorkflowSelector.h ---

/**
 * @file WorkflowSelector.h
 * @brief å·¥ä½œæµé€‰æ‹©å™¨ç»„ä»¶å¤´æ–‡ä»¶
 * 
 * è¯¥æ–‡ä»¶å®šä¹‰äº†WorkflowSelectorç±»ï¼Œç”¨äºæ˜¾ç¤ºå·¥ä½œæµé€‰æ‹©å¼¹å‡ºçª—å£ã€‚
 * åŒ…å«å·¥ä½œæµå¡ç‰‡çš„å¸ƒå±€ç®¡ç†ã€çª—å£æ ·å¼è®¾ç½®ã€äº‹ä»¶å¤„ç†ç­‰å£°æ˜ã€‚
 * 
 * @author CloudArt Team
 * @version 1.0
 * @date 2024
 */

#pragma once
#include <QWidget>
#include <QVBoxLayout>
#include <QScrollArea>
#include <QLabel>
#include <QGraphicsDropShadowEffect>
#include "../../Model/WorkflowTypes.h"

class WorkflowCard;

/**
 * @brief å·¥ä½œæµé€‰æ‹©å™¨ç±»
 * 
 * ç»§æ‰¿è‡ªQWidgetï¼Œæä¾›å·¥ä½œæµé€‰æ‹©åŠŸèƒ½çš„å¼¹å‡ºçª—å£ã€‚
 * æ”¯æŒæ˜¾ç¤ºå¤šä¸ªå·¥ä½œæµå¡ç‰‡ï¼Œå…·æœ‰é€æ˜èƒŒæ™¯ã€é˜´å½±æ•ˆæœå’Œè‡ªåŠ¨å…³é—­åŠŸèƒ½ã€‚
 */
class WorkflowSelector : public QWidget {
    Q_OBJECT

public:
    /**
     * @brief æ„é€ å‡½æ•°
     * @param parent çˆ¶çª—å£æŒ‡é’ˆ
     */
    explicit WorkflowSelector(QWidget* parent = nullptr);
    
    /**
     * @brief ææ„å‡½æ•°
     */
    ~WorkflowSelector();
    
    /**
     * @brief å¼¹å‡ºçª—å£
     * @param pos å¼¹å‡ºä½ç½®ï¼ˆç›¸å¯¹äºå±å¹•åæ ‡ï¼‰
     */
    void popup(const QPoint& pos);
    
    /**
     * @brief è®¾ç½®å·¥ä½œæµæ•°æ®
     * @param workflows å·¥ä½œæµä¿¡æ¯å‘é‡
     */
    void setWorkflows(const QVector<WorkflowInfo>& workflows);
    
    /**
     * @brief è·å–å½“å‰å·¥ä½œæµåˆ—è¡¨
     * @return å·¥ä½œæµä¿¡æ¯å‘é‡å¼•ç”¨
     */
    const QVector<WorkflowInfo>& workflows() const { return m_workflows; }

signals:
    /**
     * @brief å·¥ä½œæµé€‰æ‹©ä¿¡å·
     * @param info é€‰ä¸­çš„å·¥ä½œæµä¿¡æ¯
     */
    void workflowSelected(const WorkflowInfo& info);

protected:
    /**
     * @brief ç»˜åˆ¶äº‹ä»¶å¤„ç†
     * @param event ç»˜åˆ¶äº‹ä»¶
     */
    void paintEvent(QPaintEvent* event) override;
    
    /**
     * @brief äº‹ä»¶å¤„ç†
     * @param event äº‹ä»¶å¯¹è±¡
     * @return æ˜¯å¦å¤„ç†äº†è¯¥äº‹ä»¶
     */
    bool event(QEvent* event) override;

private:
    /**
     * @brief åˆå§‹åŒ–UIç•Œé¢
     */
    void setupUi();
    
    /**
     * @brief åˆ›å»ºå·¥ä½œæµå¡ç‰‡
     */
    void createWorkflowCards();

private:
    QVector<WorkflowInfo> m_workflows; ///< å·¥ä½œæµæ•°æ®åˆ—è¡¨
    QVector<WorkflowCard*> m_workflowCards; ///< å·¥ä½œæµå¡ç‰‡æŒ‡é’ˆåˆ—è¡¨
    
    // UIç»„ä»¶
    QVBoxLayout* m_mainLayout = nullptr; ///< ä¸»å¸ƒå±€
    QWidget* m_container = nullptr; ///< å†…å®¹å®¹å™¨
    QVBoxLayout* m_containerLayout = nullptr; ///< å®¹å™¨å¸ƒå±€
    QScrollArea* m_scrollArea = nullptr; ///< æ»šåŠ¨åŒºåŸŸ
    QWidget* m_scrollContent = nullptr; ///< æ»šåŠ¨å†…å®¹
    QVBoxLayout* m_cardsLayout = nullptr; ///< å¡ç‰‡å¸ƒå±€
};

--- æ–‡ä»¶ç»“æŸ: src\Ui\Components\WorkflowSelector.h ---

